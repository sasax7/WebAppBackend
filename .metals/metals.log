2024.10.17 08:48:33 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.17 08:48:35 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.17 08:48:42 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals5659790036057746099\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.17 08:48:49 INFO  sbt thinks that server is already booting because of this exception:
2024.10.17 08:48:49 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-7655597824915523364_lock, error 5
2024.10.17 08:48:49 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:356)
2024.10.17 08:48:49 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:295)
2024.10.17 08:48:49 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:150)
2024.10.17 08:48:49 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:77)
2024.10.17 08:48:49 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:77)
2024.10.17 08:48:49 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:85)
2024.10.17 08:48:49 ERROR 	at sbt.xMain$.run(Main.scala:121)
2024.10.17 08:48:49 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.10.17 08:48:49 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2024.10.17 08:48:49 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.10.17 08:48:49 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
2024.10.17 08:48:49 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:57)
2024.10.17 08:48:49 ERROR 	at sbt.xMain.run(Main.scala:46)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.10.17 08:48:49 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.10.17 08:48:49 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-7655597824915523364_lock, error 5
2024.10.17 08:48:49 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.10.17 08:48:49 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.10.17 08:48:49 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:350)
2024.10.17 08:48:49 ERROR 	... 23 more
2024.10.17 08:48:50 INFO  time: ran 'sbt bloopInstall' in 7.78s
2024.10.17 08:48:50 ERROR sbt command failed: C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals5659790036057746099\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.17 08:52:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:18 INFO  time: code lens generation in 8.94s
2024.10.17 08:52:26 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:27 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:27 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:27 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:28 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:28 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:28 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:30 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:30 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:30 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:33 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:34 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:34 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:34 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:35 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:38 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:46 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.10.17 08:52:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:52:48 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals2858640241740275445\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.17 08:52:54 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.10.17 08:52:59 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.10.17 08:53:00 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.10.17 08:53:05 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 08:53:06 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.10.17 08:53:06 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.10.17 08:53:13 INFO  [success] Generated .bloop\backend-build-build.json
2024.10.17 08:53:13 INFO  [success] Total time: 7 s, completed 17.10.2024, 08:53:13
2024.10.17 08:53:15 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.10.17 08:53:15 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.10.17 08:53:32 INFO  [success] Generated .bloop\backend-build.json
2024.10.17 08:53:33 INFO  [success] Total time: 17 s, completed 17.10.2024, 08:53:33
2024.10.17 08:53:40 INFO  [info] loading settings for project root from build.sbt ...
2024.10.17 08:53:40 INFO  [info]   __              __
2024.10.17 08:53:40 INFO  [info]   \ \     ____   / /____ _ __  __
2024.10.17 08:53:40 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.10.17 08:53:40 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.10.17 08:53:40 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.10.17 08:53:40 INFO  [info]       /_/               /____/
2024.10.17 08:53:40 INFO  [info] 
2024.10.17 08:53:40 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.10.17 08:53:40 INFO  [info] 
2024.10.17 08:53:40 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.10.17 08:53:40 INFO  [info] https://www.playframework.com/sponsors
2024.10.17 08:53:40 INFO  [info] 
2024.10.17 08:53:53 INFO  [success] Generated .bloop\root.json
2024.10.17 08:53:53 INFO  [success] Generated .bloop\root-test.json
2024.10.17 08:53:53 INFO  [success] Total time: 11 s, completed 17.10.2024, 08:53:53
2024.10.17 08:53:54 INFO  time: ran 'sbt bloopInstall' in 1m5s
2024.10.17 08:53:54 INFO  Attempting to connect to the build server...
2024.10.17 08:53:54 INFO  No running Bloop server found, starting one.
2024.10.17 08:53:59 INFO  Starting compilation server
2024.10.17 08:54:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 08:54:25 INFO  Attempting to connect to the build server...
2024.10.17 08:54:25 INFO  Found a Bloop server running
2024.10.17 08:54:25 INFO  Attempting to connect to the build server...
2024.10.17 08:54:25 INFO  Found a Bloop server running
2024.10.17 08:54:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 08:54:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 08:54:40 INFO  time: Connected to build server in 45s
2024.10.17 08:54:40 INFO  Connected to Build server: Bloop v2.0.3
2024.10.17 08:54:40 INFO  time: Imported build in 0.43s
2024.10.17 08:54:40 INFO  running doctor check
2024.10.17 08:54:40 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.17 08:54:49 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.17 08:55:10 INFO  compiling root (1 scala source)
2024.10.17 08:55:18 INFO  time: compiled root in 8.54s
2024.10.17 08:55:18 INFO  compiling root (7 scala sources and 1 java source)
2024.10.17 08:55:40 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 08:55:40 WARN  javac exited with exit code 1
2024.10.17 08:55:40 INFO  time: compiled root in 21s
2024.10.17 08:55:45 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.17 08:57:46 INFO  time: indexed workspace in 3m6s
2024.10.17 08:57:54 INFO  time: code lens generation in 2.48s
2024.10.17 08:58:05 INFO  compiling root (7 scala sources and 1 java source)
Okt. 17, 2024 8:58:12 AM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\.reports\metals-full\2024-10-17\r_compiler-error_(backend-build)_08-58-11-971.md
2024.10.17 08:58:19 INFO  time: code lens generation in 3.44s
2024.10.17 08:58:20 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 08:58:20 WARN  javac exited with exit code 1
2024.10.17 08:58:20 INFO  time: compiled root in 14s
Okt. 17, 2024 8:58:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 208
2024.10.17 09:00:44 INFO  compiling root (8 scala sources and 1 java source)
2024.10.17 09:00:55 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 09:00:55 WARN  javac exited with exit code 1
2024.10.17 09:00:55 INFO  time: compiled root in 11s
2024.10.17 09:01:05 INFO  compiling root (8 scala sources and 1 java source)
2024.10.17 09:01:14 INFO  time: compiled root in 9.66s
2024.10.17 09:01:23 INFO  compiling root (8 scala sources and 1 java source)
2024.10.17 09:01:24 INFO  time: compiled root in 1.18s
2024.10.17 09:01:44 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals2379581469639707273\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.17 09:01:50 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.10.17 09:01:50 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.10.17 09:01:52 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.10.17 09:01:54 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.10.17 09:01:54 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.10.17 09:02:03 INFO  [success] Generated .bloop\backend-build-build.json
2024.10.17 09:02:03 INFO  [success] Total time: 9 s, completed 17.10.2024, 09:02:03
2024.10.17 09:02:04 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.10.17 09:02:04 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.10.17 09:02:09 INFO  [success] Generated .bloop\backend-build.json
2024.10.17 09:02:09 INFO  [success] Total time: 6 s, completed 17.10.2024, 09:02:10
2024.10.17 09:02:14 ERROR C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt:7: error: not found: value PlaySlick
2024.10.17 09:02:14 ERROR   .enablePlugins(PlayScala, PlaySlick)
2024.10.17 09:02:14 ERROR                             ^
2024.10.17 09:02:16 ERROR sbt.compiler.EvalException: Type error in expression
2024.10.17 09:02:16 INFO  [error] sbt.compiler.EvalException: Type error in expression
2024.10.17 09:02:16 INFO  [error] Use 'last' for the full log.
2024.10.17 09:02:16 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.10.17 09:02:16 INFO  time: ran 'sbt bloopInstall' in 32s
2024.10.17 09:02:16 ERROR sbt command failed: C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals2379581469639707273\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.17 09:02:16 INFO  Disconnecting from Bloop session...
2024.10.17 09:02:16 INFO  Shut down connection with build server.
2024.10.17 09:02:16 INFO  Shut down connection with build server.
2024.10.17 09:02:16 INFO  Shut down connection with build server.
2024.10.17 09:02:16 INFO  Attempting to connect to the build server...
2024.10.17 09:02:16 INFO  Found a Bloop server running
2024.10.17 09:02:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 09:02:18 INFO  Attempting to connect to the build server...
2024.10.17 09:02:18 INFO  Found a Bloop server running
2024.10.17 09:02:18 INFO  Attempting to connect to the build server...
2024.10.17 09:02:18 INFO  Found a Bloop server running
2024.10.17 09:02:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 09:02:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 09:02:19 INFO  time: Connected to build server in 2.88s
2024.10.17 09:02:19 INFO  Connected to Build server: Bloop v2.0.3
2024.10.17 09:02:19 INFO  time: Imported build in 0.2s
2024.10.17 09:02:20 INFO  running doctor check
2024.10.17 09:02:20 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.17 09:02:33 INFO  compiling root (9 scala sources and 1 java source)
2024.10.17 09:02:35 INFO  time: compiled root in 1.64s
2024.10.17 09:02:44 INFO  compiling root (9 scala sources and 1 java source)
2024.10.17 09:02:45 INFO  time: compiled root in 1.27s
2024.10.17 09:02:52 INFO  time: indexed workspace in 32s
2024.10.17 09:02:58 INFO  compiling root (9 scala sources and 1 java source)
2024.10.17 09:02:59 INFO  time: compiled root in 1.24s
2024.10.17 09:03:03 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:03:04 INFO  time: compiled root in 1.03s
2024.10.17 09:03:13 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:03:15 INFO  time: compiled root in 2.42s
2024.10.17 09:06:13 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:06:15 INFO  time: compiled root in 1.58s
2024.10.17 09:07:06 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:07:08 INFO  time: compiled root in 2.32s
2024.10.17 09:08:49 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals4209419323137233906\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.17 09:08:55 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.10.17 09:08:55 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.10.17 09:08:57 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.10.17 09:08:59 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.10.17 09:08:59 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.10.17 09:09:05 INFO  [success] Generated .bloop\backend-build-build.json
2024.10.17 09:09:05 INFO  [success] Total time: 6 s, completed 17.10.2024, 09:09:05
2024.10.17 09:09:05 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.10.17 09:09:05 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.10.17 09:09:10 INFO  [success] Generated .bloop\backend-build.json
2024.10.17 09:09:10 INFO  [success] Total time: 5 s, completed 17.10.2024, 09:09:11
2024.10.17 09:09:17 INFO  [info] loading settings for project root from build.sbt ...
2024.10.17 09:09:17 INFO  [info]   __              __
2024.10.17 09:09:17 INFO  [info]   \ \     ____   / /____ _ __  __
2024.10.17 09:09:17 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.10.17 09:09:17 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.10.17 09:09:17 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.10.17 09:09:17 INFO  [info]       /_/               /____/
2024.10.17 09:09:17 INFO  [info] 
2024.10.17 09:09:17 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.10.17 09:09:17 INFO  [info] 
2024.10.17 09:09:17 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.10.17 09:09:17 INFO  [info] https://www.playframework.com/sponsors
2024.10.17 09:09:17 INFO  [info] 
2024.10.17 09:09:20 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:09:23 INFO  time: compiled root in 2.5s
2024.10.17 09:09:23 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:09:28 INFO  time: compiled root in 4.83s
2024.10.17 09:09:32 INFO  [success] Generated .bloop\root.json
2024.10.17 09:09:32 INFO  [success] Generated .bloop\root-test.json
2024.10.17 09:09:32 INFO  [success] Total time: 13 s, completed 17.10.2024, 09:09:32
2024.10.17 09:09:32 INFO  time: ran 'sbt bloopInstall' in 43s
2024.10.17 09:09:32 INFO  Disconnecting from Bloop session...
2024.10.17 09:09:32 INFO  Shut down connection with build server.
2024.10.17 09:09:32 INFO  Shut down connection with build server.
2024.10.17 09:09:32 INFO  Shut down connection with build server.
2024.10.17 09:09:32 INFO  Attempting to connect to the build server...
2024.10.17 09:09:32 INFO  Found a Bloop server running
2024.10.17 09:09:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 09:09:34 INFO  Attempting to connect to the build server...
2024.10.17 09:09:34 INFO  Found a Bloop server running
2024.10.17 09:09:34 INFO  Attempting to connect to the build server...
2024.10.17 09:09:34 INFO  Found a Bloop server running
2024.10.17 09:09:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 09:09:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 09:09:37 INFO  time: Connected to build server in 4.25s
2024.10.17 09:09:37 INFO  Connected to Build server: Bloop v2.0.3
2024.10.17 09:09:37 INFO  time: Imported build in 0.19s
2024.10.17 09:09:37 INFO  running doctor check
2024.10.17 09:09:37 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.17 09:09:53 INFO  time: indexed workspace in 15s
2024.10.17 09:09:53 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:09:57 INFO  time: compiled root in 4.14s
2024.10.17 09:10:02 INFO  compiling root (4 scala sources)
2024.10.17 09:10:04 INFO  time: compiled root in 1.85s
2024.10.17 09:10:20 WARN  Could not find 'JdbcProfile' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Okt. 17, 2024 9:10:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 622
Okt. 17, 2024 9:10:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 620
Okt. 17, 2024 9:10:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 628
2024.10.17 09:10:40 WARN  Could not find 'Inject' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.10.17 09:10:41 INFO  compiling root (4 scala sources)
2024.10.17 09:10:42 INFO  time: compiled root in 1.1s
2024.10.17 09:10:45 INFO  compiling root (4 scala sources)
2024.10.17 09:10:47 INFO  time: compiled root in 1.73s
2024.10.17 09:10:54 INFO  compiling root (4 scala sources)
2024.10.17 09:10:55 INFO  time: compiled root in 1.32s
2024.10.17 09:12:15 INFO  compiling root (4 scala sources)
2024.10.17 09:12:16 INFO  time: compiled root in 1.74s
2024.10.17 09:12:24 INFO  compiling root (4 scala sources)
2024.10.17 09:12:25 INFO  time: compiled root in 1.06s
2024.10.17 09:14:00 INFO  compiling root (8 scala sources and 1 java source)
2024.10.17 09:14:04 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:14:04 INFO  time: compiled root in 0.95s
2024.10.17 09:14:21 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 09:14:21 WARN  javac exited with exit code 1
Okt. 17, 2024 9:14:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 813
2024.10.17 09:15:31 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:15:41 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 09:15:41 WARN  javac exited with exit code 1
2024.10.17 09:15:41 INFO  time: compiled root in 10s
2024.10.17 09:20:57 INFO  compiling root (4 scala sources)
2024.10.17 09:20:59 INFO  time: compiled root in 1.46s
2024.10.17 09:20:59 INFO  compiling root (4 scala sources)
2024.10.17 09:20:59 INFO  time: compiled root in 0.85s
2024.10.17 09:26:47 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:27:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 09:27:03 WARN  javac exited with exit code 1
2024.10.17 09:27:03 INFO  time: compiled root in 15s
2024.10.17 09:34:16 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 09:34:37 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 09:34:37 WARN  javac exited with exit code 1
2024.10.17 09:34:37 INFO  time: compiled root in 21s
Okt. 17, 2024 1:59:18 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNUNG: offset 1237, count -1, length 1254
2024.10.17 13:59:47 INFO  compiling root (11 scala sources and 1 java source)
2024.10.17 14:00:02 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:00:02 WARN  javac exited with exit code 1
2024.10.17 14:00:02 INFO  time: compiled root in 14s
2024.10.17 14:00:42 INFO  compiling root (12 scala sources and 1 java source)
Okt. 17, 2024 2:00:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1125
2024.10.17 14:00:52 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:00:52 WARN  javac exited with exit code 1
2024.10.17 14:00:52 INFO  time: compiled root in 10s
2024.10.17 14:00:57 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 14:00:57 INFO  time: compiled root in 0.45s
Okt. 17, 2024 2:03:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1312
2024.10.17 14:05:43 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 14:05:58 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:05:58 WARN  javac exited with exit code 1
2024.10.17 14:05:58 INFO  time: compiled root in 15s
2024.10.17 14:05:58 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 14:06:06 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:06:06 WARN  javac exited with exit code 1
2024.10.17 14:06:06 INFO  time: compiled root in 7.89s
2024.10.17 14:07:26 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 14:07:26 INFO  time: compiled root in 0.84s
2024.10.17 14:16:50 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 14:16:52 INFO  time: compiled root in 2.27s
2024.10.17 14:17:09 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 14:17:18 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:17:18 WARN  javac exited with exit code 1
2024.10.17 14:17:18 INFO  time: compiled root in 9.71s
Okt. 17, 2024 2:17:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_3/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Okt. 17, 2024 2:17:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_3/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.17 14:18:15 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:18:25 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:18:25 WARN  javac exited with exit code 1
2024.10.17 14:18:25 INFO  time: compiled root in 10s
2024.10.17 14:18:25 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:18:28 INFO  time: compiled root in 1.97s
2024.10.17 14:18:28 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:18:30 INFO  time: compiled root in 2.12s
2024.10.17 14:20:10 INFO  compiling root (9 scala sources)
2024.10.17 14:20:12 INFO  time: compiled root in 1.59s
2024.10.17 14:20:12 INFO  compiling root (7 scala sources)
2024.10.17 14:20:12 INFO  time: compiled root in 0.94s
2024.10.17 14:20:54 INFO  compiling root (11 scala sources and 1 java source)
2024.10.17 14:20:57 INFO  time: compiled root in 3.38s
2024.10.17 14:20:57 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:21:00 INFO  time: compiled root in 2.05s
2024.10.17 14:21:54 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:22:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:22:03 WARN  javac exited with exit code 1
2024.10.17 14:22:03 INFO  time: compiled root in 9.02s
2024.10.17 14:22:25 INFO  compiling root (9 scala sources)
2024.10.17 14:22:28 INFO  time: compiled root in 3.22s
2024.10.17 14:22:28 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:22:41 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:22:41 WARN  javac exited with exit code 1
2024.10.17 14:22:41 INFO  time: compiled root in 13s
2024.10.17 14:25:02 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:25:11 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:25:11 WARN  javac exited with exit code 1
2024.10.17 14:25:11 INFO  time: compiled root in 8.66s
2024.10.17 14:25:11 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:25:21 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:25:21 WARN  javac exited with exit code 1
2024.10.17 14:25:21 INFO  time: compiled root in 9.73s
2024.10.17 14:32:11 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:32:21 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:32:21 WARN  javac exited with exit code 1
2024.10.17 14:32:21 INFO  time: compiled root in 9.69s
2024.10.17 14:51:13 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:51:20 INFO  time: compiled root in 6.9s
2024.10.17 14:51:26 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:51:26 INFO  time: compiled root in 0.58s
2024.10.17 14:51:34 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:51:34 INFO  time: compiled root in 0.4s
2024.10.17 14:51:44 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:51:55 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:51:55 WARN  javac exited with exit code 1
2024.10.17 14:51:55 INFO  time: compiled root in 11s
2024.10.17 14:51:55 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:52:06 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:52:06 WARN  javac exited with exit code 1
2024.10.17 14:52:06 INFO  time: compiled root in 10s
2024.10.17 14:54:21 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:54:23 INFO  time: compiled root in 1.68s
2024.10.17 14:58:20 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 14:58:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 14:58:36 WARN  javac exited with exit code 1
2024.10.17 14:58:36 INFO  time: compiled root in 16s
2024.10.17 15:03:24 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 15:03:34 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 15:03:34 WARN  javac exited with exit code 1
2024.10.17 15:03:34 INFO  time: compiled root in 9.89s
2024.10.17 15:03:34 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 15:03:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 15:03:43 WARN  javac exited with exit code 1
2024.10.17 15:03:43 INFO  time: compiled root in 8.82s
2024.10.17 15:04:36 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 15:04:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 15:04:47 WARN  javac exited with exit code 1
2024.10.17 15:04:47 INFO  time: compiled root in 11s
Okt. 17, 2024 3:14:45 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\.reports\metals-full\2024-10-17\r_compiler-error_(backend-build)_15-14-45-977.md
2024.10.17 15:14:52 INFO  skipping build import with status 'Installed'
2024.10.17 15:14:52 INFO  Disconnecting from Bloop session...
2024.10.17 15:14:52 INFO  Shut down connection with build server.
2024.10.17 15:14:52 INFO  Shut down connection with build server.
2024.10.17 15:14:52 INFO  Shut down connection with build server.
2024.10.17 15:14:52 INFO  Attempting to connect to the build server...
2024.10.17 15:14:52 INFO  Found a Bloop server running
2024.10.17 15:14:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 15:14:54 INFO  Attempting to connect to the build server...
2024.10.17 15:14:54 INFO  Found a Bloop server running
2024.10.17 15:14:54 INFO  Attempting to connect to the build server...
2024.10.17 15:14:54 INFO  Found a Bloop server running
2024.10.17 15:14:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 15:14:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 15:14:55 INFO  time: Connected to build server in 2.54s
2024.10.17 15:14:55 INFO  Connected to Build server: Bloop v2.0.3
2024.10.17 15:14:55 INFO  time: Imported build in 0.15s
2024.10.17 15:14:55 INFO  running doctor check
2024.10.17 15:14:55 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.17 15:15:06 INFO  time: indexed workspace in 10s
2024.10.17 15:15:06 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 15:15:18 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 15:15:18 WARN  javac exited with exit code 1
2024.10.17 15:15:18 INFO  time: compiled root in 12s
2024.10.17 15:17:28 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 15:17:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 15:17:36 WARN  javac exited with exit code 1
2024.10.17 15:17:36 INFO  time: compiled root in 8.4s
2024.10.17 15:47:39 INFO  compiling root (12 scala sources and 1 java source)
2024.10.17 15:47:43 INFO  compiling root (11 scala sources and 1 java source)
2024.10.17 15:47:47 INFO  time: compiled root in 4.04s
2024.10.17 15:47:57 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:47:58 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.10.17 15:47:58 INFO  time: compiled root in 1.6s
2024.10.17 15:49:35 INFO  compiling root (10 scala sources and 1 java source)
Exception in thread "pool-28-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.10.17 15:49:43 INFO  time: compiled root in 7.28s
2024.10.17 15:49:48 INFO  compiling root (10 scala sources and 1 java source)
Okt. 17, 2024 3:49:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2678
2024.10.17 15:49:49 INFO  time: compiled root in 1.02s
Okt. 17, 2024 3:51:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 51,
      "uri": "file:///c%3A/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/repositories/CandlesRepository.scala"
    },
    "contentChanges": [
      {
        "text": "Option["
      }
    ]
  }
}
java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..7]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:105)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:45)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:45)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:80)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:320)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2(Diagnostics.scala:276)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2$adapted(Diagnostics.scala:275)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:275)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:240)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:153)
	at scala.meta.internal.metals.MetalsLspService.didChange(MetalsLspService.scala:864)
	at scala.meta.internal.metals.ProjectMetalsLspService.didChange(ProjectMetalsLspService.scala:220)
	at scala.meta.internal.metals.WorkspaceLspService.didChange(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didChange(DelegatingScalaService.scala:50)
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Okt. 17, 2024 3:51:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..7]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..7]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..7]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:105)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:45)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:45)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:80)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:41)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extract(FoldingRangeExtractor.scala:29)
	at scala.meta.internal.parsing.FoldingRangeProvider.$anonfun$getRangedForScala$3(FoldingRangeProvider.scala:36)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.FoldingRangeProvider.$anonfun$getRangedForScala$2(FoldingRangeProvider.scala:27)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.FoldingRangeProvider.getRangedForScala(FoldingRangeProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$2(MetalsLspService.scala:1233)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.10.17 15:51:43 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala:1: error: [dialect scala213] identifier expected but end of file found
Option[
       ^
2024.10.17 15:51:44 ERROR C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
scala.meta.internal.tokenizers.package$UnexpectedInputEndException
	at scala.meta.internal.tokenizers.LegacyScanner.$anonfun$nextToken$1(LegacyScanner.scala:172)
	at scala.Function0.apply$mcV$sp(Function0.scala:42)
	at scala.meta.internal.tokenizers.LegacyScanner.scala$meta$internal$tokenizers$LegacyScanner$$nextToken(LegacyScanner.scala:178)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:172)
	at scala.meta.internal.mtags.ScalaToplevelMtags$XtensionScanner.mtagsNextToken(ScalaToplevelMtags.scala:73)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:490)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:85)
	at scala.meta.internal.metals.SemanticdbDefinition$.foreachWithReturnMtags(SemanticdbDefinition.scala:81)
	at scala.meta.internal.metals.Indexer.indexSourceFile(Indexer.scala:485)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3(Indexer.scala:583)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3$adapted(Indexer.scala:580)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1303)
	at scala.meta.internal.metals.Indexer.reindexWorkspaceSources(Indexer.scala:580)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$2(MetalsLspService.scala:946)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.10.17 15:51:44 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:51:44 INFO  time: compiled root in 0.4s
2024.10.17 15:52:14 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:52:16 INFO  time: compiled root in 2.03s
Okt. 17, 2024 3:54:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_13/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A92%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.17 15:54:16 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:54:18 INFO  time: compiled root in 1.5s
2024.10.17 15:54:26 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:54:27 INFO  time: compiled root in 1.09s
2024.10.17 15:55:22 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:55:25 INFO  time: compiled root in 2.22s
2024.10.17 15:56:26 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:56:28 INFO  time: compiled root in 1.85s
Okt. 17, 2024 3:56:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3080
2024.10.17 15:57:03 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 15:57:05 INFO  time: compiled root in 2s
2024.10.17 15:59:56 INFO  compiling root (4 scala sources)
2024.10.17 15:59:59 INFO  time: compiled root in 2.45s
2024.10.17 15:59:59 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 16:00:11 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 16:00:11 WARN  javac exited with exit code 1
2024.10.17 16:00:11 INFO  time: compiled root in 12s
2024.10.17 16:00:11 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 16:00:27 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 16:00:27 WARN  javac exited with exit code 1
2024.10.17 16:00:27 INFO  time: compiled root in 15s
2024.10.17 16:03:12 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.10.17 16:03:12 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.10.17 16:03:12 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.10.17 16:03:12 WARN  Could not find 'Candlestick' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.10.17 16:03:12 WARN  Could not find 'map' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.10.17 16:03:46 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 16:04:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 16:04:00 WARN  javac exited with exit code 1
2024.10.17 16:04:00 INFO  time: compiled root in 14s
2024.10.17 16:06:10 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 16:06:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 16:06:17 WARN  javac exited with exit code 1
2024.10.17 16:06:17 INFO  time: compiled root in 7.92s
2024.10.17 16:16:16 INFO  Shutting down server
2024.10.17 16:16:16 INFO  shutting down Metals
2024.10.17 16:16:16 INFO  Shut down connection with build server.
2024.10.17 16:16:16 INFO  Shut down connection with build server.
2024.10.17 16:16:16 INFO  Shut down connection with build server.
2024.10.17 16:16:16 INFO  Exiting server
2024.10.17 16:37:08 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.17 16:37:09 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.17 16:37:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\CandlesController.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 16:37:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\CandlesController.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.17 16:37:15 INFO  Attempting to connect to the build server...
2024.10.17 16:37:15 INFO  Found a Bloop server running
2024.10.17 16:37:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 16:37:19 INFO  Attempting to connect to the build server...
2024.10.17 16:37:19 INFO  Found a Bloop server running
2024.10.17 16:37:19 INFO  Attempting to connect to the build server...
2024.10.17 16:37:19 INFO  Found a Bloop server running
2024.10.17 16:37:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 16:37:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 16:37:21 INFO  time: Connected to build server in 6.05s
2024.10.17 16:37:21 INFO  Connected to Build server: Bloop v2.0.3
2024.10.17 16:37:22 INFO  time: Imported build in 0.45s
2024.10.17 16:37:22 INFO  running doctor check
2024.10.17 16:37:22 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.17 16:37:23 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.17 16:37:47 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.17 16:38:29 INFO  time: indexed workspace in 1m7s
2024.10.17 16:38:54 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 16:39:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 16:39:03 WARN  javac exited with exit code 1
2024.10.17 16:39:03 INFO  time: compiled root in 9.37s
2024.10.17 19:25:30 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 19:25:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 19:25:43 WARN  javac exited with exit code 1
2024.10.17 19:25:43 INFO  time: compiled root in 13s
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 63
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 64
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 65
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 67
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 69
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 71
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 72
Okt. 17, 2024 7:39:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 73
Okt. 17, 2024 7:39:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 83
Okt. 17, 2024 7:40:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 90
Okt. 17, 2024 7:40:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 91
Okt. 17, 2024 7:40:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 92
Okt. 17, 2024 7:43:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_15/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A76%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A96%2C%22endColumn%22%3A2%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.17 19:43:29 INFO  compiling root (10 scala sources and 1 java source)
Okt. 17, 2024 7:43:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_15/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A76%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A96%2C%22endColumn%22%3A2%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.17 19:43:39 INFO  time: compiled root in 9.34s
2024.10.17 19:43:42 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 19:43:43 INFO  time: compiled root in 1.38s
2024.10.17 19:44:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Okt. 17, 2024 7:44:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Okt. 17, 2024 7:44:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Okt. 17, 2024 7:44:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_15/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A76%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A96%2C%22endColumn%22%3A2%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.17 19:45:03 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 19:45:05 INFO  time: compiled root in 1.97s
2024.10.17 19:49:23 INFO  compiling root (10 scala sources and 1 java source)
2024.10.17 19:49:34 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 19:49:34 WARN  javac exited with exit code 1
2024.10.17 19:49:34 INFO  time: compiled root in 11s
2024.10.17 20:45:51 INFO  compiling root (13 scala sources and 1 java source)
2024.10.17 20:46:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.17 20:46:05 WARN  javac exited with exit code 1
2024.10.17 20:46:05 INFO  time: compiled root in 13s
2024.10.18 08:49:45 INFO  Shutting down server
2024.10.18 08:49:45 INFO  shutting down Metals
2024.10.18 08:49:46 INFO  Shut down connection with build server.
2024.10.18 08:49:46 INFO  Shut down connection with build server.
2024.10.18 08:49:46 INFO  Shut down connection with build server.
2024.10.18 08:49:45 INFO  Exiting server
2024.10.18 21:05:41 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.18 21:05:45 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.18 21:05:46 INFO  Attempting to connect to the build server...
2024.10.18 21:05:46 INFO  Found a Bloop server running
2024.10.18 21:05:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.18 21:05:52 INFO  Attempting to connect to the build server...
2024.10.18 21:05:52 INFO  Found a Bloop server running
2024.10.18 21:05:52 INFO  Attempting to connect to the build server...
2024.10.18 21:05:52 INFO  Found a Bloop server running
2024.10.18 21:05:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.18 21:05:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.18 21:05:55 INFO  time: Connected to build server in 8.4s
2024.10.18 21:05:55 INFO  Connected to Build server: Bloop v2.0.3
2024.10.18 21:05:56 INFO  time: Imported build in 0.89s
2024.10.18 21:05:56 INFO  running doctor check
2024.10.18 21:05:56 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.18 21:06:04 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.18 21:06:54 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.18 21:07:47 INFO  time: indexed workspace in 1m50s
2024.10.19 10:45:18 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.19 10:45:18 INFO  time: initialize in 0.22s
2024.10.19 10:45:25 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.19 10:45:25 INFO  Attempting to connect to the build server...
2024.10.19 10:45:27 INFO  No running Bloop server found, starting one.
2024.10.19 10:45:39 INFO  Starting compilation server
2024.10.19 10:45:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.19 10:45:51 INFO  Attempting to connect to the build server...
2024.10.19 10:45:51 INFO  Found a Bloop server running
2024.10.19 10:45:51 INFO  Attempting to connect to the build server...
2024.10.19 10:45:51 INFO  Found a Bloop server running
2024.10.19 10:45:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.19 10:45:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.19 10:45:56 INFO  time: Connected to build server in 30s
2024.10.19 10:45:56 INFO  Connected to Build server: Bloop v2.0.3
2024.10.19 10:45:57 INFO  time: Imported build in 0.37s
2024.10.19 10:45:57 INFO  running doctor check
2024.10.19 10:45:57 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.19 10:46:01 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.19 10:46:21 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.19 10:46:40 INFO  time: indexed workspace in 43s
2024.10.21 07:09:38 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.21 07:09:43 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.21 07:09:43 INFO  Attempting to connect to the build server...
2024.10.21 07:09:43 INFO  Found a Bloop server running
2024.10.21 07:09:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.21 07:09:46 INFO  Attempting to connect to the build server...
2024.10.21 07:09:46 INFO  Found a Bloop server running
2024.10.21 07:09:46 INFO  Attempting to connect to the build server...
2024.10.21 07:09:46 INFO  Found a Bloop server running
2024.10.21 07:09:47 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.21 07:09:47 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.21 07:09:47 INFO  time: Connected to build server in 3.71s
2024.10.21 07:09:47 INFO  Connected to Build server: Bloop v2.0.3
2024.10.21 07:09:47 INFO  time: Imported build in 0.4s
2024.10.21 07:09:48 INFO  running doctor check
2024.10.21 07:09:48 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.21 07:09:55 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.21 07:10:32 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.21 07:10:58 INFO  time: indexed workspace in 1m10s
2024.10.21 07:42:23 INFO  Shutting down server
2024.10.21 07:42:23 INFO  shutting down Metals
2024.10.21 07:42:23 INFO  Shut down connection with build server.
2024.10.21 07:42:23 INFO  Shut down connection with build server.
2024.10.21 07:42:23 INFO  Shut down connection with build server.
2024.10.21 07:42:23 INFO  Exiting server
2024.10.24 08:15:03 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.24 08:15:06 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.24 08:15:07 INFO  Attempting to connect to the build server...
2024.10.24 08:15:07 INFO  Found a Bloop server running
2024.10.24 08:15:10 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 08:15:11 INFO  Attempting to connect to the build server...
2024.10.24 08:15:11 INFO  Found a Bloop server running
2024.10.24 08:15:11 INFO  Attempting to connect to the build server...
2024.10.24 08:15:11 INFO  Found a Bloop server running
2024.10.24 08:15:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 08:15:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 08:15:13 INFO  time: Connected to build server in 6.14s
2024.10.24 08:15:13 INFO  Connected to Build server: Bloop v2.0.3
2024.10.24 08:15:15 INFO  time: Imported build in 1.87s
2024.10.24 08:15:15 INFO  running doctor check
2024.10.24 08:15:15 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.24 08:15:20 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.24 08:16:06 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.24 08:16:59 INFO  time: indexed workspace in 1m43s
Okt. 27, 2024 7:27:27 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Okt. 27, 2024 7:27:27 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Okt. 27, 2024 8:56:36 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.10.29 20:36:36 INFO  compiling root (13 scala sources and 1 java source)
Okt. 29, 2024 8:36:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10
2024.10.29 20:37:18 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.29 20:37:18 WARN  javac exited with exit code 1
2024.10.29 20:37:18 INFO  time: compiled root in 42s
2024.10.29 20:43:47 WARN  Could not find 'Pair' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.10.29 20:43:47 WARN  Could not find 'Pair' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.10.29 20:43:47 WARN  Could not find 'Pair' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Okt. 30, 2024 12:54:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 69
2024.10.30 12:55:32 INFO  Shutting down server
2024.10.30 12:55:32 INFO  shutting down Metals
2024.10.30 12:55:33 INFO  Shut down connection with build server.
2024.10.30 12:55:33 INFO  Shut down connection with build server.
2024.10.30 12:55:33 INFO  Shut down connection with build server.
2024.10.30 12:57:31 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.10.30 12:57:34 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.30 12:57:34 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.30 12:57:35 INFO  Attempting to connect to the build server...
2024.10.30 12:57:35 INFO  Found a Bloop server running
2024.10.30 12:57:41 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.30 12:57:41 INFO  Attempting to connect to the build server...
2024.10.30 12:57:41 INFO  Found a Bloop server running
2024.10.30 12:57:41 INFO  Attempting to connect to the build server...
2024.10.30 12:57:41 INFO  Found a Bloop server running
2024.10.30 12:57:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.30 12:57:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.30 12:57:44 INFO  time: Connected to build server in 9.23s
2024.10.30 12:57:44 INFO  Connected to Build server: Bloop v2.0.3
2024.10.30 12:57:45 INFO  time: Imported build in 0.57s
2024.10.30 12:57:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.10.30 12:57:45 INFO  running doctor check
2024.10.30 12:57:45 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.10.30 12:57:46 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.10.30 12:58:37 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.30 12:59:35 INFO  time: indexed workspace in 1m50s
2024.10.30 12:59:35 INFO  compiling root (13 scala sources and 1 java source)
2024.10.30 12:59:59 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.30 12:59:59 WARN  javac exited with exit code 1
2024.10.30 12:59:59 INFO  time: compiled root in 23s
2024.10.30 12:59:59 INFO  compiling root (13 scala sources and 1 java source)
2024.10.30 13:00:19 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.10.30 13:00:19 WARN  javac exited with exit code 1
2024.10.30 13:00:19 INFO  time: compiled root in 19s
Nov. 05, 2024 7:38:39 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.05 19:53:48 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.11.05 19:53:54 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.05 19:53:55 INFO  Attempting to connect to the build server...
2024.11.05 19:53:55 INFO  Found a Bloop server running
2024.11.05 19:53:58 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.05 19:53:58 INFO  Attempting to connect to the build server...
2024.11.05 19:53:58 INFO  Found a Bloop server running
2024.11.05 19:53:58 INFO  Attempting to connect to the build server...
2024.11.05 19:53:58 INFO  Found a Bloop server running
2024.11.05 19:54:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.05 19:54:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.05 19:54:01 INFO  time: Connected to build server in 6.39s
2024.11.05 19:54:01 INFO  Connected to Build server: Bloop v2.0.3
2024.11.05 19:54:02 INFO  time: Imported build in 0.34s
2024.11.05 19:54:02 INFO  running doctor check
2024.11.05 19:54:02 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.05 19:54:06 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.11.05 19:54:45 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.05 19:55:29 INFO  time: indexed workspace in 1m27s
2024.11.05 20:13:04 INFO  compiling root (13 scala sources and 1 java source)
Nov. 05, 2024 8:13:05 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.05 20:13:29 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:13:29 WARN  javac exited with exit code 1
2024.11.05 20:13:29 INFO  time: compiled root in 25s
2024.11.05 20:14:44 INFO  compiling root (14 scala sources and 1 java source)
2024.11.05 20:14:55 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:14:55 WARN  javac exited with exit code 1
2024.11.05 20:14:55 INFO  time: compiled root in 10s
2024.11.05 20:15:34 INFO  compiling root (14 scala sources and 1 java source)
2024.11.05 20:15:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:15:47 WARN  javac exited with exit code 1
2024.11.05 20:15:47 INFO  time: compiled root in 12s
2024.11.05 20:16:50 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:17:02 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:17:02 WARN  javac exited with exit code 1
2024.11.05 20:17:02 INFO  time: compiled root in 11s
Nov. 05, 2024 8:17:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 129
2024.11.05 20:17:22 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:17:24 INFO  time: compiled root in 2.62s
2024.11.05 20:17:32 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:17:42 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:17:42 WARN  javac exited with exit code 1
2024.11.05 20:17:42 INFO  time: compiled root in 10s
Nov. 05, 2024 8:17:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 201
Nov. 05, 2024 8:17:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 202
Nov. 05, 2024 8:17:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 203
Nov. 05, 2024 8:17:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 205
Nov. 05, 2024 8:17:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 208
Nov. 05, 2024 8:17:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 209
Nov. 05, 2024 8:17:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 210
Nov. 05, 2024 8:17:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 215
Nov. 05, 2024 8:17:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 216
2024.11.05 20:18:30 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:18:33 INFO  time: compiled root in 3.09s
Nov. 05, 2024 8:19:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_17/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cutils%5C%5CCircularBuffer.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Futils%2FCircularBuffer.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Futils%2FCircularBuffer.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A85%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A107%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:19:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 281
Nov. 05, 2024 8:19:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 282
Nov. 05, 2024 8:19:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 288
Nov. 05, 2024 8:19:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 284
Nov. 05, 2024 8:19:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 293
2024.11.05 20:19:30 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:19:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:19:43 WARN  javac exited with exit code 1
2024.11.05 20:19:43 INFO  time: compiled root in 12s
Nov. 05, 2024 8:20:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 369
2024.11.05 20:20:17 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:20:26 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:20:26 WARN  javac exited with exit code 1
2024.11.05 20:20:26 INFO  time: compiled root in 8.8s
2024.11.05 20:23:57 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:24:01 INFO  time: compiled root in 3.47s
2024.11.05 20:24:34 INFO  compiling root (15 scala sources and 1 java source)
2024.11.05 20:24:36 INFO  time: compiled root in 2.16s
2024.11.05 20:25:00 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:25:03 INFO  time: compiled root in 3.03s
Nov. 05, 2024 8:25:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 598
2024.11.05 20:25:06 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:25:08 INFO  time: compiled root in 2s
2024.11.05 20:25:28 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 05, 2024 8:25:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Nov. 05, 2024 8:25:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.11.05 20:25:28 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 05, 2024 8:25:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Nov. 05, 2024 8:25:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.11.05 20:26:08 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:26:08 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:26:08 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:26:08 WARN  Could not find 'day' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:26:09 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:26:09 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:26:09 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:26:09 WARN  Could not find 'getOrElse' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 05, 2024 8:26:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 759
Nov. 05, 2024 8:26:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 765
2024.11.05 20:27:06 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:27:08 INFO  time: compiled root in 1.91s
2024.11.05 20:27:11 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:11 WARN  Could not find 'time' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:13 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:13 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:13 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:13 WARN  Could not find 'day' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:14 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:14 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:14 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:14 WARN  Could not find 'getTime' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:17 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:17 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:17 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:17 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:17 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:17 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:17 WARN  Could not find 'day' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:17 WARN  Could not find 'day' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:22 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:22 WARN  Could not find 'time' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:22 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:22 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:22 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:22 WARN  Could not find 'getOrElse' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:24 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:24 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:24 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.05 20:27:24 WARN  Could not find 'getOrElse' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:27:27 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:27:28 INFO  time: compiled root in 1.38s
2024.11.05 20:27:46 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:27:48 INFO  time: compiled root in 1.76s
2024.11.05 20:27:53 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:27:55 INFO  time: compiled root in 2.28s
2024.11.05 20:28:01 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:28:04 INFO  time: compiled root in 2.68s
2024.11.05 20:28:11 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:28:13 INFO  time: compiled root in 2.18s
2024.11.05 20:28:47 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:28:49 INFO  time: compiled root in 1.64s
Nov. 05, 2024 8:29:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1132
2024.11.05 20:29:34 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:29:37 INFO  time: compiled root in 2.84s
2024.11.05 20:30:18 WARN  Could not find 'AnyContent' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:30:20 WARN  Could not find 'AnyContent' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:31:14 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:31:16 INFO  time: compiled root in 1.66s
2024.11.05 20:32:00 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:32:02 INFO  time: compiled root in 2.71s
2024.11.05 20:32:54 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:32:57 INFO  time: compiled root in 2.48s
2024.11.05 20:34:43 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:34:46 INFO  time: compiled root in 2.73s
2024.11.05 20:34:51 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:34:53 INFO  time: compiled root in 1.89s
2024.11.05 20:36:03 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:36:06 INFO  time: compiled root in 2.58s
2024.11.05 20:36:32 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:36:32 INFO  time: compiled root in 0.58s
Nov. 05, 2024 8:36:33 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.11.05 20:36:51 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:36:51 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/models/Candlesticks.scala
2024.11.05 20:36:51 INFO  time: compiled root in 0.45s
2024.11.05 20:36:51 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:36:51 INFO  time: compiled root in 0.39s
2024.11.05 20:37:03 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:37:03 INFO  time: compiled root in 0.39s
Nov. 05, 2024 8:37:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1697
2024.11.05 20:37:28 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:37:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:37:38 WARN  javac exited with exit code 1
2024.11.05 20:37:38 INFO  time: compiled root in 10s
2024.11.05 20:48:49 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:48:49 INFO  time: compiled root in 0.98s
2024.11.05 20:49:00 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:49:08 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:49:08 WARN  javac exited with exit code 1
2024.11.05 20:49:08 INFO  time: compiled root in 8.57s
2024.11.05 20:50:47 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:50:50 INFO  time: compiled root in 3.16s
2024.11.05 20:51:12 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:51:14 INFO  time: compiled root in 2s
2024.11.05 20:51:14 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:51:16 INFO  time: compiled root in 1.39s
2024.11.05 20:51:32 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:51:33 INFO  time: compiled root in 1.17s
2024.11.05 20:51:36 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:51:38 INFO  time: compiled root in 1.15s
2024.11.05 20:53:24 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:53:28 INFO  time: compiled root in 3.86s
2024.11.05 20:53:28 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:53:32 INFO  time: compiled root in 3.65s
Nov. 05, 2024 8:53:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2195
Nov. 05, 2024 8:53:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2196
2024.11.05 20:53:57 WARN  Could not find 'Candlestick' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:300)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:300)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:300)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 05, 2024 8:54:00 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\Candlesticks.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:300)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:227)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:227)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.05 20:54:01 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 20:54:11 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 20:54:11 WARN  javac exited with exit code 1
2024.11.05 20:54:11 INFO  time: compiled root in 9.94s
2024.11.05 21:04:38 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:04:54 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:04:54 WARN  javac exited with exit code 1
2024.11.05 21:04:54 INFO  time: compiled root in 15s
2024.11.05 21:10:09 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:10:11 INFO  time: compiled root in 2.68s
2024.11.05 21:10:32 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:10:34 INFO  time: compiled root in 2.46s
2024.11.05 21:10:59 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:11:01 INFO  time: compiled root in 2.01s
2024.11.05 21:14:28 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:14:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:14:38 WARN  javac exited with exit code 1
2024.11.05 21:14:38 INFO  time: compiled root in 10s
Nov. 05, 2024 9:18:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2612
2024.11.05 21:18:35 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:18:37 INFO  time: compiled root in 1.68s
Nov. 05, 2024 9:18:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2653
2024.11.05 21:18:55 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:19:08 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:19:08 WARN  javac exited with exit code 1
2024.11.05 21:19:08 INFO  time: compiled root in 13s
Nov. 05, 2024 9:19:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2705
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2706
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2707
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2710
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2712
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2713
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2714
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2715
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2717
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2719
Nov. 05, 2024 9:19:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2721
2024.11.05 21:19:32 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:19:34 INFO  time: compiled root in 2.85s
2024.11.05 21:19:40 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:19:56 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:19:56 WARN  javac exited with exit code 1
2024.11.05 21:19:56 INFO  time: compiled root in 16s
2024.11.05 21:20:51 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:21:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:21:05 WARN  javac exited with exit code 1
2024.11.05 21:21:05 INFO  time: compiled root in 13s
2024.11.05 21:21:47 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:22:02 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:22:02 WARN  javac exited with exit code 1
2024.11.05 21:22:02 INFO  time: compiled root in 14s
Nov. 05, 2024 9:29:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2983
2024.11.05 21:29:21 WARN  Could not find 'ChartDataService' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 05, 2024 9:31:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3104
2024.11.05 21:31:25 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:31:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:31:43 WARN  javac exited with exit code 1
2024.11.05 21:31:43 INFO  time: compiled root in 17s
2024.11.05 21:31:56 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:32:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:32:05 WARN  javac exited with exit code 1
2024.11.05 21:32:05 INFO  time: compiled root in 9.62s
2024.11.05 21:35:19 WARN  Could not find 'String' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.05 21:35:53 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:35:55 INFO  time: compiled root in 1.97s
2024.11.05 21:36:07 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:36:08 INFO  time: compiled root in 1.61s
2024.11.05 21:37:44 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:37:56 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:37:56 WARN  javac exited with exit code 1
2024.11.05 21:37:56 INFO  time: compiled root in 11s
2024.11.05 21:42:15 WARN  Could not find 'CircularBuffer' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 05, 2024 9:42:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3852
Nov. 05, 2024 9:42:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3853
2024.11.05 21:42:17 WARN  Could not find 'ExecutionContext' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 05, 2024 9:42:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3858
2024.11.05 21:42:21 INFO  compiling root (16 scala sources and 1 java source)
Nov. 05, 2024 9:42:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3900
2024.11.05 21:42:32 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:42:32 WARN  javac exited with exit code 1
2024.11.05 21:42:32 INFO  time: compiled root in 11s
2024.11.05 21:43:11 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:43:21 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:43:21 WARN  javac exited with exit code 1
2024.11.05 21:43:21 INFO  time: compiled root in 10s
Nov. 05, 2024 9:44:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4117
2024.11.05 21:44:11 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:44:22 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:44:22 WARN  javac exited with exit code 1
2024.11.05 21:44:22 INFO  time: compiled root in 10s
2024.11.05 21:44:25 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:44:39 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:44:39 WARN  javac exited with exit code 1
2024.11.05 21:44:39 INFO  time: compiled root in 14s
2024.11.05 21:45:15 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:45:30 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:45:30 WARN  javac exited with exit code 1
2024.11.05 21:45:30 INFO  time: compiled root in 15s
2024.11.05 21:46:51 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:47:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:47:05 WARN  javac exited with exit code 1
2024.11.05 21:47:05 INFO  time: compiled root in 14s
Nov. 05, 2024 9:47:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..10]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..10]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..10]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:105)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:45)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:45)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:80)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:41)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2(FoldingRangeExtractor.scala:61)
	at scala.meta.internal.parsing.FoldingRangeExtractor.$anonfun$extractFrom$2$adapted(FoldingRangeExtractor.scala:56)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extractFrom(FoldingRangeExtractor.scala:56)
	at scala.meta.internal.parsing.FoldingRangeExtractor.extract(FoldingRangeExtractor.scala:29)
	at scala.meta.internal.parsing.FoldingRangeProvider.$anonfun$getRangedForScala$3(FoldingRangeProvider.scala:36)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.FoldingRangeProvider.$anonfun$getRangedForScala$2(FoldingRangeProvider.scala:27)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.FoldingRangeProvider.getRangedForScala(FoldingRangeProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$2(MetalsLspService.scala:1233)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.11.05 21:47:56 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:48:07 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:48:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:48:09 WARN  javac exited with exit code 1
2024.11.05 21:48:09 INFO  time: compiled root in 1.46s
2024.11.05 21:48:22 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:48:22 WARN  javac exited with exit code 1
2024.11.05 21:49:12 INFO  compiling root (16 scala sources and 1 java source)
2024.11.05 21:49:24 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.05 21:49:24 WARN  javac exited with exit code 1
2024.11.05 21:49:24 INFO  time: compiled root in 12s
Nov. 05, 2024 9:50:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4571
2024.11.07 14:39:56 INFO  compiling root (16 scala sources and 1 java source)
2024.11.07 14:40:32 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.07 14:40:32 WARN  javac exited with exit code 1
2024.11.07 14:40:32 INFO  time: compiled root in 35s
Nov. 08, 2024 8:53:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4601
2024.11.08 20:53:23 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:28: error: [dialect scala213] } expected but end of file found

^
2024.11.08 20:53:24 INFO  compiling root (16 scala sources and 1 java source)
2024.11.08 20:53:39 INFO  time: compiled root in 15s
2024.11.08 20:53:39 INFO  compiling root (16 scala sources and 1 java source)
2024.11.08 20:53:45 INFO  time: compiled root in 5.62s
2024.11.08 20:54:15 INFO  compiling root (16 scala sources and 1 java source)
2024.11.08 20:54:18 INFO  time: compiled root in 2.84s
2024.11.08 20:54:39 INFO  compiling root (16 scala sources and 1 java source)
2024.11.08 20:54:43 INFO  time: compiled root in 3.22s
2024.11.08 20:55:03 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:68: error: [dialect scala213] } expected but end of file found
 
 ^
2024.11.08 20:55:03 INFO  compiling root (16 scala sources and 1 java source)
2024.11.08 20:55:03 INFO  time: compiled root in 0.6s
2024.11.08 20:55:10 INFO  compiling root (16 scala sources and 1 java source)
2024.11.08 20:55:13 INFO  time: compiled root in 2.87s
2024.11.08 20:55:40 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 20:55:43 INFO  time: compiled root in 3.19s
Nov. 08, 2024 8:55:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4933
2024.11.08 20:56:02 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 20:56:05 INFO  time: compiled root in 2.73s
Nov. 08, 2024 8:58:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5059
Nov. 08, 2024 8:58:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5060
Nov. 08, 2024 8:58:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5080
Nov. 08, 2024 8:58:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5082
Nov. 08, 2024 8:58:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5084
Nov. 08, 2024 8:58:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5085
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5112
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5115
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5117
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5118
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5119
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5123
Nov. 08, 2024 8:58:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5125
Nov. 08, 2024 8:59:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5159
2024.11.08 21:00:09 INFO  compiling root (15 scala sources and 1 java source)
Nov. 08, 2024 9:00:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5192
2024.11.08 21:00:12 INFO  time: compiled root in 3.82s
2024.11.08 21:03:38 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:03:45 INFO  time: compiled root in 6.8s
2024.11.08 21:06:37 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:06:41 INFO  time: compiled root in 3.84s
2024.11.08 21:07:09 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:07:11 INFO  time: compiled root in 2.49s
2024.11.08 21:08:16 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:08:30 INFO  time: compiled root in 13s
2024.11.08 21:10:44 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:10:50 INFO  time: compiled root in 5.31s
2024.11.08 21:10:59 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:11:02 INFO  time: compiled root in 2.31s
2024.11.08 21:11:17 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.08 21:11:17 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.08 21:11:17 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.08 21:11:17 WARN  Could not find 'map' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.08 21:13:03 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:13:06 INFO  time: compiled root in 3.39s
2024.11.08 21:13:12 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:13:15 INFO  time: compiled root in 2.8s
2024.11.08 21:19:04 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:19:44 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:19:44 WARN  javac exited with exit code 1
2024.11.08 21:19:44 INFO  time: compiled root in 40s
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5719
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5720
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5725
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5726
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5727
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5728
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5729
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5730
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5731
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5732
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5733
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5734
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5735
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5736
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5737
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5738
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5739
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5740
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5741
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5722
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5721
Nov. 08, 2024 9:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5724
Nov. 08, 2024 9:22:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5748
Nov. 08, 2024 9:22:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5754
Nov. 08, 2024 9:22:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5755
Nov. 08, 2024 9:22:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5757
Nov. 08, 2024 9:22:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5758
Nov. 08, 2024 9:22:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5759
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5760
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5764
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5761
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5763
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5769
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5771
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5773
Nov. 08, 2024 9:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5774
2024.11.08 21:22:55 INFO  compiling root (15 scala sources and 1 java source)
Nov. 08, 2024 9:23:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5787
Nov. 08, 2024 9:23:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5794
Nov. 08, 2024 9:24:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5802
Nov. 08, 2024 9:25:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint consume
WARNUNG: Unkown message type.
2024.11.08 21:25:18 INFO  Shut down connection with build server.
2024.11.08 21:25:18 INFO  Shut down connection with build server.
2024.11.08 21:25:18 INFO  Shut down connection with build server.
2024.11.08 21:25:18 INFO  Cancelling compilation on Bloop server
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@4a546c53[Shutting down, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 82478]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:435)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:506)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@4a546c53[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 82479]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:435)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete(Promise.scala:278)
	at scala.concurrent.Promise.complete(Promise.scala:57)
	at scala.concurrent.Promise.complete$(Promise.scala:56)
	at scala.concurrent.impl.Promise$DefaultPromise.complete(Promise.scala:104)
	at bloop.rifle.internal.Operations$.$anonfun$bsp$1(Operations.scala:374)
	at bloop.rifle.BloopRifleLogger.$anonfun$runnable$1(BloopRifleLogger.scala:14)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.08 21:25:18 INFO  unable to setup persistent H2 database with AUTO_SERVER=true, falling back to AUTO_SERVER=false.
2024.11.08 21:28:26 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.95.0-insider.
2024.11.08 21:28:30 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.08 21:28:30 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:36 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:37 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:36 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:36 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:36 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:37 INFO  Attempting to connect to the build server...
Nov. 08, 2024 9:28:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3
2024.11.08 21:28:36 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:37 INFO  No running Bloop server found, starting one.
2024.11.08 21:28:38 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:38 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:46 INFO  Starting compilation server
2024.11.08 21:28:51 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:51 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:28:55 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala. Using presentation compiler with project's scala-library version: 3.3.4
Nov. 08, 2024 9:29:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 26
2024.11.08 21:29:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 21:29:09 INFO  Attempting to connect to the build server...
2024.11.08 21:29:09 INFO  Found a Bloop server running
2024.11.08 21:29:09 INFO  Attempting to connect to the build server...
2024.11.08 21:29:09 INFO  Found a Bloop server running
2024.11.08 21:29:10 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:10 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
Nov. 08, 2024 9:29:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 35
2024.11.08 21:29:10 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:11 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 21:29:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 21:29:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 21:29:15 INFO  time: Connected to build server in 38s
2024.11.08 21:29:15 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 21:29:16 INFO  time: Imported build in 0.55s
2024.11.08 21:29:16 INFO  running doctor check
2024.11.08 21:29:16 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.08 21:29:16 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.11.08 21:29:51 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
Nov. 08, 2024 9:30:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 91
Nov. 08, 2024 9:30:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 186
Nov. 08, 2024 9:30:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 194
2024.11.08 21:30:52 INFO  time: indexed workspace in 1m35s
2024.11.08 21:30:53 INFO  compiling root (15 scala sources and 1 java source)
Nov. 08, 2024 9:31:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 270
2024.11.08 21:31:08 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:31:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:31:38 WARN  javac exited with exit code 1
2024.11.08 21:31:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:31:38 WARN  javac exited with exit code 1
2024.11.08 21:31:38 INFO  time: compiled root in 30s
2024.11.08 21:31:38 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:32:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 3m 0.661s)
2024.11.08 21:32:09 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:32:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:32:09 WARN  javac exited with exit code 1
2024.11.08 21:32:09 INFO  time: compiled root in 72ms
2024.11.08 21:32:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:32:09 WARN  javac exited with exit code 1
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 327
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 326
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 329
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 330
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 334
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 332
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 337
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 336
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 342
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 345
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 350
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 344
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 346
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 353
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 349
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 351
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 348
Nov. 08, 2024 9:35:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 354
Nov. 08, 2024 9:35:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 358
Nov. 08, 2024 9:35:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 355
2024.11.08 21:35:06 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:35:22 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:35:22 WARN  javac exited with exit code 1
2024.11.08 21:35:22 INFO  time: compiled root in 15s
Nov. 08, 2024 9:35:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 384
2024.11.08 21:36:58 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:37:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:37:17 WARN  javac exited with exit code 1
2024.11.08 21:37:17 INFO  time: compiled root in 19s
2024.11.08 21:38:26 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:38:30 INFO  time: compiled root in 3.87s
Nov. 08, 2024 9:38:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 739
Nov. 08, 2024 9:39:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 938
Nov. 08, 2024 9:39:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 940
Nov. 08, 2024 9:39:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1034
2024.11.08 21:39:58 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:40:14 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:40:14 WARN  javac exited with exit code 1
2024.11.08 21:40:14 INFO  time: compiled root in 15s
Nov. 08, 2024 9:41:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1163
Nov. 08, 2024 9:41:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1164
Nov. 08, 2024 9:43:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1344
Nov. 08, 2024 9:43:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1468
Nov. 08, 2024 9:43:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1515
Nov. 08, 2024 9:43:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1520
Nov. 08, 2024 9:43:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1529
Nov. 08, 2024 9:43:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1543
2024.11.08 21:43:39 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:26: error: [dialect scala213] identifier expected but if found
    if (savedTimeframe == "1d")
    ^
2024.11.08 21:43:39 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:43:39 INFO  time: compiled root in 0.73s
2024.11.08 21:44:02 INFO  compiling root (15 scala sources and 1 java source)
Exception in thread "pool-23-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.08 21:44:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:44:17 WARN  javac exited with exit code 1
2024.11.08 21:44:17 INFO  time: compiled root in 14s
Nov. 08, 2024 9:44:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1827
2024.11.08 21:44:58 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:45:00 INFO  time: compiled root in 2.75s
2024.11.08 21:45:39 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:45:41 INFO  time: compiled root in 2.6s
2024.11.08 21:46:07 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:46:19 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:46:19 WARN  javac exited with exit code 1
2024.11.08 21:46:19 INFO  time: compiled root in 12s
Nov. 08, 2024 9:46:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2324
Nov. 08, 2024 9:47:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2383
2024.11.08 21:47:26 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:47:39 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:47:39 WARN  javac exited with exit code 1
2024.11.08 21:47:39 INFO  time: compiled root in 13s
2024.11.08 21:47:43 INFO  compiling root (15 scala sources and 1 java source)
Nov. 08, 2024 9:47:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2518
2024.11.08 21:47:51 INFO  time: compiled root in 7.91s
2024.11.08 21:47:51 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:47:53 INFO  time: compiled root in 1.84s
Nov. 08, 2024 9:47:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2542
2024.11.08 21:48:00 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:25: error: [dialect scala213] identifier expected but = found
  def get_scaler:Unit timeframeInt = 1440
                                   ^
2024.11.08 21:48:00 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:48:00 INFO  time: compiled root in 0.54s
2024.11.08 21:48:13 INFO  compiling root (15 scala sources and 1 java source)
Nov. 08, 2024 9:48:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2585
2024.11.08 21:48:31 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:48:31 WARN  javac exited with exit code 1
2024.11.08 21:48:31 INFO  time: compiled root in 17s
2024.11.08 21:48:31 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:48:46 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:48:46 WARN  javac exited with exit code 1
2024.11.08 21:48:46 INFO  time: compiled root in 14s
2024.11.08 21:48:46 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:49:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:49:00 WARN  javac exited with exit code 1
2024.11.08 21:49:00 INFO  time: compiled root in 13s
2024.11.08 21:49:24 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:49:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:49:36 WARN  javac exited with exit code 1
2024.11.08 21:49:36 INFO  time: compiled root in 11s
2024.11.08 21:49:42 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:49:54 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:49:54 WARN  javac exited with exit code 1
2024.11.08 21:49:54 INFO  time: compiled root in 11s
Nov. 08, 2024 9:50:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2893
2024.11.08 21:50:29 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:50:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:50:43 WARN  javac exited with exit code 1
2024.11.08 21:50:43 INFO  time: compiled root in 14s
2024.11.08 21:50:43 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:50:58 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:50:58 WARN  javac exited with exit code 1
2024.11.08 21:50:58 INFO  time: compiled root in 14s
2024.11.08 21:52:06 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:52:25 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:52:25 WARN  javac exited with exit code 1
2024.11.08 21:52:25 INFO  time: compiled root in 19s
2024.11.08 21:55:28 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 21:55:40 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 21:55:40 WARN  javac exited with exit code 1
2024.11.08 21:55:40 INFO  time: compiled root in 11s
Nov. 08, 2024 9:57:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3285
Nov. 08, 2024 9:57:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3286
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3289
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3290
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3293
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3296
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3297
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3301
Nov. 08, 2024 9:57:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3304
Nov. 08, 2024 9:58:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3305
Nov. 08, 2024 9:58:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3310
Nov. 08, 2024 9:58:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3311
Nov. 08, 2024 9:58:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3315
Nov. 08, 2024 9:58:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3323
Nov. 08, 2024 9:58:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3324
2024.11.08 22:07:25 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:07:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:07:50 WARN  javac exited with exit code 1
2024.11.08 22:07:50 INFO  time: compiled root in 25s
2024.11.08 22:10:46 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:11:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:11:17 WARN  javac exited with exit code 1
2024.11.08 22:11:17 INFO  time: compiled root in 30s
2024.11.08 22:13:20 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:13:34 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:13:34 WARN  javac exited with exit code 1
2024.11.08 22:13:34 INFO  time: compiled root in 14s
Nov. 08, 2024 10:19:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3564
Nov. 08, 2024 10:19:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3569
2024.11.08 22:19:58 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:20:18 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:20:18 WARN  javac exited with exit code 1
2024.11.08 22:20:18 INFO  time: compiled root in 19s
2024.11.08 22:20:46 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:20:58 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:20:58 WARN  javac exited with exit code 1
2024.11.08 22:20:58 INFO  time: compiled root in 11s
2024.11.08 22:22:08 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:22:24 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:22:24 WARN  javac exited with exit code 1
2024.11.08 22:22:24 INFO  time: compiled root in 15s
Nov. 08, 2024 10:22:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3637
2024.11.08 22:23:11 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:23:24 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:23:24 WARN  javac exited with exit code 1
2024.11.08 22:23:24 INFO  time: compiled root in 13s
2024.11.08 22:23:34 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:23:48 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:23:48 WARN  javac exited with exit code 1
2024.11.08 22:23:48 INFO  time: compiled root in 13s
2024.11.08 22:23:48 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:24:01 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:24:01 WARN  javac exited with exit code 1
2024.11.08 22:24:01 INFO  time: compiled root in 12s
2024.11.08 22:26:06 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:26:20 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:26:20 WARN  javac exited with exit code 1
2024.11.08 22:26:20 INFO  time: compiled root in 13s
Nov. 08, 2024 10:26:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4002
2024.11.08 22:27:06 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:27:09 INFO  time: compiled root in 2.7s
2024.11.08 22:27:30 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:27:32 INFO  time: compiled root in 2.61s
Nov. 08, 2024 10:27:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4149
Nov. 08, 2024 10:28:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4221
2024.11.08 22:28:03 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:28:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:28:15 WARN  javac exited with exit code 1
2024.11.08 22:28:15 INFO  time: compiled root in 12s
2024.11.08 22:28:29 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:28:46 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:28:46 WARN  javac exited with exit code 1
2024.11.08 22:28:46 INFO  time: compiled root in 17s
2024.11.08 22:31:19 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 22:31:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 22:31:36 WARN  javac exited with exit code 1
2024.11.08 22:31:36 INFO  time: compiled root in 16s
Nov. 08, 2024 11:00:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4624
2024.11.08 23:00:32 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:00:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:00:47 WARN  javac exited with exit code 1
2024.11.08 23:00:47 INFO  time: compiled root in 15s
2024.11.08 23:01:19 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:01:33 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:01:33 WARN  javac exited with exit code 1
2024.11.08 23:01:33 INFO  time: compiled root in 13s
2024.11.08 23:02:01 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:02:04 INFO  time: compiled root in 2.47s
2024.11.08 23:02:35 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:02:37 INFO  time: compiled root in 2.57s
2024.11.08 23:02:41 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:02:44 INFO  time: compiled root in 2.22s
2024.11.08 23:04:20 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:04:32 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:04:32 WARN  javac exited with exit code 1
2024.11.08 23:04:32 INFO  time: compiled root in 12s
Nov. 08, 2024 11:08:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5327
2024.11.08 23:08:28 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:08:31 INFO  time: compiled root in 2.53s
2024.11.08 23:09:12 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:09:15 INFO  time: compiled root in 2.79s
Nov. 08, 2024 11:09:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5526
2024.11.08 23:09:41 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:09:59 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:09:59 WARN  javac exited with exit code 1
2024.11.08 23:09:59 INFO  time: compiled root in 17s
2024.11.08 23:12:24 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:12:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:12:36 WARN  javac exited with exit code 1
2024.11.08 23:12:36 INFO  time: compiled root in 11s
2024.11.08 23:12:36 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:12:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:12:50 WARN  javac exited with exit code 1
2024.11.08 23:12:50 INFO  time: compiled root in 14s
Nov. 08, 2024 11:13:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5650
Exception in thread "pool-23-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.08 23:13:28 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:13:42 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:13:42 WARN  javac exited with exit code 1
2024.11.08 23:13:42 INFO  time: compiled root in 14s
Nov. 08, 2024 11:13:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5726
Nov. 08, 2024 11:14:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5773
Nov. 08, 2024 11:15:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5974
2024.11.08 23:16:14 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:108: error: [dialect scala213] end of file expected but } found
}
^
2024.11.08 23:16:14 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:16:14 INFO  time: compiled root in 0.58s
2024.11.08 23:16:22 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:109: error: [dialect scala213] end of file expected but } found
}
^
2024.11.08 23:16:22 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:16:22 INFO  time: compiled root in 0.39s
2024.11.08 23:17:49 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:17:53 INFO  time: compiled root in 3.54s
2024.11.08 23:17:53 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:17:55 INFO  time: compiled root in 1.91s
Nov. 08, 2024 11:18:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6316
Nov. 08, 2024 11:18:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6338
Nov. 08, 2024 11:18:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6365
2024.11.08 23:18:55 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:19:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:19:09 WARN  javac exited with exit code 1
2024.11.08 23:19:09 INFO  time: compiled root in 13s
Nov. 08, 2024 11:19:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6442
2024.11.08 23:19:38 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:19:40 INFO  time: compiled root in 2.19s
Nov. 08, 2024 11:19:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_31/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cservices%5C%5CChartDataService.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fservices%2FChartDataService.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fservices%2FChartDataService.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A47%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A58%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.08 23:20:02 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:20:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:20:15 WARN  javac exited with exit code 1
2024.11.08 23:20:15 INFO  time: compiled root in 12s
2024.11.08 23:20:15 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:20:31 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:20:31 WARN  javac exited with exit code 1
2024.11.08 23:20:31 INFO  time: compiled root in 16s
2024.11.08 23:22:37 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:22:40 INFO  time: compiled root in 3.09s
2024.11.08 23:23:02 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:23:16 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:23:16 WARN  javac exited with exit code 1
2024.11.08 23:23:16 INFO  time: compiled root in 13s
2024.11.08 23:23:29 INFO  compiling root (15 scala sources and 1 java source)
2024.11.08 23:23:41 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:23:41 WARN  javac exited with exit code 1
2024.11.08 23:23:41 INFO  time: compiled root in 12s
2024.11.08 23:26:22 INFO  compiling root (15 scala sources and 1 java source)
Nov. 08, 2024 11:26:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7151
2024.11.08 23:26:35 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.08 23:26:35 WARN  javac exited with exit code 1
2024.11.08 23:26:35 INFO  time: compiled root in 12s
Nov. 08, 2024 11:34:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7234
2024.11.09 00:26:40 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:26:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:26:47 WARN  javac exited with exit code 1
2024.11.09 00:26:47 INFO  time: compiled root in 7.31s
2024.11.09 00:26:56 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:27:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:27:05 WARN  javac exited with exit code 1
2024.11.09 00:27:05 INFO  time: compiled root in 9.05s
Nov. 09, 2024 12:28:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7749
2024.11.09 00:28:14 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:28:14 INFO  time: compiled root in 0.82s
2024.11.09 00:28:30 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:28:30 INFO  time: compiled root in 0.79s
2024.11.09 00:29:14 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:97: error: unclosed string interpolation
        println(s"${batch(0)} ${batch(batck.length - 1)})
                                                        ^
2024.11.09 00:29:14 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:29:14 INFO  time: compiled root in 0.26s
2024.11.09 00:29:28 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:97: error: unclosed string interpolation
        println(s"Batch ${batch(0)} ${batch(batck.length - 1)})
                                                              ^
2024.11.09 00:29:28 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:29:28 INFO  time: compiled root in 0.27s
2024.11.09 00:29:53 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:29:59 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:29:59 WARN  javac exited with exit code 1
2024.11.09 00:29:59 INFO  time: compiled root in 6.07s
2024.11.09 00:30:07 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala:97: error: unclosed string interpolation
        println(s"Batch ${batch(0)} ${batch(batck.length - 1)})
                                                              ^
2024.11.09 00:30:07 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:30:07 INFO  time: compiled root in 0.2s
2024.11.09 00:30:20 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:30:20 INFO  time: compiled root in 0.83s
2024.11.09 00:30:27 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:30:34 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:30:34 WARN  javac exited with exit code 1
2024.11.09 00:30:34 INFO  time: compiled root in 7.08s
Nov. 09, 2024 12:31:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8425
2024.11.09 00:31:44 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:31:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:31:50 WARN  javac exited with exit code 1
2024.11.09 00:31:50 INFO  time: compiled root in 6.72s
2024.11.09 00:32:23 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:32:24 INFO  time: compiled root in 1.25s
Nov. 09, 2024 12:32:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8615
Nov. 09, 2024 12:32:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8618
2024.11.09 00:32:36 WARN  Could not find 'Future' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.09 00:32:36 WARN  Could not find 'Future' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 09, 2024 12:32:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8702
2024.11.09 00:33:07 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:33:07 INFO  time: compiled root in 0.8s
Nov. 09, 2024 12:33:09 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov. 09, 2024 12:33:24 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov. 09, 2024 12:33:26 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov. 09, 2024 12:33:30 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.11.09 00:35:30 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:35:35 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:35:35 WARN  javac exited with exit code 1
2024.11.09 00:35:35 INFO  time: compiled root in 5.15s
2024.11.09 00:45:06 INFO  compiling root (15 scala sources and 1 java source)
2024.11.09 00:45:16 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.09 00:45:16 WARN  javac exited with exit code 1
2024.11.09 00:45:16 INFO  time: compiled root in 10s
2024.11.11 07:46:47 INFO  Shutting down server
2024.11.11 07:46:47 INFO  shutting down Metals
2024.11.11 07:46:48 INFO  Shut down connection with build server.
2024.11.11 07:46:48 INFO  Shut down connection with build server.
2024.11.11 07:46:48 INFO  Shut down connection with build server.
2024.11.11 07:46:48 INFO  Exiting server
2024.11.11 07:48:52 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.96.0-insider.
2024.11.11 07:48:55 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.11 07:48:58 INFO  Attempting to connect to the build server...
2024.11.11 07:49:01 INFO  Found a Bloop server running
2024.11.11 07:49:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.11 07:49:11 INFO  Attempting to connect to the build server...
2024.11.11 07:49:11 INFO  Found a Bloop server running
2024.11.11 07:49:11 INFO  Attempting to connect to the build server...
2024.11.11 07:49:11 INFO  Found a Bloop server running
2024.11.11 07:49:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.11 07:49:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.11 07:49:16 INFO  time: Connected to build server in 17s
2024.11.11 07:49:16 INFO  Connected to Build server: Bloop v2.0.3
2024.11.11 07:49:18 INFO  time: Imported build in 0.79s
2024.11.11 07:49:18 INFO  running doctor check
2024.11.11 07:49:18 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.11 07:49:24 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.11.11 07:51:00 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
Nov. 11, 2024 7:51:03 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 11, 2024 7:51:18 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 11, 2024 7:51:25 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.11 07:51:45 INFO  time: indexed workspace in 2m26s
2024.11.11 07:51:45 INFO  compiling root (15 scala sources and 1 java source)
2024.11.11 07:51:59 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.11 07:51:59 WARN  javac exited with exit code 1
2024.11.11 07:51:59 INFO  time: compiled root in 13s
2024.11.11 07:51:59 INFO  compiling root (15 scala sources and 1 java source)
2024.11.11 07:52:10 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.11 07:52:10 WARN  javac exited with exit code 1
2024.11.11 07:52:10 INFO  time: compiled root in 10s
2024.11.11 19:09:43 INFO  Shutting down server
2024.11.11 19:09:43 INFO  shutting down Metals
2024.11.11 19:09:44 INFO  Shut down connection with build server.
2024.11.11 19:09:44 INFO  Shut down connection with build server.
2024.11.11 19:09:44 INFO  Shut down connection with build server.
2024.11.11 19:09:44 INFO  Exiting server
2024.11.19 18:30:48 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.96.0-insider.
2024.11.19 18:30:52 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.19 18:30:52 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\services\ChartDataService.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.19 18:30:53 INFO  Attempting to connect to the build server...
2024.11.19 18:30:53 INFO  No running Bloop server found, starting one.
2024.11.19 18:31:08 INFO  Starting compilation server
2024.11.19 18:31:31 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.19 18:31:32 INFO  Attempting to connect to the build server...
2024.11.19 18:31:32 INFO  Found a Bloop server running
2024.11.19 18:31:32 INFO  Attempting to connect to the build server...
2024.11.19 18:31:32 INFO  Found a Bloop server running
2024.11.19 18:31:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.19 18:31:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.19 18:31:48 INFO  time: Connected to build server in 55s
2024.11.19 18:31:48 INFO  Connected to Build server: Bloop v2.0.3
2024.11.19 18:31:50 INFO  time: Imported build in 1.53s
2024.11.19 18:31:51 INFO  running doctor check
2024.11.19 18:31:51 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.19 18:31:54 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.11.19 18:32:55 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.19 18:34:23 INFO  time: indexed workspace in 2m33s
2024.11.19 18:34:32 INFO  compiling root (15 scala sources and 1 java source)
2024.11.19 18:35:42 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 18:35:42 WARN  javac exited with exit code 1
2024.11.19 18:35:42 INFO  time: compiled root in 1m10s
2024.11.19 18:37:18 INFO  compiling root (15 scala sources and 1 java source)
2024.11.19 18:38:01 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 18:38:01 WARN  javac exited with exit code 1
2024.11.19 18:38:01 INFO  time: compiled root in 42s
Nov. 19, 2024 6:43:29 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 19, 2024 6:47:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 22
Nov. 19, 2024 6:47:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 23
Nov. 19, 2024 6:55:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 38
Nov. 19, 2024 6:55:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 40
Nov. 19, 2024 6:55:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 41
2024.11.19 19:03:59 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:04:17 INFO  time: compiled root in 17s
Nov. 19, 2024 7:04:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 116
Nov. 19, 2024 7:04:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 159
2024.11.19 19:05:01 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:05:23 INFO  time: compiled root in 22s
2024.11.19 19:11:36 WARN  Could not find 'CandlestickTable' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.19 19:11:45 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:11:46 INFO  time: compiled root in 1.39s
2024.11.19 19:11:52 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:11:57 INFO  time: compiled root in 4.6s
2024.11.19 19:12:15 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:12:19 INFO  time: compiled root in 3.51s
2024.11.19 19:12:40 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:15: error: [dialect scala213] } expected but end of file found
)(implicit ec: ExecutionContext) extends AbstractController(cc) {
                                                                 ^
2024.11.19 19:12:40 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:12:40 INFO  time: compiled root in 0.68s
Nov. 19, 2024 7:12:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 340
2024.11.19 19:12:49 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:35: error: [dialect scala213] } expected but end of file found
}
 ^
2024.11.19 19:12:49 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:12:49 INFO  time: compiled root in 0.59s
2024.11.19 19:12:56 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:12:59 INFO  time: compiled root in 3.51s
2024.11.19 19:13:17 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:13:20 INFO  time: compiled root in 3.29s
2024.11.19 19:13:37 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:13:40 INFO  time: compiled root in 3.21s
2024.11.19 19:13:43 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:13:46 INFO  time: compiled root in 2.63s
2024.11.19 19:14:28 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.19 19:14:28 WARN  Could not find 'time' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 19, 2024 7:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 566
Nov. 19, 2024 7:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 563
Nov. 19, 2024 7:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 571
Nov. 19, 2024 7:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 569
Nov. 19, 2024 7:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 573
Nov. 19, 2024 7:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 579
2024.11.19 19:14:35 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:14:38 INFO  time: compiled root in 3.81s
Nov. 19, 2024 7:14:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 610
2024.11.19 19:14:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:14:44 INFO  time: compiled root in 3.37s
2024.11.19 19:14:48 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:14:51 INFO  time: compiled root in 2.52s
Nov. 19, 2024 7:17:31 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.19 19:28:12 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:28:25 INFO  time: compiled root in 12s
2024.11.19 19:28:40 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:28:43 INFO  time: compiled root in 3.15s
2024.11.19 19:29:04 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:29:07 INFO  time: compiled root in 2.88s
2024.11.19 19:31:59 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:32:02 INFO  time: compiled root in 3.02s
2024.11.19 19:32:53 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.19 19:32:53 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.19 19:32:53 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.19 19:32:53 WARN  Could not find 'take' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.19 19:34:37 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:34:40 INFO  time: compiled root in 3.53s
Nov. 19, 2024 7:35:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 969
2024.11.19 19:35:50 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:36:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 19:36:09 WARN  javac exited with exit code 1
2024.11.19 19:36:09 INFO  time: compiled root in 18s
Nov. 19, 2024 7:36:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1010
2024.11.19 19:36:32 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:36:36 INFO  time: compiled root in 3.44s
2024.11.19 19:37:02 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:37:05 INFO  time: compiled root in 2.88s
2024.11.19 19:37:51 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:37:54 INFO  time: compiled root in 3.36s
2024.11.19 19:41:54 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:41:58 INFO  time: compiled root in 4.58s
2024.11.19 19:43:12 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:43:34 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 19:43:34 WARN  javac exited with exit code 1
2024.11.19 19:43:34 INFO  time: compiled root in 21s
2024.11.19 19:47:52 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 19:48:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 19:48:09 WARN  javac exited with exit code 1
2024.11.19 19:48:09 INFO  time: compiled root in 16s
Nov. 19, 2024 7:51:19 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 19, 2024 8:42:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1047
Nov. 19, 2024 8:42:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1050
2024.11.19 20:42:33 WARN  Could not find 'obj' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 19, 2024 8:46:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1091
2024.11.19 21:01:10 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 21:01:30 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 21:01:30 WARN  javac exited with exit code 1
2024.11.19 21:01:30 INFO  time: compiled root in 20s
2024.11.19 21:06:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.19 21:07:07 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.19 21:07:07 WARN  javac exited with exit code 1
2024.11.19 21:07:07 INFO  time: compiled root in 25s
Nov. 21, 2024 8:20:18 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.21 12:33:10 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 12:33:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1310
2024.11.21 12:33:20 INFO  time: compiled root in 9.87s
Nov. 21, 2024 12:34:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1386
Exception in thread "pool-7-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Nov. 21, 2024 12:34:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1405
2024.11.21 12:34:59 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 12:35:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1420
2024.11.21 12:35:02 INFO  time: compiled root in 2.6s
2024.11.21 12:37:56 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:38:07 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 12:38:07 WARN  javac exited with exit code 1
2024.11.21 12:38:07 INFO  time: compiled root in 11s
2024.11.21 12:40:52 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:41:01 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:200: error: [dialect scala213] } expected but end of file found

^
2024.11.21 12:41:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 12:41:04 WARN  javac exited with exit code 1
2024.11.21 12:41:04 INFO  time: compiled root in 11s
2024.11.21 12:41:04 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 12:41:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1491
Nov. 21, 2024 12:41:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1498
2024.11.21 12:41:08 INFO  time: compiled root in 4.32s
2024.11.21 12:41:08 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:41:11 INFO  time: compiled root in 3.05s
2024.11.21 12:41:23 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:41:24 INFO  time: compiled root in 1.54s
2024.11.21 12:41:38 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:41:40 INFO  time: compiled root in 2.32s
Nov. 21, 2024 12:41:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1648
Nov. 21, 2024 12:42:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1676
2024.11.21 12:42:25 WARN  Could not find 'Singleton' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 12:42:25 WARN  Could not find 'Inject' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 21, 2024 12:42:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1679
Nov. 21, 2024 12:42:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1683
Nov. 21, 2024 12:42:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1688
Nov. 21, 2024 12:42:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1682
Nov. 21, 2024 12:42:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1686
Nov. 21, 2024 12:42:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1685
2024.11.21 12:42:26 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:42:29 INFO  time: compiled root in 2.85s
2024.11.21 12:42:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/lang/Object.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/lang/Object.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 21, 2024 12:42:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/lang/Object.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport jdk.internal.HotSpotIntrinsicCandidate;\n\n/**\n * Class {@code Object} is the root of the class hierarchy.\n * Every class has {@code Object} as a superclass. All objects,\n * including arrays, implement the methods of this class.\n *\n * @author  unascribed\n * @see     java.lang.Class\n * @since   1.0\n */\npublic class Object {\n\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /**\n     * Constructs a new object.\n     */\n    @HotSpotIntrinsicCandidate\n    public Object() {}\n\n    /**\n     * Returns the runtime class of this {@code Object}. The returned\n     * {@code Class} object is the object that is locked by {@code\n     * static synchronized} methods of the represented class.\n     *\n     * \u003cp\u003e\u003cb\u003eThe actual result type is {@code Class\u003c? extends |X|\u003e}\n     * where {@code |X|} is the erasure of the static type of the\n     * expression on which {@code getClass} is called.\u003c/b\u003e For\n     * example, no cast is required in this code fragment:\u003c/p\u003e\n     *\n     * \u003cp\u003e\n     * {@code Number n \u003d 0;                             }\u003cbr\u003e\n     * {@code Class\u003c? extends Number\u003e c \u003d n.getClass(); }\n     * \u003c/p\u003e\n     *\n     * @return The {@code Class} object that represents the runtime\n     *         class of this object.\n     * @jls 15.8.2 Class Literals\n     */\n    @HotSpotIntrinsicCandidate\n    public final native Class\u003c?\u003e getClass();\n\n    /**\n     * Returns a hash code value for the object. This method is\n     * supported for the benefit of hash tables such as those provided by\n     * {@link java.util.HashMap}.\n     * \u003cp\u003e\n     * The general contract of {@code hashCode} is:\n     * \u003cul\u003e\n     * \u003cli\u003eWhenever it is invoked on the same object more than once during\n     *     an execution of a Java application, the {@code hashCode} method\n     *     must consistently return the same integer, provided no information\n     *     used in {@code equals} comparisons on the object is modified.\n     *     This integer need not remain consistent from one execution of an\n     *     application to another execution of the same application.\n     * \u003cli\u003eIf two objects are equal according to the {@code equals(Object)}\n     *     method, then calling the {@code hashCode} method on each of\n     *     the two objects must produce the same integer result.\n     * \u003cli\u003eIt is \u003cem\u003enot\u003c/em\u003e required that if two objects are unequal\n     *     according to the {@link java.lang.Object#equals(java.lang.Object)}\n     *     method, then calling the {@code hashCode} method on each of the\n     *     two objects must produce distinct integer results.  However, the\n     *     programmer should be aware that producing distinct integer results\n     *     for unequal objects may improve the performance of hash tables.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As much as is reasonably practical, the hashCode method defined\n     * by class {@code Object} does return distinct integers for\n     * distinct objects. (The hashCode may or may not be implemented\n     * as some function of an object\u0027s memory address at some point\n     * in time.)\n     *\n     * @return  a hash code value for this object.\n     * @see     java.lang.Object#equals(java.lang.Object)\n     * @see     java.lang.System#identityHashCode\n     */\n    @HotSpotIntrinsicCandidate\n    public native int hashCode();\n\n    /**\n     * Indicates whether some other object is \"equal to\" this one.\n     * \u003cp\u003e\n     * The {@code equals} method implements an equivalence relation\n     * on non-null object references:\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for any non-null reference value\n     *     {@code x}, {@code x.equals(x)} should return\n     *     {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for any non-null reference values\n     *     {@code x} and {@code y}, {@code x.equals(y)}\n     *     should return {@code true} if and only if\n     *     {@code y.equals(x)} returns {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for any non-null reference values\n     *     {@code x}, {@code y}, and {@code z}, if\n     *     {@code x.equals(y)} returns {@code true} and\n     *     {@code y.equals(z)} returns {@code true}, then\n     *     {@code x.equals(z)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003econsistent\u003c/i\u003e: for any non-null reference values\n     *     {@code x} and {@code y}, multiple invocations of\n     *     {@code x.equals(y)} consistently return {@code true}\n     *     or consistently return {@code false}, provided no\n     *     information used in {@code equals} comparisons on the\n     *     objects is modified.\n     * \u003cli\u003eFor any non-null reference value {@code x},\n     *     {@code x.equals(null)} should return {@code false}.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The {@code equals} method for class {@code Object} implements\n     * the most discriminating possible equivalence relation on objects;\n     * that is, for any non-null reference values {@code x} and\n     * {@code y}, this method returns {@code true} if and only\n     * if {@code x} and {@code y} refer to the same object\n     * ({@code x \u003d\u003d y} has the value {@code true}).\n     * \u003cp\u003e\n     * Note that it is generally necessary to override the {@code hashCode}\n     * method whenever this method is overridden, so as to maintain the\n     * general contract for the {@code hashCode} method, which states\n     * that equal objects must have equal hash codes.\n     *\n     * @param   obj   the reference object with which to compare.\n     * @return  {@code true} if this object is the same as the obj\n     *          argument; {@code false} otherwise.\n     * @see     #hashCode()\n     * @see     java.util.HashMap\n     */\n    public boolean equals(Object obj) {\n        return (this \u003d\u003d obj);\n    }\n\n    /**\n     * Creates and returns a copy of this object.  The precise meaning\n     * of \"copy\" may depend on the class of the object. The general\n     * intent is that, for any object {@code x}, the expression:\n     * \u003cblockquote\u003e\n     * \u003cpre\u003e\n     * x.clone() !\u003d x\u003c/pre\u003e\u003c/blockquote\u003e\n     * will be true, and that the expression:\n     * \u003cblockquote\u003e\n     * \u003cpre\u003e\n     * x.clone().getClass() \u003d\u003d x.getClass()\u003c/pre\u003e\u003c/blockquote\u003e\n     * will be {@code true}, but these are not absolute requirements.\n     * While it is typically the case that:\n     * \u003cblockquote\u003e\n     * \u003cpre\u003e\n     * x.clone().equals(x)\u003c/pre\u003e\u003c/blockquote\u003e\n     * will be {@code true}, this is not an absolute requirement.\n     * \u003cp\u003e\n     * By convention, the returned object should be obtained by calling\n     * {@code super.clone}.  If a class and all of its superclasses (except\n     * {@code Object}) obey this convention, it will be the case that\n     * {@code x.clone().getClass() \u003d\u003d x.getClass()}.\n     * \u003cp\u003e\n     * By convention, the object returned by this method should be independent\n     * of this object (which is being cloned).  To achieve this independence,\n     * it may be necessary to modify one or more fields of the object returned\n     * by {@code super.clone} before returning it.  Typically, this means\n     * copying any mutable objects that comprise the internal \"deep structure\"\n     * of the object being cloned and replacing the references to these\n     * objects with references to the copies.  If a class contains only\n     * primitive fields or references to immutable objects, then it is usually\n     * the case that no fields in the object returned by {@code super.clone}\n     * need to be modified.\n     * \u003cp\u003e\n     * The method {@code clone} for class {@code Object} performs a\n     * specific cloning operation. First, if the class of this object does\n     * not implement the interface {@code Cloneable}, then a\n     * {@code CloneNotSupportedException} is thrown. Note that all arrays\n     * are considered to implement the interface {@code Cloneable} and that\n     * the return type of the {@code clone} method of an array type {@code T[]}\n     * is {@code T[]} where T is any reference or primitive type.\n     * Otherwise, this method creates a new instance of the class of this\n     * object and initializes all its fields with exactly the contents of\n     * the corresponding fields of this object, as if by assignment; the\n     * contents of the fields are not themselves cloned. Thus, this method\n     * performs a \"shallow copy\" of this object, not a \"deep copy\" operation.\n     * \u003cp\u003e\n     * The class {@code Object} does not itself implement the interface\n     * {@code Cloneable}, so calling the {@code clone} method on an object\n     * whose class is {@code Object} will result in throwing an\n     * exception at run time.\n     *\n     * @return     a clone of this instance.\n     * @throws  CloneNotSupportedException  if the object\u0027s class does not\n     *               support the {@code Cloneable} interface. Subclasses\n     *               that override the {@code clone} method can also\n     *               throw this exception to indicate that an instance cannot\n     *               be cloned.\n     * @see java.lang.Cloneable\n     */\n    @HotSpotIntrinsicCandidate\n    protected native Object clone() throws CloneNotSupportedException;\n\n    /**\n     * Returns a string representation of the object. In general, the\n     * {@code toString} method returns a string that\n     * \"textually represents\" this object. The result should\n     * be a concise but informative representation that is easy for a\n     * person to read.\n     * It is recommended that all subclasses override this method.\n     * \u003cp\u003e\n     * The {@code toString} method for class {@code Object}\n     * returns a string consisting of the name of the class of which the\n     * object is an instance, the at-sign character `{@code @}\u0027, and\n     * the unsigned hexadecimal representation of the hash code of the\n     * object. In other words, this method returns a string equal to the\n     * value of:\n     * \u003cblockquote\u003e\n     * \u003cpre\u003e\n     * getClass().getName() + \u0027@\u0027 + Integer.toHexString(hashCode())\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @return  a string representation of the object.\n     */\n    public String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n\n    /**\n     * Wakes up a single thread that is waiting on this object\u0027s\n     * monitor. If any threads are waiting on this object, one of them\n     * is chosen to be awakened. The choice is arbitrary and occurs at\n     * the discretion of the implementation. A thread waits on an object\u0027s\n     * monitor by calling one of the {@code wait} methods.\n     * \u003cp\u003e\n     * The awakened thread will not be able to proceed until the current\n     * thread relinquishes the lock on this object. The awakened thread will\n     * compete in the usual manner with any other threads that might be\n     * actively competing to synchronize on this object; for example, the\n     * awakened thread enjoys no reliable privilege or disadvantage in being\n     * the next thread to lock this object.\n     * \u003cp\u003e\n     * This method should only be called by a thread that is the owner\n     * of this object\u0027s monitor. A thread becomes the owner of the\n     * object\u0027s monitor in one of three ways:\n     * \u003cul\u003e\n     * \u003cli\u003eBy executing a synchronized instance method of that object.\n     * \u003cli\u003eBy executing the body of a {@code synchronized} statement\n     *     that synchronizes on the object.\n     * \u003cli\u003eFor objects of type {@code Class,} by executing a\n     *     synchronized static method of that class.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Only one thread at a time can own an object\u0027s monitor.\n     *\n     * @throws  IllegalMonitorStateException  if the current thread is not\n     *               the owner of this object\u0027s monitor.\n     * @see        java.lang.Object#notifyAll()\n     * @see        java.lang.Object#wait()\n     */\n    @HotSpotIntrinsicCandidate\n    public final native void notify();\n\n    /**\n     * Wakes up all threads that are waiting on this object\u0027s monitor. A\n     * thread waits on an object\u0027s monitor by calling one of the\n     * {@code wait} methods.\n     * \u003cp\u003e\n     * The awakened threads will not be able to proceed until the current\n     * thread relinquishes the lock on this object. The awakened threads\n     * will compete in the usual manner with any other threads that might\n     * be actively competing to synchronize on this object; for example,\n     * the awakened threads enjoy no reliable privilege or disadvantage in\n     * being the next thread to lock this object.\n     * \u003cp\u003e\n     * This method should only be called by a thread that is the owner\n     * of this object\u0027s monitor. See the {@code notify} method for a\n     * description of the ways in which a thread can become the owner of\n     * a monitor.\n     *\n     * @throws  IllegalMonitorStateException  if the current thread is not\n     *               the owner of this object\u0027s monitor.\n     * @see        java.lang.Object#notify()\n     * @see        java.lang.Object#wait()\n     */\n    @HotSpotIntrinsicCandidate\n    public final native void notifyAll();\n\n    /**\n     * Causes the current thread to wait until it is awakened, typically\n     * by being \u003cem\u003enotified\u003c/em\u003e or \u003cem\u003einterrupted\u003c/em\u003e.\n     * \u003cp\u003e\n     * In all respects, this method behaves as if {@code wait(0L, 0)}\n     * had been called. See the specification of the {@link #wait(long, int)} method\n     * for details.\n     *\n     * @throws IllegalMonitorStateException if the current thread is not\n     *         the owner of the object\u0027s monitor\n     * @throws InterruptedException if any thread interrupted the current thread before or\n     *         while the current thread was waiting. The \u003cem\u003einterrupted status\u003c/em\u003e of the\n     *         current thread is cleared when this exception is thrown.\n     * @see    #notify()\n     * @see    #notifyAll()\n     * @see    #wait(long)\n     * @see    #wait(long, int)\n     */\n    public final void wait() throws InterruptedException {\n        wait(0L);\n    }\n\n    /**\n     * Causes the current thread to wait until it is awakened, typically\n     * by being \u003cem\u003enotified\u003c/em\u003e or \u003cem\u003einterrupted\u003c/em\u003e, or until a\n     * certain amount of real time has elapsed.\n     * \u003cp\u003e\n     * In all respects, this method behaves as if {@code wait(timeoutMillis, 0)}\n     * had been called. See the specification of the {@link #wait(long, int)} method\n     * for details.\n     *\n     * @param  timeoutMillis the maximum time to wait, in milliseconds\n     * @throws IllegalArgumentException if {@code timeoutMillis} is negative\n     * @throws IllegalMonitorStateException if the current thread is not\n     *         the owner of the object\u0027s monitor\n     * @throws InterruptedException if any thread interrupted the current thread before or\n     *         while the current thread was waiting. The \u003cem\u003einterrupted status\u003c/em\u003e of the\n     *         current thread is cleared when this exception is thrown.\n     * @see    #notify()\n     * @see    #notifyAll()\n     * @see    #wait()\n     * @see    #wait(long, int)\n     */\n    public final native void wait(long timeoutMillis) throws InterruptedException;\n\n    /**\n     * Causes the current thread to wait until it is awakened, typically\n     * by being \u003cem\u003enotified\u003c/em\u003e or \u003cem\u003einterrupted\u003c/em\u003e, or until a\n     * certain amount of real time has elapsed.\n     * \u003cp\u003e\n     * The current thread must own this object\u0027s monitor lock. See the\n     * {@link #notify notify} method for a description of the ways in which\n     * a thread can become the owner of a monitor lock.\n     * \u003cp\u003e\n     * This method causes the current thread (referred to here as \u003cvar\u003eT\u003c/var\u003e) to\n     * place itself in the wait set for this object and then to relinquish any\n     * and all synchronization claims on this object. Note that only the locks\n     * on this object are relinquished; any other objects on which the current\n     * thread may be synchronized remain locked while the thread waits.\n     * \u003cp\u003e\n     * Thread \u003cvar\u003eT\u003c/var\u003e then becomes disabled for thread scheduling purposes\n     * and lies dormant until one of the following occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eSome other thread invokes the {@code notify} method for this\n     * object and thread \u003cvar\u003eT\u003c/var\u003e happens to be arbitrarily chosen as\n     * the thread to be awakened.\n     * \u003cli\u003eSome other thread invokes the {@code notifyAll} method for this\n     * object.\n     * \u003cli\u003eSome other thread {@linkplain Thread#interrupt() interrupts}\n     * thread \u003cvar\u003eT\u003c/var\u003e.\n     * \u003cli\u003eThe specified amount of real time has elapsed, more or less.\n     * The amount of real time, in nanoseconds, is given by the expression\n     * {@code 1000000 * timeoutMillis + nanos}. If {@code timeoutMillis} and {@code nanos}\n     * are both zero, then real time is not taken into consideration and the\n     * thread waits until awakened by one of the other causes.\n     * \u003cli\u003eThread \u003cvar\u003eT\u003c/var\u003e is awakened spuriously. (See below.)\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The thread \u003cvar\u003eT\u003c/var\u003e is then removed from the wait set for this\n     * object and re-enabled for thread scheduling. It competes in the\n     * usual manner with other threads for the right to synchronize on the\n     * object; once it has regained control of the object, all its\n     * synchronization claims on the object are restored to the status quo\n     * ante - that is, to the situation as of the time that the {@code wait}\n     * method was invoked. Thread \u003cvar\u003eT\u003c/var\u003e then returns from the\n     * invocation of the {@code wait} method. Thus, on return from the\n     * {@code wait} method, the synchronization state of the object and of\n     * thread {@code T} is exactly as it was when the {@code wait} method\n     * was invoked.\n     * \u003cp\u003e\n     * A thread can wake up without being notified, interrupted, or timing out, a\n     * so-called \u003cem\u003espurious wakeup\u003c/em\u003e.  While this will rarely occur in practice,\n     * applications must guard against it by testing for the condition that should\n     * have caused the thread to be awakened, and continuing to wait if the condition\n     * is not satisfied. See the example below.\n     * \u003cp\u003e\n     * For more information on this topic, see section 14.2,\n     * \"Condition Queues,\" in Brian Goetz and others\u0027 \u003cem\u003eJava Concurrency\n     * in Practice\u003c/em\u003e (Addison-Wesley, 2006) or Item 69 in Joshua\n     * Bloch\u0027s \u003cem\u003eEffective Java, Second Edition\u003c/em\u003e (Addison-Wesley,\n     * 2008).\n     * \u003cp\u003e\n     * If the current thread is {@linkplain java.lang.Thread#interrupt() interrupted}\n     * by any thread before or while it is waiting, then an {@code InterruptedException}\n     * is thrown.  The \u003cem\u003einterrupted status\u003c/em\u003e of the current thread is cleared when\n     * this exception is thrown. This exception is not thrown until the lock status of\n     * this object has been restored as described above.\n     *\n     * @apiNote\n     * The recommended approach to waiting is to check the condition being awaited in\n     * a {@code while} loop around the call to {@code wait}, as shown in the example\n     * below. Among other things, this approach avoids problems that can be caused\n     * by spurious wakeups.\n     *\n     * \u003cpre\u003e{@code\n     *     synchronized (obj) {\n     *         while (\u003ccondition does not hold\u003e and \u003ctimeout not exceeded\u003e) {\n     *             long timeoutMillis \u003d ... ; // recompute timeout values\n     *             int nanos \u003d ... ;\n     *             obj.wait(timeoutMillis, nanos);\n     *         }\n     *         ... // Perform action appropriate to condition or timeout\n     *     }\n     * }\u003c/pre\u003e\n     *\n     * @param  timeoutMillis the maximum time to wait, in milliseconds\n     * @param  nanos   additional time, in nanoseconds, in the range range 0-999999 inclusive\n     * @throws IllegalArgumentException if {@code timeoutMillis} is negative,\n     *         or if the value of {@code nanos} is out of range\n     * @throws IllegalMonitorStateException if the current thread is not\n     *         the owner of the object\u0027s monitor\n     * @throws InterruptedException if any thread interrupted the current thread before or\n     *         while the current thread was waiting. The \u003cem\u003einterrupted status\u003c/em\u003e of the\n     *         current thread is cleared when this exception is thrown.\n     * @see    #notify()\n     * @see    #notifyAll()\n     * @see    #wait()\n     * @see    #wait(long)\n     */\n    public final void wait(long timeoutMillis, int nanos) throws InterruptedException {\n        if (timeoutMillis \u003c 0) {\n            throw new IllegalArgumentException(\"timeoutMillis value is negative\");\n        }\n\n        if (nanos \u003c 0 || nanos \u003e 999999) {\n            throw new IllegalArgumentException(\n                                \"nanosecond timeout value out of range\");\n        }\n\n        if (nanos \u003e 0) {\n            timeoutMillis++;\n        }\n\n        wait(timeoutMillis);\n    }\n\n    /**\n     * Called by the garbage collector on an object when garbage collection\n     * determines that there are no more references to the object.\n     * A subclass overrides the {@code finalize} method to dispose of\n     * system resources or to perform other cleanup.\n     * \u003cp\u003e\n     * The general contract of {@code finalize} is that it is invoked\n     * if and when the Java\u0026trade; virtual\n     * machine has determined that there is no longer any\n     * means by which this object can be accessed by any thread that has\n     * not yet died, except as a result of an action taken by the\n     * finalization of some other object or class which is ready to be\n     * finalized. The {@code finalize} method may take any action, including\n     * making this object available again to other threads; the usual purpose\n     * of {@code finalize}, however, is to perform cleanup actions before\n     * the object is irrevocably discarded. For example, the finalize method\n     * for an object that represents an input/output connection might perform\n     * explicit I/O transactions to break the connection before the object is\n     * permanently discarded.\n     * \u003cp\u003e\n     * The {@code finalize} method of class {@code Object} performs no\n     * special action; it simply returns normally. Subclasses of\n     * {@code Object} may override this definition.\n     * \u003cp\u003e\n     * The Java programming language does not guarantee which thread will\n     * invoke the {@code finalize} method for any given object. It is\n     * guaranteed, however, that the thread that invokes finalize will not\n     * be holding any user-visible synchronization locks when finalize is\n     * invoked. If an uncaught exception is thrown by the finalize method,\n     * the exception is ignored and finalization of that object terminates.\n     * \u003cp\u003e\n     * After the {@code finalize} method has been invoked for an object, no\n     * further action is taken until the Java virtual machine has again\n     * determined that there is no longer any means by which this object can\n     * be accessed by any thread that has not yet died, including possible\n     * actions by other objects or classes which are ready to be finalized,\n     * at which point the object may be discarded.\n     * \u003cp\u003e\n     * The {@code finalize} method is never invoked more than once by a Java\n     * virtual machine for any given object.\n     * \u003cp\u003e\n     * Any exception thrown by the {@code finalize} method causes\n     * the finalization of this object to be halted, but is otherwise\n     * ignored.\n     *\n     * @apiNote\n     * Classes that embed non-heap resources have many options\n     * for cleanup of those resources. The class must ensure that the\n     * lifetime of each instance is longer than that of any resource it embeds.\n     * {@link java.lang.ref.Reference#reachabilityFence} can be used to ensure that\n     * objects remain reachable while resources embedded in the object are in use.\n     * \u003cp\u003e\n     * A subclass should avoid overriding the {@code finalize} method\n     * unless the subclass embeds non-heap resources that must be cleaned up\n     * before the instance is collected.\n     * Finalizer invocations are not automatically chained, unlike constructors.\n     * If a subclass overrides {@code finalize} it must invoke the superclass\n     * finalizer explicitly.\n     * To guard against exceptions prematurely terminating the finalize chain,\n     * the subclass should use a {@code try-finally} block to ensure\n     * {@code super.finalize()} is always invoked. For example,\n     * \u003cpre\u003e{@code      @Override\n     *     protected void finalize() throws Throwable {\n     *         try {\n     *             ... // cleanup subclass state\n     *         } finally {\n     *             super.finalize();\n     *         }\n     *     }\n     * }\u003c/pre\u003e\n     *\n     * @deprecated The finalization mechanism is inherently problematic.\n     * Finalization can lead to performance issues, deadlocks, and hangs.\n     * Errors in finalizers can lead to resource leaks; there is no way to cancel\n     * finalization if it is no longer necessary; and no ordering is specified\n     * among calls to {@code finalize} methods of different objects.\n     * Furthermore, there are no guarantees regarding the timing of finalization.\n     * The {@code finalize} method might be called on a finalizable object\n     * only after an indefinite delay, if at all.\n     *\n     * Classes whose instances hold non-heap resources should provide a method\n     * to enable explicit release of those resources, and they should also\n     * implement {@link AutoCloseable} if appropriate.\n     * The {@link java.lang.ref.Cleaner} and {@link java.lang.ref.PhantomReference}\n     * provide more flexible and efficient ways to release resources when an object\n     * becomes unreachable.\n     *\n     * @throws Throwable the {@code Exception} raised by this method\n     * @see java.lang.ref.WeakReference\n     * @see java.lang.ref.PhantomReference\n     * @jls 12.6 Finalization of Class Instances\n     */\n    @Deprecated(since\u003d\"9\")\n    protected void finalize() throws Throwable { }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/lang/Object.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/lang/Object.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Nov. 21, 2024 12:42:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/lang/Object.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/lang/Object.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/lang/Object.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.11.21 12:42:32 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:42:42 INFO  time: compiled root in 9.39s
Nov. 21, 2024 12:42:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1746
Nov. 21, 2024 12:42:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1747
Nov. 21, 2024 12:42:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1748
Nov. 21, 2024 12:43:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1758
2024.11.21 12:44:38 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:44:49 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 12:44:49 WARN  javac exited with exit code 1
2024.11.21 12:44:49 INFO  time: compiled root in 11s
2024.11.21 12:45:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:45:51 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 12:45:51 WARN  javac exited with exit code 1
2024.11.21 12:45:51 INFO  time: compiled root in 9.4s
2024.11.21 12:48:48 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:49:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 12:49:00 WARN  javac exited with exit code 1
2024.11.21 12:49:00 INFO  time: compiled root in 12s
2024.11.21 12:54:36 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:230: error: [dialect scala213] } expected but case found
          case None =>
          ^
2024.11.21 12:54:36 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:54:36 INFO  time: compiled root in 0.43s
2024.11.21 12:54:40 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:230: error: [dialect scala213] } expected but case found
          case None =>
          ^
2024.11.21 12:54:40 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:54:40 INFO  time: compiled root in 0.55s
2024.11.21 12:56:36 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 12:56:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 12:56:47 WARN  javac exited with exit code 1
2024.11.21 12:56:47 INFO  time: compiled root in 10s
2024.11.21 13:03:34 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:03:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 13:03:43 WARN  javac exited with exit code 1
2024.11.21 13:03:43 INFO  time: compiled root in 8.77s
Nov. 21, 2024 1:05:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2113
Nov. 21, 2024 1:05:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2119
Nov. 21, 2024 1:05:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2146
2024.11.21 13:05:53 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 1:06:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2166
Exception in thread "pool-7-thread-2" Nov. 21, 2024 1:06:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2169
java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.21 13:06:10 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 13:06:10 WARN  javac exited with exit code 1
2024.11.21 13:06:10 INFO  time: compiled root in 17s
Nov. 21, 2024 1:06:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2172
Nov. 21, 2024 1:06:29 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov. 21, 2024 1:06:29 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\.reports\metals-full\2024-11-21\r_compiler-error_(root)_13-06-29-431.md
Nov. 21, 2024 1:07:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_29/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A280%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 1:07:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_29/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A280%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 13:07:45 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:07:55 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 13:07:55 WARN  javac exited with exit code 1
2024.11.21 13:07:55 INFO  time: compiled root in 9.46s
2024.11.21 13:15:35 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:15:51 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 13:15:51 WARN  javac exited with exit code 1
2024.11.21 13:15:51 INFO  time: compiled root in 15s
Nov. 21, 2024 1:16:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_29/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A280%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 1:16:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2348
2024.11.21 13:16:49 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:17:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 13:17:00 WARN  javac exited with exit code 1
2024.11.21 13:17:00 INFO  time: compiled root in 10s
2024.11.21 13:41:44 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:41:44 ERROR C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala
scala.meta.internal.tokenizers.package$UnexpectedInputEndException
	at scala.meta.internal.tokenizers.LegacyScanner.$anonfun$nextToken$1(LegacyScanner.scala:172)
	at scala.Function0.apply$mcV$sp(Function0.scala:42)
	at scala.meta.internal.tokenizers.LegacyScanner.scala$meta$internal$tokenizers$LegacyScanner$$nextToken(LegacyScanner.scala:178)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:172)
	at scala.meta.internal.mtags.ScalaToplevelMtags$XtensionScanner.mtagsNextToken(ScalaToplevelMtags.scala:73)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:478)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:85)
	at scala.meta.internal.metals.SemanticdbDefinition$.foreachWithReturnMtags(SemanticdbDefinition.scala:81)
	at scala.meta.internal.metals.Indexer.indexSourceFile(Indexer.scala:485)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3(Indexer.scala:583)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3$adapted(Indexer.scala:580)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1303)
	at scala.meta.internal.metals.Indexer.reindexWorkspaceSources(Indexer.scala:580)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$2(MetalsLspService.scala:946)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 13:41:44 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:41:46 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:41:55 INFO  time: compiled root in 11s
2024.11.21 13:41:55 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:41:55 INFO  time: compiled root in 0.29s
2024.11.21 13:41:58 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:41:58 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:41:58 INFO  time: compiled root in 0.42s
2024.11.21 13:42:11 WARN  Could not find 'Future' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 13:42:24 WARN  Could not find 'Future' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 13:42:25 WARN  Could not find 'NotFound' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 21, 2024 1:43:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_31/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A288%2C%22endColumn%22%3A2%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 13:43:41 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:43:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:43:41 INFO  time: compiled root in 0.53s
2024.11.21 13:43:53 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:43:54 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:43:54 INFO  time: compiled root in 0.38s
2024.11.21 13:43:56 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:43:57 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 1:43:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2668
2024.11.21 13:43:57 INFO  time: compiled root in 0.44s
Nov. 21, 2024 1:43:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2677
Nov. 21, 2024 1:43:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2678
Nov. 21, 2024 1:43:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2680
2024.11.21 13:43:59 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:43:59 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:43:59 INFO  time: compiled root in 0.38s
2024.11.21 13:44:03 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:44:03 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:44:03 INFO  time: compiled root in 0.6s
Nov. 21, 2024 1:45:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_32/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A289%2C%22endColumn%22%3A3%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 1:45:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_32/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A289%2C%22endColumn%22%3A3%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 13:45:55 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:45:55 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:45:55 INFO  time: compiled root in 0.38s
Nov. 21, 2024 1:45:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://51e86eab-a194-41e1-a596-b8f8b0df0646/response_32/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CChartController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FChartController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A289%2C%22endColumn%22%3A3%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 13:46:04 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:46:04 ERROR C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala
scala.meta.internal.tokenizers.package$UnexpectedInputEndException
	at scala.meta.internal.tokenizers.LegacyScanner.$anonfun$nextToken$1(LegacyScanner.scala:172)
	at scala.Function0.apply$mcV$sp(Function0.scala:42)
	at scala.meta.internal.tokenizers.LegacyScanner.scala$meta$internal$tokenizers$LegacyScanner$$nextToken(LegacyScanner.scala:178)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:172)
	at scala.meta.internal.mtags.ScalaToplevelMtags$XtensionScanner.mtagsNextToken(ScalaToplevelMtags.scala:73)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:478)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:85)
	at scala.meta.internal.metals.SemanticdbDefinition$.foreachWithReturnMtags(SemanticdbDefinition.scala:81)
	at scala.meta.internal.metals.Indexer.indexSourceFile(Indexer.scala:485)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3(Indexer.scala:583)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3$adapted(Indexer.scala:580)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1303)
	at scala.meta.internal.metals.Indexer.reindexWorkspaceSources(Indexer.scala:580)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$2(MetalsLspService.scala:946)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 13:46:04 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:46:04 INFO  time: compiled root in 0.37s
2024.11.21 13:49:40 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:264: error: [dialect scala213] } expected but case found
                case None =>
                ^
2024.11.21 13:49:41 ERROR C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala
scala.meta.internal.tokenizers.package$UnexpectedInputEndException
	at scala.meta.internal.tokenizers.LegacyScanner.$anonfun$nextToken$1(LegacyScanner.scala:172)
	at scala.Function0.apply$mcV$sp(Function0.scala:42)
	at scala.meta.internal.tokenizers.LegacyScanner.scala$meta$internal$tokenizers$LegacyScanner$$nextToken(LegacyScanner.scala:178)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:172)
	at scala.meta.internal.mtags.ScalaToplevelMtags$XtensionScanner.mtagsNextToken(ScalaToplevelMtags.scala:73)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:478)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:85)
	at scala.meta.internal.metals.SemanticdbDefinition$.foreachWithReturnMtags(SemanticdbDefinition.scala:81)
	at scala.meta.internal.metals.Indexer.indexSourceFile(Indexer.scala:485)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3(Indexer.scala:583)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3$adapted(Indexer.scala:580)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1303)
	at scala.meta.internal.metals.Indexer.reindexWorkspaceSources(Indexer.scala:580)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$2(MetalsLspService.scala:946)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 13:49:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:49:41 INFO  time: compiled root in 0.8s
2024.11.21 13:49:47 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:264: error: [dialect scala213] } expected but case found
                case None =>
                ^
2024.11.21 13:49:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:49:47 INFO  time: compiled root in 0.38s
2024.11.21 13:50:50 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:264: error: [dialect scala213] } expected but case found
                case None =>
                ^
2024.11.21 13:50:50 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:50:50 INFO  time: compiled root in 0.41s
Nov. 21, 2024 1:51:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2997
Nov. 21, 2024 1:51:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2994
Nov. 21, 2024 1:51:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2996
Nov. 21, 2024 1:51:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3004
2024.11.21 13:51:08 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:264: error: [dialect scala213] } expected but case found
                case None =>
                ^
2024.11.21 13:51:08 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:51:08 INFO  time: compiled root in 0.56s
2024.11.21 13:52:19 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:52:21 INFO  time: compiled root in 1.95s
2024.11.21 13:52:37 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:264: error: [dialect scala213] } expected but case found
                case None =>
                ^
2024.11.21 13:52:37 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:52:37 INFO  time: compiled root in 0.45s
2024.11.21 13:52:47 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:264: error: [dialect scala213] } expected but case found
                case None =>
                ^
2024.11.21 13:52:47 ERROR C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala
scala.meta.internal.tokenizers.package$UnexpectedInputEndException
	at scala.meta.internal.tokenizers.LegacyScanner.$anonfun$nextToken$1(LegacyScanner.scala:172)
	at scala.Function0.apply$mcV$sp(Function0.scala:42)
	at scala.meta.internal.tokenizers.LegacyScanner.scala$meta$internal$tokenizers$LegacyScanner$$nextToken(LegacyScanner.scala:178)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:172)
	at scala.meta.internal.mtags.ScalaToplevelMtags$XtensionScanner.mtagsNextToken(ScalaToplevelMtags.scala:73)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:478)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:85)
	at scala.meta.internal.metals.SemanticdbDefinition$.foreachWithReturnMtags(SemanticdbDefinition.scala:81)
	at scala.meta.internal.metals.Indexer.indexSourceFile(Indexer.scala:485)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3(Indexer.scala:583)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3$adapted(Indexer.scala:580)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1303)
	at scala.meta.internal.metals.Indexer.reindexWorkspaceSources(Indexer.scala:580)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$2(MetalsLspService.scala:946)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 13:52:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:52:47 INFO  time: compiled root in 0.38s
Nov. 21, 2024 1:53:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3144
Nov. 21, 2024 1:53:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3164
2024.11.21 13:53:19 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:53:19 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:53:19 INFO  time: compiled root in 0.33s
2024.11.21 13:53:28 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala:262: error: [dialect scala213] } expected but case found
              case None =>
              ^
2024.11.21 13:53:28 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:53:28 INFO  time: compiled root in 0.29s
Nov. 21, 2024 1:53:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3255
2024.11.21 13:53:33 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 13:53:45 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 13:53:45 WARN  javac exited with exit code 1
2024.11.21 13:53:45 INFO  time: compiled root in 11s
Nov. 21, 2024 1:56:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3291
Nov. 21, 2024 2:06:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3294
2024.11.21 15:37:54 INFO  time: code lens generation in 1.58s
Exception in thread "pool-7-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.21 15:58:15 WARN  Could not find 'Inject' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 21, 2024 3:58:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3344
Nov. 21, 2024 3:58:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3345
Nov. 21, 2024 3:58:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3365
2024.11.21 15:58:33 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 15:58:33 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 15:58:33 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 15:58:33 WARN  Could not find 'headOption' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 15:58:33 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 15:58:33 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 15:58:33 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.21 15:58:33 WARN  Could not find 'headOption' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 15:59:33 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 3:59:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3435
2024.11.21 15:59:45 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 15:59:46 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 15:59:46 WARN  javac exited with exit code 1
2024.11.21 15:59:46 INFO  time: compiled root in 1.21s
2024.11.21 15:59:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 45h 28m 23.697s)
2024.11.21 15:59:54 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 15:59:58 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 15:59:58 WARN  javac exited with exit code 1
2024.11.21 15:59:58 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 15:59:58 WARN  javac exited with exit code 1
2024.11.21 15:59:58 INFO  time: compiled root in 3.26s
2024.11.21 16:01:07 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:01:10 INFO  time: compiled root in 2.32s
2024.11.21 16:01:31 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:01:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 16:01:43 WARN  javac exited with exit code 1
2024.11.21 16:01:43 INFO  time: compiled root in 11s
2024.11.21 16:02:20 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:02:34 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 16:02:34 WARN  javac exited with exit code 1
2024.11.21 16:02:34 INFO  time: compiled root in 14s
2024.11.21 16:05:37 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:05:39 INFO  time: compiled root in 1.62s
2024.11.21 16:05:53 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:05:55 INFO  time: compiled root in 2.03s
Nov. 21, 2024 4:10:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_35/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 16:10:14 WARN  Could not find 'Candlestick' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Exception in thread "pool-7-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.21 16:10:14 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:10:16 INFO  time: compiled root in 1.38s
2024.11.21 16:13:03 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 16:13:03 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 16:13:03 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 4:13:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3819
2024.11.21 16:13:15 INFO  time: code lens generation in 5.07s
Nov. 21, 2024 4:14:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3835
Nov. 21, 2024 4:14:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_37/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A24%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 16:14:22 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt:16: error: [dialect scala213] ) expected but string constant found
      "org.scalatest" %% "scalatest" % "3.2.9" % Test,
      ^
Nov. 21, 2024 4:14:22 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\.reports\metals-full\2024-11-21\r_compiler-error_(backend-build)_16-14-22-845.md
2024.11.21 16:15:13 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 4:15:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3916
2024.11.21 16:15:21 INFO  time: compiled root in 7.79s
2024.11.21 16:15:21 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:15:24 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 21, 2024 4:15:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 21, 2024 4:15:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 21, 2024 4:15:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3933
Nov. 21, 2024 4:15:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3935
2024.11.21 16:15:24 INFO  time: compiled root in 3.53s
2024.11.21 16:15:24 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 16:15:26 INFO  time: compiled root in 1.93s
Nov. 21, 2024 4:17:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_38/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Ctest%5C%5Ccontrollers%5C%5Cmodels%5C%5Crepositories%5C%5CCandlesRepositorySpec.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Ftest%2Fcontrollers%2Fmodels%2Frepositories%2FCandlesRepositorySpec.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Ftest%2Fcontrollers%2Fmodels%2Frepositories%2FCandlesRepositorySpec.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 16:17:38 INFO  skipping build import with status 'Dismissed'
Nov. 21, 2024 4:17:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_38/2#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Ctest%5C%5Ccontrollers%5C%5Cmodels%5C%5Crepositories%5C%5CCandlesRepositorySpec.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Ftest%2Fcontrollers%2Fmodels%2Frepositories%2FCandlesRepositorySpec.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Ftest%2Fcontrollers%2Fmodels%2Frepositories%2FCandlesRepositorySpec.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 4:18:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4011
Nov. 21, 2024 4:18:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4009
Nov. 21, 2024 4:18:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4012
Nov. 21, 2024 4:18:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4014
Nov. 21, 2024 4:18:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4015
2024.11.21 16:18:09 INFO  skipping build import with status 'Dismissed'
2024.11.21 16:18:12 INFO  time: code lens generation in 2.52s
2024.11.21 16:18:12 INFO  time: code lens generation in 3.05s
2024.11.21 16:18:12 INFO  time: code lens generation in 3.08s
2024.11.21 16:18:12 INFO  time: code lens generation in 3.05s
2024.11.21 16:19:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 16:19:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 4:20:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_40/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A28%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 4:20:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_40/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A28%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 4:21:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://440ffa3d-e5fc-4247-b583-25aa64f1c6d0/response_40/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A28%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 16:22:24 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
Nov. 21, 2024 4:22:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4121
Nov. 21, 2024 4:24:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4146
2024.11.21 16:24:49 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals1839856050821825300\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 16:24:57 INFO  sbt thinks that server is already booting because of this exception:
2024.11.21 16:24:57 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-7655597824915523364_lock, error 5
2024.11.21 16:24:57 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:356)
2024.11.21 16:24:57 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:295)
2024.11.21 16:24:57 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:150)
2024.11.21 16:24:57 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:77)
2024.11.21 16:24:57 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:77)
2024.11.21 16:24:57 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:85)
2024.11.21 16:24:57 ERROR 	at sbt.xMain$.run(Main.scala:121)
2024.11.21 16:24:57 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.11.21 16:24:57 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2024.11.21 16:24:57 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.11.21 16:24:57 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
2024.11.21 16:24:57 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:57)
2024.11.21 16:24:57 ERROR 	at sbt.xMain.run(Main.scala:46)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.11.21 16:24:57 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.11.21 16:24:57 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-7655597824915523364_lock, error 5
2024.11.21 16:24:57 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.11.21 16:24:57 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.11.21 16:24:57 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:350)
2024.11.21 16:24:57 ERROR 	... 23 more
2024.11.21 16:24:57 INFO  time: ran 'sbt bloopInstall' in 8.1s
2024.11.21 16:24:57 ERROR sbt command failed: C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals1839856050821825300\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.11.21 16:24:57 INFO  Disconnecting from Bloop session...
2024.11.21 16:24:57 INFO  Shut down connection with build server.
2024.11.21 16:24:57 INFO  Shut down connection with build server.
2024.11.21 16:24:57 INFO  Shut down connection with build server.
2024.11.21 16:24:57 INFO  Attempting to connect to the build server...
2024.11.21 16:24:57 INFO  Found a Bloop server running
2024.11.21 16:24:59 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 16:24:59 INFO  Attempting to connect to the build server...
2024.11.21 16:24:59 INFO  Found a Bloop server running
2024.11.21 16:24:59 INFO  Attempting to connect to the build server...
2024.11.21 16:24:59 INFO  Found a Bloop server running
2024.11.21 16:25:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 16:25:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 16:25:01 INFO  time: Connected to build server in 4.58s
2024.11.21 16:25:01 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 16:25:02 INFO  time: Imported build in 0.31s
2024.11.21 16:25:03 INFO  running doctor check
2024.11.21 16:25:03 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.21 16:25:07 INFO  time: code lens generation in 1.44s
Nov. 21, 2024 4:25:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4180
Nov. 21, 2024 4:25:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4184
2024.11.21 16:25:16 INFO  time: code lens generation in 1.46s
2024.11.21 16:25:16 INFO  time: code lens generation in 1.2s
2024.11.21 16:25:16 INFO  time: code lens generation in 1.56s
Nov. 21, 2024 4:25:34 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\.reports\metals-full\2024-11-21\r_compiler-error_(backend-build)_16-25-34-403.md
2024.11.21 16:25:36 INFO  skipping build import with status 'Dismissed'
2024.11.21 16:26:06 INFO  compiling root (10 scala sources)
2024.11.21 16:26:08 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/target/scala-2.13/routes/main/router/Routes.scala
2024.11.21 16:26:08 INFO  time: compiled root in 2.39s
2024.11.21 16:26:08 INFO  compiling root (8 scala sources)
2024.11.21 16:26:10 INFO  time: compiled root in 1.21s
2024.11.21 16:26:13 INFO  time: indexed workspace in 1m10s
2024.11.21 16:26:13 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc
2024.11.21 16:26:13 INFO  compiling root (8 scala sources)
2024.11.21 16:26:14 INFO  time: compiled root in 1.39s
2024.11.21 16:26:27 INFO  skipping build import with status 'Dismissed'
Nov. 21, 2024 4:26:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://235bbdb4-4ae2-46e0-a3a5-8f6425104a54/response_42/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A24%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 21, 2024 4:26:49 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\.reports\metals-full\2024-11-21\r_compiler-error_(backend-build)_16-26-49-473.md
Nov. 21, 2024 4:26:50 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNUNG: offset 5522, count -1, length 5826
2024.11.21 16:26:54 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals645371007541116564\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 16:26:59 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.11.21 16:26:59 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.11.21 16:27:01 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.11.21 16:27:03 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.11.21 16:27:03 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.11.21 16:27:11 INFO  [success] Generated .bloop\backend-build-build.json
2024.11.21 16:27:11 INFO  [success] Total time: 8 s, completed 21.11.2024, 16:27:12
2024.11.21 16:27:18 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.11.21 16:27:18 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.11.21 16:27:22 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.11.21 16:27:22 INFO  [warn] Removed stale C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.bloop\backend-build.json
2024.11.21 16:27:22 INFO  [error] java.lang.RuntimeException: found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
2024.11.21 16:27:22 INFO  [error] 
2024.11.21 16:27:22 INFO  [error] 	* org.scala-lang.modules:scala-xml_2.12:2.2.0 (early-semver) is selected over {1.2.0, 1.1.1, 1.3.0, 1.0.6}
2024.11.21 16:27:22 INFO  [error] 	    +- org.scoverage:scalac-scoverage-reporter_2.12:2.0.11 (depends on 2.2.0)
2024.11.21 16:27:22 INFO  [error] 	    +- org.scala-lang:scala-compiler:2.12.16              (depends on 1.0.6)
2024.11.21 16:27:22 INFO  [error] 	    +- org.foundweekends.giter8:giter8-lib_2.12:0.13.1    (depends on 1.3.0)
2024.11.21 16:27:22 INFO  [error] 	    +- com.typesafe.sbt:sbt-native-packager:1.5.2 (scalaVersion=2.12, sbtVersion=1.0) (depends on 1.1.1)
2024.11.21 16:27:22 INFO  [error] 	    +- com.typesafe.play:twirl-api_2.12:1.5.1             (depends on 1.2.0)
2024.11.21 16:27:22 INFO  [error] 
2024.11.21 16:27:22 INFO  [error] 
2024.11.21 16:27:22 INFO  [error] this can be overridden using libraryDependencySchemes or evictionErrorLevel
2024.11.21 16:27:22 INFO  [error] 	at scala.sys.package$.error(package.scala:30)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:89)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:133)
2024.11.21 16:27:22 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:73)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:146)
2024.11.21 16:27:22 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:146)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:127)
2024.11.21 16:27:22 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:219)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:160)
2024.11.21 16:27:22 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3687)
2024.11.21 16:27:22 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:62)
2024.11.21 16:27:22 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:68)
2024.11.21 16:27:22 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:282)
2024.11.21 16:27:22 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:23)
2024.11.21 16:27:22 INFO  [error] 	at sbt.Execute.work(Execute.scala:291)
2024.11.21 16:27:22 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:282)
2024.11.21 16:27:22 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.11.21 16:27:22 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:64)
2024.11.21 16:27:22 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.11.21 16:27:22 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
2024.11.21 16:27:22 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.11.21 16:27:22 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
2024.11.21 16:27:22 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
2024.11.21 16:27:22 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:834)
2024.11.21 16:27:22 INFO  [error] (update) found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
2024.11.21 16:27:22 INFO  [error] 
2024.11.21 16:27:22 INFO  [error] 	* org.scala-lang.modules:scala-xml_2.12:2.2.0 (early-semver) is selected over {1.2.0, 1.1.1, 1.3.0, 1.0.6}
2024.11.21 16:27:22 INFO  [error] 	    +- org.scoverage:scalac-scoverage-reporter_2.12:2.0.11 (depends on 2.2.0)
2024.11.21 16:27:22 INFO  [error] 	    +- org.scala-lang:scala-compiler:2.12.16              (depends on 1.0.6)
2024.11.21 16:27:22 INFO  [error] 	    +- org.foundweekends.giter8:giter8-lib_2.12:0.13.1    (depends on 1.3.0)
2024.11.21 16:27:22 INFO  [error] 	    +- com.typesafe.sbt:sbt-native-packager:1.5.2 (scalaVersion=2.12, sbtVersion=1.0) (depends on 1.1.1)
2024.11.21 16:27:22 INFO  [error] 	    +- com.typesafe.play:twirl-api_2.12:1.5.1             (depends on 1.2.0)
2024.11.21 16:27:22 INFO  [error] 
2024.11.21 16:27:22 INFO  [error] 
2024.11.21 16:27:22 INFO  [error] this can be overridden using libraryDependencySchemes or evictionErrorLevel
2024.11.21 16:27:22 INFO  [error] Total time: 4 s, completed 21.11.2024, 16:27:22
2024.11.21 16:27:22 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.11.21 16:27:23 INFO  [error] java.lang.RuntimeException: found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
2024.11.21 16:27:23 INFO  [error] 
2024.11.21 16:27:23 INFO  [error] 	* org.scala-lang.modules:scala-xml_2.12:2.2.0 (early-semver) is selected over {1.2.0, 1.1.1, 1.3.0, 1.0.6}
2024.11.21 16:27:23 INFO  [error] 	    +- org.scoverage:scalac-scoverage-reporter_2.12:2.0.11 (depends on 2.2.0)
2024.11.21 16:27:23 INFO  [error] 	    +- org.scala-lang:scala-compiler:2.12.16              (depends on 1.0.6)
2024.11.21 16:27:23 INFO  [error] 	    +- org.foundweekends.giter8:giter8-lib_2.12:0.13.1    (depends on 1.3.0)
2024.11.21 16:27:23 INFO  [error] 	    +- com.typesafe.sbt:sbt-native-packager:1.5.2 (scalaVersion=2.12, sbtVersion=1.0) (depends on 1.1.1)
2024.11.21 16:27:23 INFO  [error] 	    +- com.typesafe.play:twirl-api_2.12:1.5.1             (depends on 1.2.0)
2024.11.21 16:27:23 INFO  [error] 
2024.11.21 16:27:23 INFO  [error] 
2024.11.21 16:27:23 INFO  [error] this can be overridden using libraryDependencySchemes or evictionErrorLevel
2024.11.21 16:27:23 INFO  [error] 	at scala.sys.package$.error(package.scala:30)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:89)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:133)
2024.11.21 16:27:23 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:73)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:146)
2024.11.21 16:27:23 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:146)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:127)
2024.11.21 16:27:23 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:219)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:160)
2024.11.21 16:27:23 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3687)
2024.11.21 16:27:23 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:62)
2024.11.21 16:27:23 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:68)
2024.11.21 16:27:23 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:282)
2024.11.21 16:27:23 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:23)
2024.11.21 16:27:23 INFO  [error] 	at sbt.Execute.work(Execute.scala:291)
2024.11.21 16:27:23 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:282)
2024.11.21 16:27:23 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.11.21 16:27:23 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:64)
2024.11.21 16:27:23 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.11.21 16:27:23 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
2024.11.21 16:27:23 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.11.21 16:27:23 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
2024.11.21 16:27:23 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
2024.11.21 16:27:23 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:834)
2024.11.21 16:27:23 INFO  [error] (update) found version conflict(s) in library dependencies; some are suspected to be binary incompatible:
2024.11.21 16:27:23 INFO  [error] 
2024.11.21 16:27:23 INFO  [error] 	* org.scala-lang.modules:scala-xml_2.12:2.2.0 (early-semver) is selected over {1.2.0, 1.1.1, 1.3.0, 1.0.6}
2024.11.21 16:27:23 INFO  [error] 	    +- org.scoverage:scalac-scoverage-reporter_2.12:2.0.11 (depends on 2.2.0)
2024.11.21 16:27:23 INFO  [error] 	    +- org.scala-lang:scala-compiler:2.12.16              (depends on 1.0.6)
2024.11.21 16:27:23 INFO  [error] 	    +- org.foundweekends.giter8:giter8-lib_2.12:0.13.1    (depends on 1.3.0)
2024.11.21 16:27:23 INFO  [error] 	    +- com.typesafe.sbt:sbt-native-packager:1.5.2 (scalaVersion=2.12, sbtVersion=1.0) (depends on 1.1.1)
2024.11.21 16:27:23 INFO  [error] 	    +- com.typesafe.play:twirl-api_2.12:1.5.1             (depends on 1.2.0)
2024.11.21 16:27:23 INFO  [error] 
2024.11.21 16:27:23 INFO  [error] 
2024.11.21 16:27:23 INFO  [error] this can be overridden using libraryDependencySchemes or evictionErrorLevel
2024.11.21 16:27:23 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.11.21 16:27:24 INFO  time: ran 'sbt bloopInstall' in 29s
2024.11.21 16:27:24 ERROR sbt command failed: C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals645371007541116564\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.11.21 16:27:24 INFO  Disconnecting from Bloop session...
2024.11.21 16:27:24 INFO  Shut down connection with build server.
2024.11.21 16:27:24 INFO  Shut down connection with build server.
2024.11.21 16:27:24 INFO  Shut down connection with build server.
2024.11.21 16:27:24 INFO  Attempting to connect to the build server...
2024.11.21 16:27:24 INFO  Found a Bloop server running
2024.11.21 16:27:24 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 16:27:24 INFO  Attempting to connect to the build server...
2024.11.21 16:27:24 INFO  Found a Bloop server running
2024.11.21 16:27:24 INFO  Attempting to connect to the build server...
2024.11.21 16:27:24 INFO  Found a Bloop server running
2024.11.21 16:27:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 16:27:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 16:27:26 INFO  time: Connected to build server in 2s
2024.11.21 16:27:26 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 16:27:26 INFO  time: Imported build in 0.13s
2024.11.21 16:27:26 INFO  running doctor check
2024.11.21 16:27:26 INFO  java targets: root-test, root, backend-build-build
2024.11.21 16:27:30 INFO  time: indexed workspace in 4.76s
2024.11.21 16:27:30 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 16:27:30 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc
2024.11.21 16:27:31 INFO  compiling root (8 scala sources)
2024.11.21 16:27:31 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 16:27:31 INFO  time: compiled root in 0.98s
2024.11.21 16:27:32 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:21:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:21:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:21:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:21:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:21:09 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:14 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:14 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:14 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:14 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:22:15 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:22:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:23:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:07 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:07 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:07 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:07 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:07 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:08 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:24:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:24:10 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals339698030825625801\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 17:24:15 INFO  sbt thinks that server is already booting because of this exception:
2024.11.21 17:24:15 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-7655597824915523364_lock, error 5
2024.11.21 17:24:15 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:356)
2024.11.21 17:24:15 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:295)
2024.11.21 17:24:15 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:150)
2024.11.21 17:24:15 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:77)
2024.11.21 17:24:15 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:77)
2024.11.21 17:24:15 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:85)
2024.11.21 17:24:15 ERROR 	at sbt.xMain$.run(Main.scala:121)
2024.11.21 17:24:15 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.11.21 17:24:15 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2024.11.21 17:24:15 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.11.21 17:24:15 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
2024.11.21 17:24:15 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:57)
2024.11.21 17:24:15 ERROR 	at sbt.xMain.run(Main.scala:46)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.11.21 17:24:15 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.11.21 17:24:15 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-7655597824915523364_lock, error 5
2024.11.21 17:24:15 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.11.21 17:24:15 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.11.21 17:24:15 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:350)
2024.11.21 17:24:15 ERROR 	... 23 more
2024.11.21 17:24:15 INFO  time: ran 'sbt bloopInstall' in 5.44s
2024.11.21 17:24:15 ERROR sbt command failed: C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals339698030825625801\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.11.21 17:24:15 INFO  Disconnecting from Bloop session...
2024.11.21 17:24:15 INFO  Shut down connection with build server.
2024.11.21 17:24:15 INFO  Shut down connection with build server.
2024.11.21 17:24:15 INFO  Shut down connection with build server.
2024.11.21 17:24:15 INFO  Attempting to connect to the build server...
2024.11.21 17:24:15 INFO  Found a Bloop server running
2024.11.21 17:24:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 17:24:16 INFO  Attempting to connect to the build server...
2024.11.21 17:24:16 INFO  Found a Bloop server running
2024.11.21 17:24:16 INFO  Attempting to connect to the build server...
2024.11.21 17:24:16 INFO  Found a Bloop server running
2024.11.21 17:24:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 17:24:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 17:24:18 INFO  time: Connected to build server in 2.92s
2024.11.21 17:24:18 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 17:24:18 INFO  time: Imported build in 0.23s
2024.11.21 17:24:18 INFO  running doctor check
2024.11.21 17:24:18 INFO  java targets: root-test, root, backend-build-build
2024.11.21 17:25:02 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:02 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:02 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:25:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4430
2024.11.21 17:25:02 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:25:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4433
2024.11.21 17:25:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:08 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:20 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:22 INFO  time: indexed workspace in 1m3s
2024.11.21 17:25:22 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc
2024.11.21 17:25:22 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:25:22 INFO  compiling root (8 scala sources)
2024.11.21 17:25:24 INFO  time: compiled root in 2.17s
2024.11.21 17:25:24 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:25:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://235bbdb4-4ae2-46e0-a3a5-8f6425104a54/response_47/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A31%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 17:25:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:56 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:56 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:56 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:57 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:57 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:57 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:57 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:57 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:25:57 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:25:57 INFO  skipping build import with status 'Dismissed'
2024.11.21 17:26:42 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:42 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:26:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4493
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:26:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4494
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:47 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:47 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:47 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:48 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:48 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:48 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:50 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt:18: error: [dialect scala213] ) expected but string constant found
    dependencyOverrides += "com.google.inject" % "guice" % "5.1.0"
                           ^
2024.11.21 17:26:50 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:50 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:26:50 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:50 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:50 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:52 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:52 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:52 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:52 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:52 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:55 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:55 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:55 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:26:55 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:55 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:26:57 INFO  skipping build import with status 'Dismissed'
2024.11.21 17:27:00 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:00 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:00 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:27:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4570
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:17 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:16 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:17 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:17 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:17 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:19 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:27:19 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:19 INFO  skipping build import with status 'Dismissed'
2024.11.21 17:27:32 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:32 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:32 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:32 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:32 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:33 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:33 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:33 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:33 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:34 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:34 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:35 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:52 INFO  compiling root (8 scala sources)
2024.11.21 17:27:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:54 INFO  time: compiled root in 2.08s
2024.11.21 17:27:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:27:54 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
Nov. 21, 2024 5:28:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://235bbdb4-4ae2-46e0-a3a5-8f6425104a54/response_48/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cbuild.sbt%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fbuild.sbt%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A24%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.21 17:28:36 INFO  skipping build import with status 'Dismissed'
2024.11.21 17:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:39 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:46 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:28:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:46 INFO  skipping build import with status 'Dismissed'
2024.11.21 17:28:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:28:56 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:46 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:48 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:30:48 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:30:57 INFO  skipping build import with status 'Dismissed'
2024.11.21 17:31:02 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:31:02 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:31:12 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:41 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:44 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:33:45 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:34:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:34:01 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:34:03 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:34:03 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:34:03 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:35:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:35:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:35:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:35:53 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:13 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:15 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:18 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:19 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:19 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:20 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:19 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:20 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:19 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:20 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:20 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt
2024.11.21 17:36:20 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:19 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 17:36:23 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals5108064049975364584\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 17:36:30 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.11.21 17:36:30 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.11.21 17:36:32 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.11.21 17:36:34 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.11.21 17:36:34 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.11.21 17:36:41 INFO  [success] Generated .bloop\backend-build-build.json
2024.11.21 17:36:41 INFO  [success] Total time: 8 s, completed 21.11.2024, 17:36:42
2024.11.21 17:36:41 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.11.21 17:36:42 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.11.21 17:36:47 INFO  [success] Generated .bloop\backend-build.json
2024.11.21 17:36:47 INFO  [success] Total time: 5 s, completed 21.11.2024, 17:36:48
2024.11.21 17:36:55 INFO  [info] loading settings for project root from build.sbt ...
2024.11.21 17:36:55 INFO  [info]   __              __
2024.11.21 17:36:55 INFO  [info]   \ \     ____   / /____ _ __  __
2024.11.21 17:36:55 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.11.21 17:36:55 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.11.21 17:36:55 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.11.21 17:36:55 INFO  [info]       /_/               /____/
2024.11.21 17:36:55 INFO  [info] 
2024.11.21 17:36:55 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.11.21 17:36:55 INFO  [info] 
2024.11.21 17:36:55 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.11.21 17:36:55 INFO  [info] https://www.playframework.com/sponsors
2024.11.21 17:36:55 INFO  [info] 
2024.11.21 17:37:06 INFO  [success] Generated .bloop\root.json
2024.11.21 17:37:06 INFO  [success] Generated .bloop\root-test.json
2024.11.21 17:37:06 INFO  [success] Total time: 9 s, completed 21.11.2024, 17:37:07
2024.11.21 17:37:07 INFO  time: ran 'sbt bloopInstall' in 44s
2024.11.21 17:37:07 INFO  Disconnecting from Bloop session...
2024.11.21 17:37:07 INFO  Shut down connection with build server.
2024.11.21 17:37:07 INFO  Shut down connection with build server.
2024.11.21 17:37:07 INFO  Shut down connection with build server.
2024.11.21 17:37:07 INFO  Attempting to connect to the build server...
2024.11.21 17:37:07 INFO  Found a Bloop server running
2024.11.21 17:37:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 17:37:08 INFO  Attempting to connect to the build server...
2024.11.21 17:37:08 INFO  Found a Bloop server running
2024.11.21 17:37:08 INFO  Attempting to connect to the build server...
2024.11.21 17:37:08 INFO  Found a Bloop server running
2024.11.21 17:37:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 17:37:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 17:37:09 INFO  time: Connected to build server in 2.91s
2024.11.21 17:37:09 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 17:37:10 INFO  time: Imported build in 0.11s
2024.11.21 17:37:10 INFO  running doctor check
2024.11.21 17:37:10 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.21 17:38:33 INFO  time: indexed workspace in 1m23s
2024.11.21 17:39:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 2m 1.586s)
2024.11.21 17:39:09 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:39:09 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:39:19 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:39:19 WARN  javac exited with exit code 1
2024.11.21 17:39:19 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:39:19 WARN  javac exited with exit code 1
2024.11.21 17:39:19 INFO  time: compiled root in 9.74s
2024.11.21 17:39:21 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 5:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4835
2024.11.21 17:39:31 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:39:31 WARN  javac exited with exit code 1
2024.11.21 17:39:31 INFO  time: compiled root in 9.28s
2024.11.21 17:39:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:39:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:39:50 WARN  javac exited with exit code 1
2024.11.21 17:39:50 INFO  time: compiled root in 8.67s
2024.11.21 17:41:08 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:41:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:41:17 WARN  javac exited with exit code 1
2024.11.21 17:41:17 INFO  time: compiled root in 8.38s
2024.11.21 17:42:52 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:43:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:43:00 WARN  javac exited with exit code 1
2024.11.21 17:43:00 INFO  time: compiled root in 7.55s
2024.11.21 17:46:21 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:46:29 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:46:29 WARN  javac exited with exit code 1
2024.11.21 17:46:29 INFO  time: compiled root in 8.57s
2024.11.21 17:47:49 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:47:57 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:47:57 WARN  javac exited with exit code 1
2024.11.21 17:47:57 INFO  time: compiled root in 8.27s
Nov. 21, 2024 5:48:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4999
Nov. 21, 2024 5:48:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5006
Nov. 21, 2024 5:48:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5009
Nov. 21, 2024 5:48:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5011
Nov. 21, 2024 5:48:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5012
Nov. 21, 2024 5:48:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5015
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5022
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5024
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5026
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5027
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5029
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5030
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5032
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5033
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5034
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5041
Nov. 21, 2024 5:48:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5045
2024.11.21 17:48:16 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\test\controllers\models\repositories\CandlesRepositorySpec.scala:100: error: [dialect scala213] } expected but end of file found

^
2024.11.21 17:48:16 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:48:25 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:48:25 WARN  javac exited with exit code 1
2024.11.21 17:48:25 INFO  time: compiled root in 8.83s
2024.11.21 17:48:25 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:48:41 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:48:41 WARN  javac exited with exit code 1
2024.11.21 17:48:41 INFO  time: compiled root in 15s
Nov. 21, 2024 5:49:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5110
2024.11.21 17:49:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:49:59 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:49:59 WARN  javac exited with exit code 1
2024.11.21 17:49:59 INFO  time: compiled root in 11s
2024.11.21 17:50:03 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 5:50:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5161
2024.11.21 17:50:14 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:50:14 WARN  javac exited with exit code 1
2024.11.21 17:50:14 INFO  time: compiled root in 11s
2024.11.21 17:50:49 WARN  Could not find 'Instant' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 17:50:49 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:51:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:51:00 WARN  javac exited with exit code 1
2024.11.21 17:51:00 INFO  time: compiled root in 11s
Nov. 21, 2024 5:51:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5195
2024.11.21 17:51:53 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:52:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:52:03 WARN  javac exited with exit code 1
2024.11.21 17:52:03 INFO  time: compiled root in 10s
2024.11.21 17:53:27 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:53:44 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:53:44 WARN  javac exited with exit code 1
2024.11.21 17:53:44 INFO  time: compiled root in 16s
2024.11.21 17:54:18 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:54:30 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:54:30 WARN  javac exited with exit code 1
2024.11.21 17:54:30 INFO  time: compiled root in 12s
2024.11.21 17:54:30 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5297
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5302
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5301
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5299
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5300
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5313
Nov. 21, 2024 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5314
2024.11.21 17:54:43 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 17m 35.2s)
2024.11.21 17:54:43 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:54:46 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:54:46 WARN  javac exited with exit code 1
2024.11.21 17:54:46 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:54:46 WARN  javac exited with exit code 1
2024.11.21 17:54:46 INFO  time: compiled root in 3.09s
2024.11.21 17:54:48 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:55:08 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:55:08 WARN  javac exited with exit code 1
2024.11.21 17:55:08 INFO  time: compiled root in 20s
2024.11.21 17:59:10 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:59:18 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:59:18 WARN  javac exited with exit code 1
2024.11.21 17:59:18 INFO  time: compiled root in 8.52s
2024.11.21 17:59:18 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:59:29 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:59:29 WARN  javac exited with exit code 1
2024.11.21 17:59:29 INFO  time: compiled root in 10s
2024.11.21 17:59:29 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 17:59:41 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 17:59:41 WARN  javac exited with exit code 1
2024.11.21 17:59:41 INFO  time: compiled root in 11s
2024.11.21 18:00:02 INFO  time: code lens generation in 1s
2024.11.21 18:00:21 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals7915846268512461639\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 18:00:27 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.11.21 18:00:27 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.11.21 18:00:30 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.11.21 18:00:31 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.11.21 18:00:31 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.11.21 18:00:38 INFO  [success] Generated .bloop\backend-build-build.json
2024.11.21 18:00:38 INFO  [success] Total time: 6 s, completed 21.11.2024, 18:00:38
2024.11.21 18:00:38 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.11.21 18:00:39 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.11.21 18:00:45 INFO  [success] Generated .bloop\backend-build.json
2024.11.21 18:00:45 INFO  [success] Total time: 7 s, completed 21.11.2024, 18:00:45
2024.11.21 18:00:57 INFO  [info] loading settings for project root from build.sbt ...
2024.11.21 18:00:57 INFO  [info]   __              __
2024.11.21 18:00:57 INFO  [info]   \ \     ____   / /____ _ __  __
2024.11.21 18:00:57 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.11.21 18:00:57 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.11.21 18:00:57 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.11.21 18:00:57 INFO  [info]       /_/               /____/
2024.11.21 18:00:57 INFO  [info] 
2024.11.21 18:00:57 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.11.21 18:00:57 INFO  [info] 
2024.11.21 18:00:57 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.11.21 18:00:57 INFO  [info] https://www.playframework.com/sponsors
2024.11.21 18:00:57 INFO  [info] 
2024.11.21 18:01:11 INFO  [success] Generated .bloop\root.json
2024.11.21 18:01:11 INFO  [success] Generated .bloop\root-test.json
2024.11.21 18:01:11 INFO  [success] Total time: 10 s, completed 21.11.2024, 18:01:11
2024.11.21 18:01:12 INFO  time: ran 'sbt bloopInstall' in 50s
2024.11.21 18:01:12 INFO  Disconnecting from Bloop session...
2024.11.21 18:01:12 INFO  Shut down connection with build server.
2024.11.21 18:01:12 INFO  Shut down connection with build server.
2024.11.21 18:01:12 INFO  Shut down connection with build server.
2024.11.21 18:01:12 INFO  Attempting to connect to the build server...
2024.11.21 18:01:12 INFO  Found a Bloop server running
2024.11.21 18:01:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:01:13 INFO  Attempting to connect to the build server...
2024.11.21 18:01:13 INFO  Found a Bloop server running
2024.11.21 18:01:13 INFO  Attempting to connect to the build server...
2024.11.21 18:01:13 INFO  Found a Bloop server running
2024.11.21 18:01:15 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:01:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:01:16 INFO  time: Connected to build server in 4.01s
2024.11.21 18:01:16 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 18:01:16 INFO  time: Imported build in 0.33s
2024.11.21 18:01:16 INFO  running doctor check
2024.11.21 18:01:16 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.21 18:01:38 INFO  time: indexed workspace in 21s
2024.11.21 18:01:38 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:01:52 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:01:52 WARN  javac exited with exit code 1
2024.11.21 18:01:52 INFO  time: compiled root in 14s
2024.11.21 18:02:43 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:02:43 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:02:43 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:03:40 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals10183091874077516624\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 18:03:47 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.11.21 18:03:47 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.11.21 18:03:49 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.11.21 18:03:53 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.11.21 18:03:53 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.11.21 18:04:04 INFO  [success] Generated .bloop\backend-build-build.json
2024.11.21 18:04:04 INFO  [success] Total time: 10 s, completed 21.11.2024, 18:04:04
2024.11.21 18:04:04 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.11.21 18:04:04 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.11.21 18:04:10 INFO  [success] Generated .bloop\backend-build.json
2024.11.21 18:04:10 INFO  [success] Total time: 5 s, completed 21.11.2024, 18:04:10
2024.11.21 18:04:17 INFO  [info] loading settings for project root from build.sbt ...
2024.11.21 18:04:17 INFO  [info]   __              __
2024.11.21 18:04:17 INFO  [info]   \ \     ____   / /____ _ __  __
2024.11.21 18:04:17 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.11.21 18:04:17 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.11.21 18:04:17 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.11.21 18:04:17 INFO  [info]       /_/               /____/
2024.11.21 18:04:17 INFO  [info] 
2024.11.21 18:04:17 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.11.21 18:04:17 INFO  [info] 
2024.11.21 18:04:17 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.11.21 18:04:17 INFO  [info] https://www.playframework.com/sponsors
2024.11.21 18:04:17 INFO  [info] 
2024.11.21 18:04:22 INFO  [success] Generated .bloop\root.json
2024.11.21 18:04:22 INFO  [success] Generated .bloop\root-test.json
2024.11.21 18:04:22 INFO  [success] Total time: 4 s, completed 21.11.2024, 18:04:23
2024.11.21 18:04:23 INFO  time: ran 'sbt bloopInstall' in 43s
2024.11.21 18:04:23 INFO  Disconnecting from Bloop session...
2024.11.21 18:04:23 INFO  Shut down connection with build server.
2024.11.21 18:04:23 INFO  Shut down connection with build server.
2024.11.21 18:04:23 INFO  Shut down connection with build server.
2024.11.21 18:04:23 INFO  Attempting to connect to the build server...
2024.11.21 18:04:23 INFO  Found a Bloop server running
2024.11.21 18:04:24 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:04:24 INFO  Attempting to connect to the build server...
2024.11.21 18:04:24 INFO  Found a Bloop server running
2024.11.21 18:04:24 INFO  Attempting to connect to the build server...
2024.11.21 18:04:24 INFO  Found a Bloop server running
2024.11.21 18:04:25 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:04:25 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:04:25 INFO  time: Connected to build server in 2.41s
2024.11.21 18:04:25 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 18:04:25 INFO  time: Imported build in 0.17s
2024.11.21 18:04:25 INFO  running doctor check
2024.11.21 18:04:25 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.21 18:04:34 INFO  time: indexed workspace in 8.75s
2024.11.21 18:04:34 WARN  no build target for: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc
2024.11.21 18:04:34 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:04:36 INFO  time: code lens generation in 1.5s
2024.11.21 18:04:53 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:04:53 WARN  javac exited with exit code 1
2024.11.21 18:04:53 INFO  time: compiled root in 19s
2024.11.21 18:05:23 INFO  compiling root (8 scala sources)
2024.11.21 18:05:26 INFO  time: compiled root in 2.71s
2024.11.21 18:07:07 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:07:14 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:07:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 2m 49.847s)
2024.11.21 18:07:14 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:07:22 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:07:22 WARN  javac exited with exit code 1
2024.11.21 18:07:22 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:07:22 WARN  javac exited with exit code 1
2024.11.21 18:07:22 INFO  time: compiled root in 8.29s
2024.11.21 18:08:27 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:08:27 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:08:27 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:10:01 INFO  compiling root (8 scala sources)
2024.11.21 18:10:03 INFO  time: compiled root in 2.43s
2024.11.21 18:10:42 INFO  compiling root (12 scala sources and 1 java source)
2024.11.21 18:10:45 INFO  time: compiled root in 3.49s
2024.11.21 18:10:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:11:10 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:11:10 WARN  javac exited with exit code 1
2024.11.21 18:11:10 INFO  time: compiled root in 22s
2024.11.21 18:12:52 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:13:02 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:13:02 WARN  javac exited with exit code 1
2024.11.21 18:13:02 INFO  time: compiled root in 10s
2024.11.21 18:13:02 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:13:14 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:13:14 WARN  javac exited with exit code 1
2024.11.21 18:13:14 INFO  time: compiled root in 11s
2024.11.21 18:13:24 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:13:29 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 9m 5.277s)
2024.11.21 18:13:29 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:13:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:13:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:13:36 WARN  javac exited with exit code 1
2024.11.21 18:13:36 WARN  javac exited with exit code 1
2024.11.21 18:13:36 INFO  time: compiled root in 6.42s
2024.11.21 18:14:25 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:14:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:14:43 WARN  javac exited with exit code 1
2024.11.21 18:14:43 INFO  time: compiled root in 17s
2024.11.21 18:17:34 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:17:48 WARN  Could not find 'CandlestickTable' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 18:17:48 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:17:48 WARN  javac exited with exit code 1
2024.11.21 18:17:48 INFO  time: compiled root in 13s
2024.11.21 18:17:50 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:17:59 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:17:59 WARN  javac exited with exit code 1
2024.11.21 18:17:59 INFO  time: compiled root in 8.65s
2024.11.21 18:18:06 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:18:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:18:15 WARN  javac exited with exit code 1
2024.11.21 18:18:15 INFO  time: compiled root in 8.56s
2024.11.21 18:19:01 INFO  skipping build import with status 'Dismissed'
2024.11.21 18:19:04 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:19:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:19:15 WARN  javac exited with exit code 1
2024.11.21 18:19:15 INFO  time: compiled root in 11s
2024.11.21 18:19:15 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:19:27 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:19:27 WARN  javac exited with exit code 1
2024.11.21 18:19:27 INFO  time: compiled root in 11s
2024.11.21 18:19:29 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:19:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:19:38 WARN  javac exited with exit code 1
2024.11.21 18:19:38 INFO  time: compiled root in 8.7s
2024.11.21 18:19:55 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:20:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:20:05 WARN  javac exited with exit code 1
2024.11.21 18:20:05 INFO  time: compiled root in 9.13s
2024.11.21 18:21:14 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:21:31 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:21:31 WARN  javac exited with exit code 1
2024.11.21 18:21:31 INFO  time: compiled root in 16s
2024.11.21 18:21:31 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:21:36 WARN  Could not find 'CandlestickTable' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 18:21:36 WARN  Could not find 'CandlestickTable' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.21 18:21:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:21:43 WARN  javac exited with exit code 1
2024.11.21 18:21:43 INFO  time: compiled root in 12s
2024.11.21 18:22:03 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:22:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:22:15 WARN  javac exited with exit code 1
2024.11.21 18:22:15 INFO  time: compiled root in 12s
2024.11.21 18:22:24 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 6:22:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6097
2024.11.21 18:22:37 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:22:37 WARN  javac exited with exit code 1
2024.11.21 18:22:37 INFO  time: compiled root in 12s
2024.11.21 18:22:37 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:22:49 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:22:49 WARN  javac exited with exit code 1
2024.11.21 18:22:49 INFO  time: compiled root in 12s
Nov. 21, 2024 6:22:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6139
2024.11.21 18:23:00 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:23:08 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:23:08 WARN  javac exited with exit code 1
2024.11.21 18:23:08 INFO  time: compiled root in 8.23s
2024.11.21 18:23:14 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 21, 2024 6:23:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 21, 2024 6:23:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.21 18:23:15 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:23:24 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:23:24 WARN  javac exited with exit code 1
2024.11.21 18:23:24 INFO  time: compiled root in 8.8s
2024.11.21 18:23:25 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:23:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:23:36 WARN  javac exited with exit code 1
2024.11.21 18:23:36 INFO  time: compiled root in 10s
2024.11.21 18:23:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:24:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:24:00 WARN  javac exited with exit code 1
2024.11.21 18:24:00 INFO  time: compiled root in 19s
2024.11.21 18:27:00 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:29:18 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals7519665807449731409\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 18:29:24 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.11.21 18:29:25 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.11.21 18:29:27 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.11.21 18:29:27 INFO  skipping build import with status 'Dismissed'
2024.11.21 18:29:29 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.11.21 18:29:29 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.11.21 18:29:32 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:29:38 INFO  [success] Generated .bloop\backend-build-build.json
2024.11.21 18:29:38 INFO  [success] Total time: 9 s, completed 21.11.2024, 18:29:38
2024.11.21 18:29:38 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.11.21 18:29:39 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.11.21 18:29:45 INFO  [success] Generated .bloop\backend-build.json
2024.11.21 18:29:45 INFO  [success] Total time: 7 s, completed 21.11.2024, 18:29:46
2024.11.21 18:29:47 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 25m 22.629s)
2024.11.21 18:29:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:29:55 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:29:55 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:29:55 WARN  javac exited with exit code 1
2024.11.21 18:29:55 WARN  javac exited with exit code 1
2024.11.21 18:29:55 INFO  time: compiled root in 8.13s
2024.11.21 18:30:01 INFO  [info] loading settings for project root from build.sbt ...
2024.11.21 18:30:01 INFO  [info]   __              __
2024.11.21 18:30:01 INFO  [info]   \ \     ____   / /____ _ __  __
2024.11.21 18:30:01 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.11.21 18:30:01 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.11.21 18:30:01 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.11.21 18:30:01 INFO  [info]       /_/               /____/
2024.11.21 18:30:01 INFO  [info] 
2024.11.21 18:30:01 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.11.21 18:30:01 INFO  [info] 
2024.11.21 18:30:01 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.11.21 18:30:01 INFO  [info] https://www.playframework.com/sponsors
2024.11.21 18:30:01 INFO  [info] 
2024.11.21 18:30:12 INFO  [success] Generated .bloop\root.json
2024.11.21 18:30:12 INFO  [success] Generated .bloop\root-test.json
2024.11.21 18:30:12 INFO  [success] Total time: 8 s, completed 21.11.2024, 18:30:12
2024.11.21 18:30:12 INFO  time: ran 'sbt bloopInstall' in 54s
2024.11.21 18:30:12 INFO  Disconnecting from Bloop session...
2024.11.21 18:30:12 INFO  Shut down connection with build server.
2024.11.21 18:30:12 INFO  Shut down connection with build server.
2024.11.21 18:30:12 INFO  Shut down connection with build server.
2024.11.21 18:30:12 INFO  Attempting to connect to the build server...
2024.11.21 18:30:12 INFO  Found a Bloop server running
2024.11.21 18:30:14 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:30:14 INFO  Attempting to connect to the build server...
2024.11.21 18:30:14 INFO  Found a Bloop server running
2024.11.21 18:30:14 INFO  Attempting to connect to the build server...
2024.11.21 18:30:14 INFO  Found a Bloop server running
2024.11.21 18:30:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:30:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:30:16 INFO  time: Connected to build server in 3.48s
2024.11.21 18:30:16 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 18:30:16 INFO  time: Imported build in 0.28s
2024.11.21 18:30:17 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\ChartController.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.21 18:30:17 INFO  running doctor check
2024.11.21 18:30:17 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.21 18:31:07 INFO  time: indexed workspace in 51s
2024.11.21 18:32:54 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:32:57 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 2m 43.199s)
2024.11.21 18:32:57 INFO  compiling root (14 scala sources and 1 java source)
Nov. 21, 2024 6:32:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6544
2024.11.21 18:33:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:33:04 WARN  javac exited with exit code 1
2024.11.21 18:33:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:33:04 WARN  javac exited with exit code 1
2024.11.21 18:33:04 INFO  time: compiled root in 6.59s
2024.11.21 18:33:04 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:33:12 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:33:12 WARN  javac exited with exit code 1
2024.11.21 18:33:12 INFO  time: compiled root in 7.71s
Nov. 21, 2024 6:34:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6668
2024.11.21 18:34:31 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:34:44 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:34:44 WARN  javac exited with exit code 1
2024.11.21 18:34:44 INFO  time: compiled root in 13s
2024.11.21 18:36:18 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:36:29 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:36:29 WARN  javac exited with exit code 1
2024.11.21 18:36:29 INFO  time: compiled root in 10s
Nov. 21, 2024 6:36:32 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.21 18:37:43 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:37:51 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:37:51 WARN  javac exited with exit code 1
2024.11.21 18:37:51 INFO  time: compiled root in 8.19s
2024.11.21 18:40:18 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:40:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:40:38 WARN  javac exited with exit code 1
2024.11.21 18:40:38 INFO  time: compiled root in 20s
2024.11.21 18:43:42 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:44:10 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:44:10 WARN  javac exited with exit code 1
2024.11.21 18:44:10 INFO  time: compiled root in 28s
2024.11.21 18:48:18 INFO  running 'C:\Program Files\Java\jdk-11\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\sti\AppData\Local\Temp\metals3636380752989842395\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.21 18:48:23 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 11.0.24)
2024.11.21 18:48:24 INFO  [info] loading settings for project backend-build-build-build from metals.sbt ...
2024.11.21 18:48:26 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\project
2024.11.21 18:48:27 INFO  [info] loading settings for project backend-build-build from metals.sbt ...
2024.11.21 18:48:27 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project
2024.11.21 18:48:32 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:48:36 INFO  [success] Generated .bloop\backend-build-build.json
2024.11.21 18:48:36 INFO  [success] Total time: 8 s, completed 21.11.2024, 18:48:36
2024.11.21 18:48:37 INFO  [info] loading settings for project backend-build from metals.sbt,plugins.sbt ...
2024.11.21 18:48:37 INFO  [info] loading project definition from C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project
2024.11.21 18:48:42 INFO  [success] Generated .bloop\backend-build.json
2024.11.21 18:48:42 INFO  [success] Total time: 6 s, completed 21.11.2024, 18:48:43
2024.11.21 18:48:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:48:50 WARN  javac exited with exit code 1
2024.11.21 18:48:50 INFO  time: compiled root in 17s
2024.11.21 18:48:53 INFO  [info] loading settings for project root from build.sbt ...
2024.11.21 18:48:53 INFO  [info]   __              __
2024.11.21 18:48:53 INFO  [info]   \ \     ____   / /____ _ __  __
2024.11.21 18:48:53 INFO  [info]    \ \   / __ \ / // __ `// / / /
2024.11.21 18:48:53 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2024.11.21 18:48:53 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2024.11.21 18:48:53 INFO  [info]       /_/               /____/
2024.11.21 18:48:53 INFO  [info] 
2024.11.21 18:48:53 INFO  [info] Version 2.8.20 running Java 11.0.24
2024.11.21 18:48:53 INFO  [info] 
2024.11.21 18:48:53 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2024.11.21 18:48:53 INFO  [info] https://www.playframework.com/sponsors
2024.11.21 18:48:53 INFO  [info] 
2024.11.21 18:49:07 INFO  [success] Generated .bloop\root.json
2024.11.21 18:49:07 INFO  [success] Generated .bloop\root-test.json
2024.11.21 18:49:07 INFO  [success] Total time: 12 s, completed 21.11.2024, 18:49:08
2024.11.21 18:49:08 INFO  time: ran 'sbt bloopInstall' in 50s
2024.11.21 18:49:08 INFO  Disconnecting from Bloop session...
2024.11.21 18:49:08 INFO  Shut down connection with build server.
2024.11.21 18:49:08 INFO  Shut down connection with build server.
2024.11.21 18:49:08 INFO  Shut down connection with build server.
2024.11.21 18:49:08 INFO  Attempting to connect to the build server...
2024.11.21 18:49:08 INFO  Found a Bloop server running
2024.11.21 18:49:10 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:49:10 INFO  Attempting to connect to the build server...
2024.11.21 18:49:10 INFO  Found a Bloop server running
2024.11.21 18:49:10 INFO  Attempting to connect to the build server...
2024.11.21 18:49:10 INFO  Found a Bloop server running
2024.11.21 18:49:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:49:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.21 18:49:11 INFO  time: Connected to build server in 3.07s
2024.11.21 18:49:11 INFO  Connected to Build server: Bloop v2.0.3
2024.11.21 18:49:11 INFO  time: Imported build in 0.16s
2024.11.21 18:49:11 INFO  running doctor check
2024.11.21 18:49:11 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.21 18:50:40 INFO  time: indexed workspace in 1m28s
2024.11.21 18:50:40 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:50:56 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:50:56 WARN  javac exited with exit code 1
2024.11.21 18:50:56 INFO  time: compiled root in 15s
2024.11.21 18:52:28 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:52:44 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:52:44 WARN  javac exited with exit code 1
2024.11.21 18:52:44 INFO  time: compiled root in 16s
2024.11.21 18:57:41 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:58:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:58:03 WARN  javac exited with exit code 1
2024.11.21 18:58:03 INFO  time: compiled root in 21s
2024.11.21 18:59:08 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 18:59:25 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 18:59:25 WARN  javac exited with exit code 1
2024.11.21 18:59:25 INFO  time: compiled root in 17s
2024.11.21 19:00:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 19:01:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 19:01:00 WARN  javac exited with exit code 1
2024.11.21 19:01:00 INFO  time: compiled root in 12s
2024.11.21 19:07:23 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 19:07:35 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 19:07:35 WARN  javac exited with exit code 1
2024.11.21 19:07:35 INFO  time: compiled root in 12s
2024.11.21 19:07:56 INFO  compiling root (14 scala sources and 1 java source)
2024.11.21 19:08:07 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.21 19:08:07 WARN  javac exited with exit code 1
2024.11.21 19:08:07 INFO  time: compiled root in 10s
Nov. 22, 2024 9:03:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7372
2024.11.22 18:39:11 WARN  Could not find 'Action' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 22, 2024 6:41:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://4bb4fb9b-fbbb-4858-9cad-2ed98ee96b93/response_51/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:42:02 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:42:10 INFO  time: compiled root in 7.29s
Nov. 22, 2024 6:42:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://4bb4fb9b-fbbb-4858-9cad-2ed98ee96b93/response_51/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:42:22 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:42:24 INFO  time: compiled root in 1.25s
2024.11.22 18:42:29 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 6:42:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 6:42:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 18:42:29 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 6:42:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 6:42:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 18:42:34 WARN  Could not find 'Candlestick' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 18:42:34 WARN  Could not find 'CandlesRepository' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 18:42:35 WARN  Could not find 'CandlesRepository' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 22, 2024 6:42:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7724
Nov. 22, 2024 6:42:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7725
2024.11.22 18:42:48 INFO  compiling root (14 scala sources and 1 java source)
Nov. 22, 2024 6:42:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7751
2024.11.22 18:42:50 INFO  time: compiled root in 1.49s
2024.11.22 18:43:59 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:44:02 INFO  time: compiled root in 2.79s
2024.11.22 18:46:56 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:47:00 INFO  time: compiled root in 3.2s
2024.11.22 18:48:24 INFO  compiling root (8 scala sources)
2024.11.22 18:48:26 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/target/scala-2.13/routes/main/router/Routes.scala
2024.11.22 18:48:26 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/target/scala-2.13/routes/main/controllers/ReverseRoutes.scala
2024.11.22 18:48:26 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/target/scala-2.13/routes/main/controllers/javascript/JavaScriptReverseRoutes.scala
2024.11.22 18:48:26 INFO  time: compiled root in 2.12s
2024.11.22 18:49:57 INFO  compiling root (8 scala sources)
2024.11.22 18:49:58 INFO  time: compiled root in 1.33s
2024.11.22 18:50:31 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:50:32 INFO  time: compiled root in 1.33s
2024.11.22 18:51:47 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:51:49 INFO  time: compiled root in 1.47s
2024.11.22 18:51:49 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:51:51 INFO  time: compiled root in 1.66s
2024.11.22 18:51:51 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:51:54 INFO  time: compiled root in 3.1s
Nov. 22, 2024 6:52:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_57/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A82%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:52:57 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:52:59 INFO  time: compiled root in 1.69s
Nov. 22, 2024 6:53:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_57/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A82%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:53:06 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:53:08 INFO  time: compiled root in 2s
Nov. 22, 2024 6:53:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_57/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A82%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:53:24 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 6:53:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 6:53:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 18:53:28 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:53:30 INFO  time: compiled root in 1.95s
Nov. 22, 2024 6:53:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_57/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A82%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 6:53:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_57/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A82%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:53:45 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 6:53:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 6:53:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 18:53:46 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:53:46 INFO  time: compiled root in 0.97s
2024.11.22 18:53:56 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:53:56 INFO  time: compiled root in 0.82s
Nov. 22, 2024 6:54:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_58/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 6:54:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8097
Nov. 22, 2024 6:54:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_58/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A77%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 18:54:36 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:54:38 INFO  time: compiled root in 2.51s
2024.11.22 18:54:43 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:54:44 INFO  time: compiled root in 1.68s
2024.11.22 18:54:44 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:54:45 INFO  time: compiled root in 1.22s
2024.11.22 18:54:45 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:54:47 INFO  time: compiled root in 1.79s
2024.11.22 18:55:01 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:55:02 INFO  time: compiled root in 1.35s
2024.11.22 18:57:15 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:57:24 INFO  time: compiled root in 9.67s
2024.11.22 18:58:40 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:58:40 INFO  time: compiled root in 0.96s
2024.11.22 18:58:40 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:58:42 INFO  time: compiled root in 0.97s
2024.11.22 18:58:42 INFO  compiling root (14 scala sources and 1 java source)
2024.11.22 18:58:42 INFO  time: compiled root in 0.78s
Nov. 22, 2024 6:59:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_62/2#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cconf%5C%5Cevolutions%5C%5Cdefault%5C%5C1.sql%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fconf%2Fevolutions%2Fdefault%2F1.sql%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fconf%2Fevolutions%2Fdefault%2F1.sql%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A3%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A40%2C%22endColumn%22%3A24%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:11:16 INFO  compiling root (8 scala sources)
2024.11.22 19:11:24 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/target/scala-2.13/routes/main/router/Routes.scala
2024.11.22 19:11:24 INFO  time: compiled root in 8.67s
2024.11.22 19:11:24 INFO  compiling root (8 scala sources)
2024.11.22 19:11:25 INFO  time: compiled root in 0.98s
2024.11.22 19:11:31 INFO  compiling root (7 scala sources)
2024.11.22 19:11:33 INFO  time: compiled root in 2.39s
2024.11.22 19:11:36 INFO  compiling root (6 scala sources)
2024.11.22 19:11:39 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/repositories/UserRepository.scala
2024.11.22 19:11:39 INFO  time: compiled root in 2.42s
2024.11.22 19:11:46 INFO  compiling root (5 scala sources)
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 INFO  BSP server: object UserRepository is not a member of package repositories
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 INFO  BSP server: not found: type UserRepository
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 INFO  BSP server: type User is not a member of package models
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 INFO  BSP server: type User is not a member of package models
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 INFO  BSP server: type User is not a member of package models
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 INFO  BSP server: type User is not a member of package models
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:47 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/HomeController.scala
2024.11.22 19:11:47 INFO  time: compiled root in 2.15s
2024.11.22 19:11:47 INFO  compiling root (4 scala sources)
2024.11.22 19:11:53 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/UserController.scala
2024.11.22 19:11:53 INFO  time: compiled root in 6.18s
2024.11.22 19:12:54 INFO  compiling root (1 scala source)
2024.11.22 19:12:54 INFO  time: compiled root in 0.87s
2024.11.22 19:13:15 INFO  compiling root (1 scala source)
2024.11.22 19:13:17 INFO  time: compiled root in 2.04s
2024.11.22 19:13:17 INFO  compiling root (2 scala sources)
2024.11.22 19:13:17 INFO  time: compiled root in 0.44s
2024.11.22 19:13:40 INFO  compiling root (2 scala sources)
2024.11.22 19:13:40 INFO  time: compiled root in 0.21s
2024.11.22 19:13:44 INFO  compiling root (2 scala sources)
2024.11.22 19:13:44 INFO  time: compiled root in 0.2s
2024.11.22 19:13:50 INFO  compiling root (2 scala sources)
2024.11.22 19:13:50 INFO  time: compiled root in 0.35s
2024.11.22 19:14:00 INFO  compiling root (2 scala sources)
2024.11.22 19:14:02 INFO  time: compiled root in 2.46s
2024.11.22 19:14:02 INFO  compiling root (1 scala source)
2024.11.22 19:14:02 INFO  time: compiled root in 0.45s
2024.11.22 19:14:10 INFO  compiling root (2 scala sources)
2024.11.22 19:14:13 INFO  time: compiled root in 2.77s
2024.11.22 19:14:13 INFO  compiling root (1 scala source)
2024.11.22 19:14:13 INFO  time: compiled root in 0.34s
Nov. 22, 2024 7:15:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_65/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A37%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A56%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:15:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_65/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A37%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A56%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:15:30 INFO  compiling root (2 scala sources)
2024.11.22 19:15:32 INFO  time: compiled root in 1.08s
Nov. 22, 2024 7:16:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_65/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A37%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A56%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:16:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8843
2024.11.22 19:16:05 INFO  compiling root (2 scala sources)
2024.11.22 19:16:05 INFO  time: compiled root in 0.94s
Nov. 22, 2024 7:16:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_65/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A37%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A56%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:16:16 INFO  compiling root (2 scala sources)
2024.11.22 19:16:16 INFO  time: compiled root in 0.55s
Nov. 22, 2024 7:16:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8906
Nov. 22, 2024 7:16:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8905
Nov. 22, 2024 7:16:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8907
Nov. 22, 2024 7:16:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8911
Nov. 22, 2024 7:16:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8908
Nov. 22, 2024 7:16:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8912
2024.11.22 19:16:21 INFO  compiling root (2 scala sources)
2024.11.22 19:16:21 INFO  time: compiled root in 0.98s
Nov. 22, 2024 7:17:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_66/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A73%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:17:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8956
2024.11.22 19:17:45 INFO  compiling root (2 scala sources)
2024.11.22 19:17:45 INFO  time: compiled root in 0.92s
Nov. 22, 2024 7:18:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_66/2#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A73%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:18:25 INFO  compiling root (2 scala sources)
2024.11.22 19:18:26 INFO  time: compiled root in 1.01s
Nov. 22, 2024 7:18:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9071
2024.11.22 19:18:36 INFO  compiling root (2 scala sources)
2024.11.22 19:18:36 INFO  time: compiled root in 0.47s
Nov. 22, 2024 7:18:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9100
Nov. 22, 2024 7:18:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9108
Nov. 22, 2024 7:18:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9112
2024.11.22 19:18:47 INFO  compiling root (2 scala sources)
2024.11.22 19:18:47 INFO  time: compiled root in 0.57s
2024.11.22 19:19:18 INFO  compiling root (2 scala sources)
2024.11.22 19:19:18 INFO  time: compiled root in 0.92s
Nov. 22, 2024 7:19:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9184
Nov. 22, 2024 7:19:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9193
Nov. 22, 2024 7:19:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9197
2024.11.22 19:19:41 INFO  compiling root (2 scala sources)
2024.11.22 19:19:41 INFO  time: compiled root in 0.52s
Nov. 22, 2024 7:19:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9245
2024.11.22 19:19:52 INFO  compiling root (2 scala sources)
2024.11.22 19:19:55 INFO  time: compiled root in 2.87s
2024.11.22 19:19:55 INFO  compiling root (2 scala sources)
2024.11.22 19:19:55 INFO  time: compiled root in 0.31s
2024.11.22 19:20:19 INFO  compiling root (5 scala sources)
2024.11.22 19:20:21 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/CandlesController.scala
2024.11.22 19:20:21 INFO  time: compiled root in 1.25s
2024.11.22 19:20:21 INFO  compiling root (5 scala sources)
2024.11.22 19:20:24 INFO  time: compiled root in 2.91s
Nov. 22, 2024 7:20:24 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.11.22 19:20:26 INFO  compiling root (5 scala sources)
2024.11.22 19:20:26 INFO  time: compiled root in 0.67s
2024.11.22 19:20:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 7:20:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 7:20:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 19:20:45 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 7:20:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 7:20:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 19:20:51 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 7:20:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 7:20:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 19:21:01 INFO  compiling root (5 scala sources)
2024.11.22 19:21:01 INFO  time: compiled root in 0.88s
2024.11.22 19:21:31 INFO  compiling root (5 scala sources)
2024.11.22 19:21:32 INFO  time: compiled root in 1.56s
2024.11.22 19:21:32 WARN  Could not find 'Inject' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 19:23:10 INFO  compiling root (5 scala sources)
2024.11.22 19:23:10 INFO  time: compiled root in 0.74s
2024.11.22 19:23:22 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 19:23:22 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 19:23:22 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 19:23:22 WARN  Could not find 'map' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 19:23:45 INFO  compiling root (5 scala sources)
2024.11.22 19:23:45 INFO  time: compiled root in 1s
Exception in thread "pool-50-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.22 19:23:57 INFO  compiling root (5 scala sources)
2024.11.22 19:23:57 INFO  time: compiled root in 0.81s
Exception in thread "pool-50-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Exception in thread "pool-50-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.22 19:25:00 INFO  compiling root (5 scala sources)
2024.11.22 19:25:02 WARN  Invalid text document uri received from build server: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/ChartController.scala
2024.11.22 19:25:02 INFO  time: compiled root in 2.08s
2024.11.22 19:25:02 INFO  compiling root (5 scala sources)
2024.11.22 19:25:08 INFO  time: compiled root in 5.5s
2024.11.22 19:27:49 INFO  compiling root (4 scala sources and 1 java source)
2024.11.22 19:27:58 INFO  compiling root (11 scala sources and 1 java source)
2024.11.22 19:28:03 INFO  time: compiled root in 5.89s
Nov. 22, 2024 7:29:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_73/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Cconf%5C%5Croutes%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fconf%2Froutes%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fconf%2Froutes%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A27%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:29:09 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:29:10 INFO  time: compiled root in 1.29s
2024.11.22 19:29:15 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:29:16 INFO  time: compiled root in 1.18s
Nov. 22, 2024 7:29:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9820
Nov. 22, 2024 7:29:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9821
2024.11.22 19:29:30 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:29:39 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 19:29:39 WARN  javac exited with exit code 1
2024.11.22 19:29:39 INFO  time: compiled root in 9.49s
2024.11.22 19:36:13 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:36:20 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 24h 47m 9.811s)
2024.11.22 19:36:20 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:36:26 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 19:36:26 WARN  javac exited with exit code 1
2024.11.22 19:36:26 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 19:36:26 WARN  javac exited with exit code 1
2024.11.22 19:36:26 INFO  time: compiled root in 6.2s
2024.11.22 19:37:36 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:37:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 19:37:47 WARN  javac exited with exit code 1
2024.11.22 19:37:47 INFO  time: compiled root in 10s
2024.11.22 19:46:28 INFO  compiling root (1 scala source)
2024.11.22 19:46:36 INFO  time: compiled root in 8.34s
2024.11.22 19:48:06 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:48:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 19:48:17 WARN  javac exited with exit code 1
2024.11.22 19:48:17 INFO  time: compiled root in 10s
2024.11.22 19:51:52 INFO  compiling root (1 scala source)
2024.11.22 19:51:52 INFO  time: compiled root in 0.86s
2024.11.22 19:51:52 INFO  compiling root (1 scala source)
2024.11.22 19:51:54 INFO  time: compiled root in 0.59s
2024.11.22 19:52:39 INFO  compiling root (1 scala source)
2024.11.22 19:52:39 INFO  time: compiled root in 0.81s
2024.11.22 19:52:51 INFO  compiling root (10 scala sources and 1 java source)
2024.11.22 19:52:54 INFO  time: compiled root in 3.29s
2024.11.22 19:52:54 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:53:00 INFO  time: compiled root in 5.23s
Nov. 22, 2024 7:53:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9917
Nov. 22, 2024 7:54:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_79/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A34%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:54:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_79/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A34%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:54:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_79/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A34%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:54:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_79/2#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A34%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 7:54:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://dbc7de6a-689e-4a2c-b8f3-29a1796843cf/response_79/3#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A34%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:55:23 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:55:25 INFO  time: compiled root in 1.35s
2024.11.22 19:55:40 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:55:48 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 19:55:48 WARN  javac exited with exit code 1
2024.11.22 19:55:48 INFO  time: compiled root in 7.34s
2024.11.22 19:56:37 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:56:39 INFO  time: compiled root in 2.65s
Nov. 22, 2024 7:56:48 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.22 19:57:01 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:57:04 INFO  time: compiled root in 2.67s
2024.11.22 19:57:05 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:57:07 INFO  time: compiled root in 2.4s
2024.11.22 19:57:13 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:57:15 INFO  time: compiled root in 2.6s
2024.11.22 19:57:21 INFO  file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/controllers/HomeController.scala:20:8: stale bloop error: not enough arguments for method apply: (message: String): play.twirl.api.HtmlFormat.Appendable in object index.
Unspecified value parameter message.
    Ok(views.html.index())
       ^^^^^^^^^^^^^^^^^^
2024.11.22 19:57:38 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:57:38 INFO  time: compiled root in 0.51s
2024.11.22 19:57:44 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:57:45 INFO  time: compiled root in 1.28s
2024.11.22 19:57:51 WARN  Could not find 'index' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 19:58:00 WARN  Could not find 'Action' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
Nov. 22, 2024 7:58:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10254
Nov. 22, 2024 7:58:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10256
Nov. 22, 2024 7:58:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_82/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A23%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 19:58:32 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:58:33 INFO  time: compiled root in 1.07s
2024.11.22 19:59:11 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:59:14 INFO  time: compiled root in 2.25s
2024.11.22 19:59:14 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 19:59:16 INFO  time: compiled root in 2.51s
Nov. 22, 2024 7:59:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_83/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A13%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A23%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 8:00:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10335
2024.11.22 20:00:38 INFO  compiling root (12 scala sources and 1 java source)
Nov. 22, 2024 8:00:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_85/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CHomeController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22path%22%3A%22%2FC%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FHomeController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A23%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 20:01:05 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:01:05 WARN  javac exited with exit code 1
2024.11.22 20:01:05 INFO  time: compiled root in 26s
2024.11.22 20:01:05 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:01:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:01:17 WARN  javac exited with exit code 1
2024.11.22 20:01:17 INFO  time: compiled root in 12s
2024.11.22 20:03:19 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:03:29 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:03:29 WARN  javac exited with exit code 1
2024.11.22 20:03:29 INFO  time: compiled root in 9.71s
2024.11.22 20:06:23 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:06:37 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:06:37 WARN  javac exited with exit code 1
2024.11.22 20:06:37 INFO  time: compiled root in 14s
2024.11.22 20:07:52 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:08:02 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:08:02 WARN  javac exited with exit code 1
2024.11.22 20:08:02 INFO  time: compiled root in 10s
2024.11.22 20:09:26 INFO  compiling root (1 scala source)
2024.11.22 20:09:26 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 25h 20m 16.954s)
2024.11.22 20:09:26 INFO  compiling root (1 scala source)
2024.11.22 20:09:27 INFO  time: compiled root in 0.47s
2024.11.22 20:10:34 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:10:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:10:50 WARN  javac exited with exit code 1
2024.11.22 20:10:50 INFO  time: compiled root in 15s
2024.11.22 20:15:01 INFO  compiling root (1 scala source)
2024.11.22 20:15:09 INFO  time: compiled root in 8.36s
2024.11.22 20:15:09 INFO  compiling root (1 scala source)
2024.11.22 20:15:09 INFO  time: compiled root in 0.52s
2024.11.22 20:16:17 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:16:27 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:16:27 WARN  javac exited with exit code 1
2024.11.22 20:16:27 INFO  time: compiled root in 9.47s
2024.11.22 20:18:51 INFO  compiling root (1 scala source)
2024.11.22 20:18:51 INFO  time: compiled root in 0.76s
2024.11.22 20:20:28 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:20:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:20:38 WARN  javac exited with exit code 1
2024.11.22 20:20:38 INFO  time: compiled root in 10s
2024.11.22 20:22:59 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:23:09 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:23:09 WARN  javac exited with exit code 1
2024.11.22 20:23:09 INFO  time: compiled root in 9.9s
2024.11.22 20:23:09 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:23:19 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:23:19 WARN  javac exited with exit code 1
2024.11.22 20:23:19 INFO  time: compiled root in 10s
2024.11.22 20:24:47 INFO  compiling root (1 scala source)
2024.11.22 20:24:48 INFO  time: compiled root in 1.42s
2024.11.22 20:27:15 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:27:28 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:27:28 WARN  javac exited with exit code 1
2024.11.22 20:27:28 INFO  time: compiled root in 13s
2024.11.22 20:28:56 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:29:02 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:29:02 WARN  javac exited with exit code 1
2024.11.22 20:29:02 INFO  time: compiled root in 6.2s
2024.11.22 20:29:02 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:29:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:29:17 WARN  javac exited with exit code 1
2024.11.22 20:29:17 INFO  time: compiled root in 15s
2024.11.22 20:29:48 INFO  compiling root (1 scala source)
2024.11.22 20:29:48 INFO  time: compiled root in 0.74s
2024.11.22 20:29:48 INFO  compiling root (1 scala source)
2024.11.22 20:29:49 INFO  time: compiled root in 0.35s
2024.11.22 20:33:37 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:33:47 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:33:47 WARN  javac exited with exit code 1
2024.11.22 20:33:47 INFO  time: compiled root in 10s
2024.11.22 20:38:15 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:38:24 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:38:24 WARN  javac exited with exit code 1
2024.11.22 20:38:24 INFO  time: compiled root in 9.86s
2024.11.22 20:40:01 INFO  compiling root (1 scala source)
2024.11.22 20:40:01 INFO  time: compiled root in 0.62s
2024.11.22 20:41:51 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:42:08 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:42:08 WARN  javac exited with exit code 1
2024.11.22 20:42:08 INFO  time: compiled root in 17s
2024.11.22 20:48:57 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:49:01 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 25h 59m 51.239s)
2024.11.22 20:49:01 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 20:49:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:49:04 WARN  javac exited with exit code 1
2024.11.22 20:49:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 20:49:04 WARN  javac exited with exit code 1
2024.11.22 20:49:04 INFO  time: compiled root in 3.12s
Nov. 22, 2024 9:05:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jdt://contents/java.base/java.util.concurrent/ForkJoinPool.class?%3Djdt.ls-java-project%2FC%3A%5C%2FProgram%20Files%5C%2FJava%5C%2Fjdk-11%5C%2Flib%5C%2Fjrt-fs.jar%60java.base%3D%2Fjavadoc_location%3D%2Fhttps%3A%5C%2F%5C%2Fdocs.oracle.com%5C%2Fen%5C%2Fjava%5C%2Fjavase%5C%2F11%5C%2Fdocs%5C%2Fapi%5C%2F%3D%2F%3Cjava.util.concurrent%28ForkJoinPool.class"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "jdt" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:46:41 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:46:50 INFO  time: compiled root in 8.99s
Nov. 22, 2024 9:50:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_87/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A84%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:50:38 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 9:50:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:50:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:50:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_87/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A84%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 9:51:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_87/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A84%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:51:10 ERROR scalafmt: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala:37: error: [dialect scala213] end of file expected but } found
}
^
2024.11.22 21:51:10 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:51:10 INFO  time: compiled root in 0.27s
2024.11.22 21:51:14 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:51:15 INFO  time: compiled root in 1.18s
Nov. 22, 2024 9:51:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_87/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CCandlestick.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FCandlestick.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A84%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:51:26 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 9:51:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:51:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 21:51:30 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:51:31 INFO  time: compiled root in 1.33s
Nov. 22, 2024 9:51:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_88/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A61%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 9:51:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_88/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A61%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:51:56 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 9:51:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:51:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 21:51:56 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 9:51:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:51:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 21:51:58 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:51:58 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:51:59 INFO  time: compiled root in 1.34s
2024.11.22 21:51:59 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 9:52:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_88/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A61%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:52:07 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:07 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:07 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:07 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:08 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:10 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:10 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:10 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:11 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:52:11 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:12 INFO  time: compiled root in 1.64s
2024.11.22 21:52:13 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 21:52:23 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 9:52:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:52:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.22 21:52:23 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Nov. 22, 2024 9:52:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.INSTANT_SECONDS;\nimport static java.time.temporal.ChronoField.NANO_OF_DAY;\nimport static java.time.temporal.ChronoField.OFFSET_SECONDS;\nimport static java.time.temporal.ChronoUnit.FOREVER;\nimport static java.time.temporal.ChronoUnit.NANOS;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Comparator;\nimport java.util.Objects;\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00}.\n * \u003cp\u003e\n * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * as well as the offset from UTC/Greenwich. For example, the value\n * \"2nd October 2007 at 13:45:30.123456789 +02:00\" can be stored in an {@code OffsetDateTime}.\n * \u003cp\u003e\n * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant\n * on the time-line to nanosecond precision.\n * {@code Instant} is the simplest, simply representing the instant.\n * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows\n * the local date-time to be obtained.\n * {@code ZonedDateTime} adds full time-zone rules.\n * \u003cp\u003e\n * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data\n * in simpler applications. This class may be used when modeling date-time concepts in\n * more detail, or when communicating to a database or in a network protocol.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code OffsetDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class OffsetDateTime\n        implements Temporal, TemporalAdjuster, Comparable\u003cOffsetDateTime\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code OffsetDateTime}, \u0027-999999999-01-01T00:00:00+18:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date\n     * in the maximum offset (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final OffsetDateTime MIN \u003d LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    /**\n     * The maximum supported {@code OffsetDateTime}, \u0027+999999999-12-31T23:59:59.999999999-18:00\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date\n     * in the minimum offset (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final OffsetDateTime MAX \u003d LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    /**\n     * Gets a comparator that compares two {@code OffsetDateTime} instances\n     * based solely on the instant.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying instant.\n     *\n     * @return a comparator that compares in time-line order\n     *\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     */\n    public static Comparator\u003cOffsetDateTime\u003e timeLineOrder() {\n        return OffsetDateTime::compareInstant;\n    }\n\n    /**\n     * Compares this {@code OffsetDateTime} to another date-time.\n     * The comparison is based on the instant.\n     *\n     * @param datetime1  the first date-time to compare, not null\n     * @param datetime2  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {\n        if (datetime1.getOffset().equals(datetime2.getOffset())) {\n            return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());\n        }\n        int cmp \u003d Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();\n        }\n        return cmp;\n    }\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2287754244819255394L;\n\n    /**\n     * The local date-time.\n     */\n    private final LocalDateTime dateTime;\n    /**\n     * The offset from UTC/Greenwich.\n     */\n    private final ZoneOffset offset;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static OffsetDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * The offset will be calculated from the time-zone in the clock.\n     * \u003cp\u003e\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static OffsetDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone().getRules().getOffset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date, time and offset.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the specified local date-time and offset.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     */\n    public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and offset.\n     * \u003cp\u003e\n     * This creates an offset date-time with the seven specified fields.\n     * \u003cp\u003e\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    public static OffsetDateTime of(\n            int year, int month, int dayOfMonth,\n            int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {\n        LocalDateTime dt \u003d LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates an offset date-time with the same instant as that specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        LocalDateTime ldt \u003d LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains an offset date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * The conversion will first obtain a {@code ZoneOffset} from the temporal object.\n     * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.\n     * The result will be the combination of {@code ZoneOffset} with either\n     * with {@code LocalDateTime} or {@code Instant}.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the offset date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}\n     */\n    public static OffsetDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof OffsetDateTime) {\n            return (OffsetDateTime) temporal;\n        }\n        try {\n            ZoneOffset offset \u003d ZoneOffset.from(temporal);\n            LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n            LocalTime time \u003d temporal.query(TemporalQueries.localTime());\n            if (date !\u003d null \u0026\u0026 time !\u003d null) {\n                return OffsetDateTime.of(date, time, offset);\n            } else {\n                Instant instant \u003d Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string\n     * such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30+01:00\", not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed offset date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param dateTime  the local date-time, not null\n     * @param offset  the zone offset, not null\n     */\n    private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {\n        this.dateTime \u003d Objects.requireNonNull(dateTime, \"dateTime\");\n        this.offset \u003d Objects.requireNonNull(offset, \"offset\");\n    }\n\n    /**\n     * Returns a new date-time based on this one, returning {@code this} where possible.\n     *\n     * @param dateTime  the date-time to create with, not null\n     * @param offset  the zone offset to create with, not null\n     */\n    private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {\n        if (this.dateTime \u003d\u003d dateTime \u0026\u0026 this.offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003cli\u003e{@code INSTANT_SECONDS}\n     * \u003cli\u003e{@code OFFSET_SECONDS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        return field instanceof ChronoField || (field !\u003d null \u0026\u0026 field.isSupportedBy(this));\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit !\u003d FOREVER;\n        }\n        return unit !\u003d null \u0026\u0026 unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d INSTANT_SECONDS || field \u003d\u003d OFFSET_SECONDS) {\n                return field.range();\n            }\n            return dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS:\n                    throw new UnsupportedTemporalTypeException(\"Invalid field \u0027InstantSeconds\u0027 for get() method, use getLong() instead\");\n                case OFFSET_SECONDS:\n                    return getOffset().getTotalSeconds();\n            }\n            return dateTime.get(field);\n        }\n        return Temporal.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            switch ((ChronoField) field) {\n                case INSTANT_SECONDS: return toEpochSecond();\n                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n            }\n            return dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as \u0027+01:00\u0027.\n     * \u003cp\u003e\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return the zone offset, not null\n     */\n    public ZoneOffset getOffset() {\n        return offset;\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result has the same local date-time.\n     * \u003cp\u003e\n     * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.\n     * No calculation is needed or performed.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.\n     * \u003cp\u003e\n     * To take into account the difference between the offsets, and adjust the time fields,\n     * use {@link #withOffsetSameInstant}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     */\n    public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {\n        return with(dateTime, offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring\n     * that the result is at the same instant.\n     * \u003cp\u003e\n     * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}\n     * adjusted by the difference between the two offsets.\n     * This will result in the old and new objects representing the same instant.\n     * This is useful for finding the local time in a different offset.\n     * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is\n     * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.\n     * \u003cp\u003e\n     * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param offset  the zone offset to change to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {\n        if (offset.equals(this.offset)) {\n            return this;\n        }\n        int difference \u003d offset.getTotalSeconds() - this.offset.getTotalSeconds();\n        LocalDateTime adjusted \u003d dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return the local date-time part of this date-time, not null\n     */\n    public LocalDateTime toLocalDateTime() {\n        return dateTime;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    public LocalDate toLocalDate() {\n        return dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return dateTime.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return dateTime.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return dateTime.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return dateTime.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return dateTime.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return dateTime.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    public LocalTime toLocalTime() {\n        return dateTime.toLocalTime();\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return dateTime.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return dateTime.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return dateTime.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return dateTime.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d offsetDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement\n     * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d offsetDateTime.with(date);\n     *  result \u003d offsetDateTime.with(time);\n     *  result \u003d offsetDateTime.with(offset);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return with(dateTime.with(adjuster), offset);\n        } else if (adjuster instanceof Instant) {\n            return ofInstant((Instant) adjuster, offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return with(dateTime, (ZoneOffset) adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return (OffsetDateTime) adjuster;\n        }\n        return (OffsetDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \u003cp\u003e\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The offset and nano-of-second are unchanged.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.\n     * The local date-time is unaltered. If the new offset value is outside the valid range\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            switch (f) {\n                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n                case OFFSET_SECONDS: {\n                    return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return with(dateTime.with(field, newValue), offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public OffsetDateTime withYear(int year) {\n        return with(dateTime.withYear(year), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public OffsetDateTime withMonth(int month) {\n        return with(dateTime.withMonth(month), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public OffsetDateTime withDayOfMonth(int dayOfMonth) {\n        return with(dateTime.withDayOfMonth(dayOfMonth), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * The time and offset do not affect the calculation and will be the same in the result.\n     * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return an {@code OffsetDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public OffsetDateTime withDayOfYear(int dayOfYear) {\n        return with(dateTime.withDayOfYear(dayOfYear), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public OffsetDateTime withHour(int hour) {\n        return with(dateTime.withHour(hour), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public OffsetDateTime withMinute(int minute) {\n        return with(dateTime.withMinute(minute), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public OffsetDateTime withSecond(int second) {\n        return with(dateTime.withSecond(second), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * The date and offset do not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public OffsetDateTime withNano(int nanoOfSecond) {\n        return with(dateTime.withNano(nanoOfSecond), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * The offset does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public OffsetDateTime truncatedTo(TemporalUnit unit) {\n        return with(dateTime.truncatedTo(unit), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(TemporalAmount amountToAdd) {\n        return (OffsetDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDateTime#plus(long, TemporalUnit)}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            return with(dateTime.plus(amountToAdd, unit), offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusYears(long years) {\n        return with(dateTime.plusYears(years), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMonths(long months) {\n        return with(dateTime.plusMonths(months), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusWeeks(long weeks) {\n        return with(dateTime.plusWeeks(weeks), offset);\n    }\n\n    /**\n     * Returns a copy of this OffsetDateTime with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusDays(long days) {\n        return with(dateTime.plusDays(days), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusHours(long hours) {\n        return with(dateTime.plusHours(hours), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusMinutes(long minutes) {\n        return with(dateTime.plusMinutes(minutes), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime plusSeconds(long seconds) {\n        return with(dateTime.plusSeconds(seconds), offset);\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    public OffsetDateTime plusNanos(long nanos) {\n        return with(dateTime.plusNanos(nanos), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(TemporalAmount amountToSubtract) {\n        return (OffsetDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusHours(long hours) {\n        return (hours \u003d\u003d Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusMinutes(long minutes) {\n        return (minutes \u003d\u003d Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusSeconds(long seconds) {\n        return (seconds \u003d\u003d Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public OffsetDateTime minusNanos(long nanos) {\n        return (nanos \u003d\u003d Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.offset() || query \u003d\u003d TemporalQueries.zone()) {\n            return (R) getOffset();\n        } else if (query \u003d\u003d TemporalQueries.zoneId()) {\n            return null;\n        } else if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) toLocalDate();\n        } else if (query \u003d\u003d TemporalQueries.localTime()) {\n            return (R) toLocalTime();\n        } else if (query \u003d\u003d TemporalQueries.chronology()) {\n            return (R) IsoChronology.INSTANCE;\n        } else if (query \u003d\u003d TemporalQueries.precision()) {\n            return (R) NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset, date\n     * and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the offset, date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * three times, passing {@link ChronoField#EPOCH_DAY},\n     * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisOffsetDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisOffsetDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        // OffsetDateTime is treated as three separate fields, not an instant\n        // this produces the most consistent set of results overall\n        // the offset is set after the date and time, as it is typically a small\n        // tweak to the result, with ZonedDateTime frequently ignoring the offset\n        return temporal\n                .with(EPOCH_DAY, toLocalDate().toEpochDay())\n                .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())\n                .with(OFFSET_SECONDS, getOffset().getTotalSeconds());\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code OffsetDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.\n     * If the offset differs between the two date-times, the specified\n     * end date-time is normalized to have the same offset as this date-time.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end \u003d OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end \u003d end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * \u003cp\u003e\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * \u003cp\u003e\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * \u003cp\u003e\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * \u003cp\u003e\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * \u003cp\u003e\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * \u003cp\u003e\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * \u003cp\u003e\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * For example, the following is the comparator order:\n     * \u003col\u003e\n     * \u003cli\u003e{@code 2008-12-03T10:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+02:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T11:30+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:00+01:00}\u003c/li\u003e\n     * \u003cli\u003e{@code 2008-12-03T12:30+01:00}\u003c/li\u003e\n     * \u003c/ol\u003e\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp \u003d compareInstant(this, other);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is after the instant of the specified date-time\n     */\n    public boolean isAfter(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003e otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003e other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this is before the instant of the specified date-time\n     */\n    public boolean isBefore(OffsetDateTime other) {\n        long thisEpochSec \u003d toEpochSecond();\n        long otherEpochSec \u003d other.toEpochSecond();\n        return thisEpochSec \u003c otherEpochSec ||\n            (thisEpochSec \u003d\u003d otherEpochSec \u0026\u0026 toLocalTime().getNano() \u003c other.toLocalTime().getNano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * \u003cp\u003e\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if the instant equals the instant of the specified date-time\n     */\n    public boolean isEqual(OffsetDateTime other) {\n        return toEpochSecond() \u003d\u003d other.toEpochSecond() \u0026\u0026\n                toLocalTime().getNano() \u003d\u003d other.toLocalTime().getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * The comparison is based on the local date-time and the offset.\n     * To compare for the same instant on the time-line, use {@link #isEqual}.\n     * Only objects of type {@code OffsetDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDateTime) {\n            OffsetDateTime other \u003d (OffsetDateTime) obj;\n            return dateTime.equals(other.dateTime) \u0026\u0026 offset.equals(other.offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return dateTime.hashCode() ^ offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mmXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ssXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSXXXXX}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSSXXXXX}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return dateTime.toString() + offset.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(10);  // identifies an OffsetDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDateTime\"\u003edatetime\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.ZoneOffset\"\u003eoffset\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(ObjectOutput out) throws IOException {\n        dateTime.writeExternal(out);\n        offset.writeExternal(out);\n    }\n\n    static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        LocalDateTime dateTime \u003d LocalDateTime.readExternal(in);\n        ZoneOffset offset \u003d ZoneOffset.readExternal(in);\n        return OffsetDateTime.of(dateTime, offset);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:52:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.base/java/time/OffsetDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.base/java/time/OffsetDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov. 22, 2024 9:52:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_89/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A134%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 9:53:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_89/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A134%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 9:53:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_89/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A134%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 21:53:30 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:53:38 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 21:53:38 WARN  javac exited with exit code 1
2024.11.22 21:53:38 INFO  time: compiled root in 8.7s
2024.11.22 21:53:41 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 21:53:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 21:53:50 WARN  javac exited with exit code 1
2024.11.22 21:53:50 INFO  time: compiled root in 8.92s
2024.11.22 22:07:01 INFO  compiling root (12 scala sources and 1 java source)
Nov. 22, 2024 10:07:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10870
Nov. 22, 2024 10:07:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10871
2024.11.22 22:07:21 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:07:21 WARN  javac exited with exit code 1
2024.11.22 22:07:21 INFO  time: compiled root in 20s
2024.11.22 22:07:22 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:07:29 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:07:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:10 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:08:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_90/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A26%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A35%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 22:08:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:26 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:27 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:28 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:28 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:29 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:29 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:29 WARN  Could not find 'Candlestick' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 22:08:29 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:08:30 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:08:40 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:08:40 WARN  javac exited with exit code 1
2024.11.22 22:08:40 INFO  time: compiled root in 10s
2024.11.22 22:08:41 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:09:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:12:47 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:13:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:13:03 WARN  javac exited with exit code 1
2024.11.22 22:13:03 INFO  time: compiled root in 16s
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11024
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11028
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11026
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11025
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11029
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11032
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11037
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11035
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11042
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11041
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11038
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11050
Nov. 22, 2024 10:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11049
2024.11.22 22:13:09 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:13:17 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:18 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:13:20 WARN  javac exited with exit code 1
2024.11.22 22:13:20 INFO  time: compiled root in 11s
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:20 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:13:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:13:25 WARN  failed to generate semanticdb for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\PairsRepository.scala:
java.lang.IllegalArgumentException: 1368 is not a valid offset, allowed [0..1366]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$File.offsetToLine(Input.scala:73)
	at scala.meta.inputs.Position$Range.endLine$lzycompute(Position.scala:47)
	at scala.meta.inputs.Position$Range.endLine(Position.scala:47)
	at scala.meta.internal.semanticdb.Implicits$XtensionPositionToRange$.toRange$extension(Implicits.scala:12)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.tryFindSynthetic(TextDocumentOps.scala:429)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:569)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$Select.traverse(Trees.scala:857)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$Select.traverse(Trees.scala:857)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.api.Trees$Traverser.traverseTrees(Trees.scala:2506)
	at scala.reflect.internal.Trees$Apply.traverse(Trees.scala:791)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$DefDef.$anonfun$traverse$4(Trees.scala:463)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.internal.Trees$DefDef.traverse(Trees.scala:457)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$2(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$1(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.traverseStats(Trees.scala:2519)
	at scala.reflect.internal.Trees$Template.traverse(Trees.scala:550)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$ClassDef.$anonfun$traverse$1(Trees.scala:369)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.internal.Trees$ClassDef.traverse(Trees.scala:365)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$2(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$1(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.traverseStats(Trees.scala:2519)
	at scala.reflect.internal.Trees$PackageDef.traverse(Trees.scala:349)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:628)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:43)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.saveSemanticdbForCompilationUnit(SemanticdbPipeline.scala:66)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.apply(SemanticdbPipeline.scala:70)
	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:480)
	at scala.tools.nsc.Global$GlobalPhase.run(Global.scala:427)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.run(SemanticdbPipeline.scala:78)
	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1546)
	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1530)
	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1522)
	at scala.tools.nsc.Global$Run.compileFiles(Global.scala:1635)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:176)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:139)
	at scala.tools.xsbt.CompilerBridge.run(CompilerBridge.scala:43)
	at sbt.internal.inc.AnalyzingCompiler.compile(AnalyzingCompiler.scala:91)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.compileSources$1(BloopHighLevelCompiler.scala:148)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$9(BloopHighLevelCompiler.scala:181)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$1(BloopHighLevelCompiler.scala:73)
	at bloop.tracing.NoopTracer$.trace(BraveTracer.scala:53)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.timed$1(BloopHighLevelCompiler.scala:72)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$8(BloopHighLevelCompiler.scala:181)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)
	at monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)
	at monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)
	at monix.eval.internal.TaskExecuteOn$AsyncRegister$$anon$1.run(TaskExecuteOn.scala:71)
	at java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
2024.11.22 22:13:32 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:13:32 WARN  javac exited with exit code 1
2024.11.22 22:13:32 INFO  time: compiled root in 12s
2024.11.22 22:13:32 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:13:44 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:13:44 WARN  javac exited with exit code 1
2024.11.22 22:13:44 INFO  time: compiled root in 11s
2024.11.22 22:14:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:14:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:14:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:14:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:14:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:14:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11201
2024.11.22 22:14:54 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:16:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:16:30 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\PairsRepository.scala
2024.11.22 22:16:56 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:17:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:17:04 WARN  javac exited with exit code 1
2024.11.22 22:17:04 INFO  time: compiled root in 8.05s
2024.11.22 22:17:08 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:17:13 WARN  Could not find semantic tokens for: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/models/CandleStick.scala
Nov. 22, 2024 10:17:13 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.11.22 22:17:20 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:17:20 WARN  javac exited with exit code 1
2024.11.22 22:17:20 INFO  time: compiled root in 12s
2024.11.22 22:17:20 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:17:22 INFO  time: compiled root in 1.95s
2024.11.22 22:17:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:25 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 22:17:25 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 22:17:25 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 22:17:25 WARN  Could not find 'pairId' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 22:17:26 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:26 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:17:26 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:28 INFO  time: compiled root in 1.77s
2024.11.22 22:17:28 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:30 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:30 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:30 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:30 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 22:17:30 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 22:17:30 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.11.22 22:17:30 WARN  Could not find 'pairId' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.22 22:17:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:32 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:32 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:17:32 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:34 INFO  time: compiled root in 2.03s
2024.11.22 22:17:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:37 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:37 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:37 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:37 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:38 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:17:38 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:17:41 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:17:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11578
Nov. 22, 2024 10:17:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11579
2024.11.22 22:17:46 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\PairsRepository.scala
2024.11.22 22:17:50 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:17:50 WARN  javac exited with exit code 1
2024.11.22 22:17:50 INFO  time: compiled root in 12s
2024.11.22 22:17:54 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:18:04 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:18:04 WARN  javac exited with exit code 1
2024.11.22 22:18:04 INFO  time: compiled root in 10s
2024.11.22 22:18:08 INFO  compiling root (12 scala sources and 1 java source)
Exception in thread "metals-watch-callback-thread" java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionAbsolutePathBuffers.toInputFromBuffers(MetalsEnrichments.scala:621)
	at scala.meta.internal.metals.Compilers.originInput$1(Compilers.scala:227)
	at scala.meta.internal.metals.Compilers.$anonfun$didChange$2(Compilers.scala:243)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.Compilers.$anonfun$didChange$1(Compilers.scala:242)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.Compilers.didChange(Compilers.scala:230)
	at scala.meta.internal.metals.MetalsLspService.onCreate(MetalsLspService.scala:383)
	at scala.meta.internal.metals.ProjectMetalsLspService.didChangeWatchedFiles(ProjectMetalsLspService.scala:412)
	at scala.meta.internal.metals.ProjectMetalsLspService.$anonfun$fileWatcher$3(ProjectMetalsLspService.scala:110)
	at scala.meta.internal.metals.ProjectMetalsLspService.$anonfun$fileWatcher$3$adapted(ProjectMetalsLspService.scala:109)
	at scala.meta.internal.metals.watcher.ProjectFileWatcher$$anon$1.loop(ProjectFileWatcher.scala:199)
	at scala.meta.internal.metals.watcher.ProjectFileWatcher$$anon$1.run(ProjectFileWatcher.scala:203)
2024.11.22 22:18:18 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:18:18 WARN  javac exited with exit code 1
2024.11.22 22:18:18 INFO  time: compiled root in 9.9s
2024.11.22 22:18:18 INFO  compiling root (8 scala sources)
2024.11.22 22:18:20 INFO  time: compiled root in 1.54s
2024.11.22 22:18:20 INFO  compiling root (8 scala sources)
2024.11.22 22:18:21 INFO  time: compiled root in 1.09s
2024.11.22 22:18:21 INFO  compiling root (8 scala sources)
2024.11.22 22:18:23 INFO  time: compiled root in 1.75s
2024.11.22 22:28:56 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:28:56 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:29:00 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:29:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:29:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:29:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:29:10 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:29:10 WARN  javac exited with exit code 1
2024.11.22 22:29:10 INFO  time: compiled root in 14s
2024.11.22 22:30:22 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:22 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:30:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11763
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:24 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:30:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11778
2024.11.22 22:30:26 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:30:26 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:29 INFO  time: compiled root in 2.7s
2024.11.22 22:30:29 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:30:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11819
2024.11.22 22:30:45 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:48 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:49 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:30:49 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:30:57 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:30:57 WARN  javac exited with exit code 1
2024.11.22 22:30:57 INFO  time: compiled root in 8.53s
2024.11.22 22:30:57 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:33:14 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:33:29 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:33:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:33:36 WARN  javac exited with exit code 1
2024.11.22 22:33:36 INFO  time: compiled root in 21s
2024.11.22 22:33:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:04 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:34:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_93/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A24%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A33%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 22:34:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:36 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:37 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:34:37 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:34:39 INFO  time: compiled root in 2.48s
2024.11.22 22:34:40 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:00 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:35:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_94/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A55%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 22:35:17 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:19 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:20 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:35:20 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:29 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:35:29 WARN  javac exited with exit code 1
2024.11.22 22:35:29 INFO  time: compiled root in 8.91s
2024.11.22 22:35:29 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:35:54 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:37:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_95/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A23%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A31%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 22, 2024 10:37:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_95/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A23%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A31%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 22:37:45 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:37:54 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:37:54 WARN  javac exited with exit code 1
2024.11.22 22:37:54 INFO  time: compiled root in 9.09s
2024.11.22 22:37:56 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 22, 2024 10:37:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://f4ca2998-5141-49ee-981b-d0041f37d4ad/response_95/1#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A23%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A31%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.22 22:38:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:02 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:03 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:05 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:06 INFO  compiling root (12 scala sources and 1 java source)
2024.11.22 22:38:07 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 22:38:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.22 22:38:17 WARN  javac exited with exit code 1
2024.11.22 22:38:17 INFO  time: compiled root in 10s
2024.11.22 22:38:17 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.22 23:29:27 INFO  Shutting down server
2024.11.22 23:29:27 INFO  shutting down Metals
2024.11.22 23:29:28 INFO  Shut down connection with build server.
2024.11.22 23:29:28 INFO  Shut down connection with build server.
2024.11.22 23:29:28 INFO  Shut down connection with build server.
2024.11.23 21:55:59 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.96.0-insider.
2024.11.23 21:55:59 INFO  time: initialize in 0.12s
2024.11.23 21:56:17 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.23 21:56:18 INFO  Attempting to connect to the build server...
2024.11.23 21:56:18 INFO  Found a Bloop server running
2024.11.23 21:56:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.23 21:56:23 INFO  Attempting to connect to the build server...
2024.11.23 21:56:23 INFO  Found a Bloop server running
2024.11.23 21:56:23 INFO  Attempting to connect to the build server...
2024.11.23 21:56:23 INFO  Found a Bloop server running
2024.11.23 21:56:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.23 21:56:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.23 21:56:26 INFO  time: Connected to build server in 7.62s
2024.11.23 21:56:26 INFO  Connected to Build server: Bloop v2.0.3
2024.11.23 21:56:27 INFO  time: Imported build in 0.5s
2024.11.23 21:56:27 INFO  running doctor check
2024.11.23 21:56:27 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.23 21:56:31 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.11.23 21:57:12 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
Nov. 23, 2024 9:57:37 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.23 21:57:49 INFO  time: indexed workspace in 1m22s
2024.11.23 21:59:16 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 21:59:30 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.23 21:59:30 WARN  javac exited with exit code 1
2024.11.23 21:59:30 INFO  time: compiled root in 14s
Nov. 23, 2024 10:17:49 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 23, 2024 10:24:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3
2024.11.23 22:24:09 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.23 22:24:09 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.23 22:33:22 INFO  compiling root (6 scala sources)
2024.11.23 22:33:29 INFO  time: compiled root in 6.81s
2024.11.23 22:33:29 INFO  compiling root (6 scala sources)
2024.11.23 22:33:29 INFO  time: compiled root in 0.75s
2024.11.23 22:35:08 INFO  compiling root (12 scala sources and 1 java source)
Nov. 23, 2024 10:35:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 26
Nov. 23, 2024 10:35:18 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMATION: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.11.23 22:35:20 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.23 22:35:20 WARN  javac exited with exit code 1
2024.11.23 22:35:20 INFO  time: compiled root in 11s
Exception in thread "pool-6-thread-1" scala.tools.nsc.interactive.ShutdownReq$
Nov. 23, 2024 10:35:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 46
Nov. 23, 2024 10:35:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 48
2024.11.23 22:39:52 INFO  compiling root (12 scala sources and 1 java source)
Nov. 23, 2024 10:39:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 55
2024.11.23 22:40:03 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.23 22:40:03 WARN  javac exited with exit code 1
2024.11.23 22:40:03 INFO  time: compiled root in 10s
Nov. 23, 2024 10:43:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 129
Nov. 23, 2024 10:53:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://fc050cae-5a78-4ec1-8377-9b0123a82987/response_45/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A114%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 23, 2024 10:53:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://fc050cae-5a78-4ec1-8377-9b0123a82987/response_45/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A114%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 23, 2024 10:53:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://fc050cae-5a78-4ec1-8377-9b0123a82987/response_45/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A114%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.23 22:54:00 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 22:54:03 INFO  time: compiled root in 2.61s
Nov. 23, 2024 10:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://fc050cae-5a78-4ec1-8377-9b0123a82987/response_45/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A114%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 23, 2024 10:55:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 315
2024.11.23 22:55:44 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 22:55:50 INFO  time: compiled root in 6.7s
2024.11.23 22:56:11 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 22:56:12 INFO  time: compiled root in 1.19s
Nov. 23, 2024 10:56:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://fc050cae-5a78-4ec1-8377-9b0123a82987/response_45/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Ccontrollers%5C%5CCandlesticksController.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fcontrollers%2FCandlesticksController.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A61%2C%22startColumn%22%3A2%2C%22endLineNumber%22%3A114%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Nov. 23, 2024 10:56:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 469
2024.11.23 22:56:42 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 22:56:42 INFO  time: compiled root in 0.68s
2024.11.23 22:57:01 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 22:57:03 INFO  time: compiled root in 1.74s
2024.11.23 22:57:38 INFO  compiling root (12 scala sources and 1 java source)
2024.11.23 22:57:48 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.23 22:57:48 WARN  javac exited with exit code 1
2024.11.23 22:57:48 INFO  time: compiled root in 9.33s
2024.11.24 14:28:52 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:28:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:28:55 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 24, 2024 2:30:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://9a74c660-c9a9-4e7e-85c0-120a7ea8d950/response_55/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Crepositories%5C%5CCandlesRepository.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Frepositories%2FCandlesRepository.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A32%2C%22startColumn%22%3A3%2C%22endLineNumber%22%3A49%2C%22endColumn%22%3A4%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.24 14:30:28 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:31 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:34 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:30:34 INFO  compiling root (12 scala sources and 1 java source)
2024.11.24 14:31:00 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.11.24 14:31:00 WARN  javac exited with exit code 1
2024.11.24 14:31:00 INFO  time: compiled root in 25s
2024.11.24 14:31:00 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:31:51 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.11.24 14:36:55 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
Nov. 26, 2024 9:54:11 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 26, 2024 11:54:09 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 26, 2024 12:07:49 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 26, 2024 12:20:03 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Nov. 27, 2024 12:11:09 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.11.27 12:34:44 ERROR Bloop 'bsp' command exited with code 1. Something may be wrong with the current configuration.
Running the [1mclean[0m sub-command to clear the working directory and remove caches might help.
If the error persists, please report the issue as a bug and attach a log with increased verbosity by passing [1m-v -v -v[0m.
2024.11.27 12:34:44 ERROR Bloop 'bsp' command exited with code 1. Something may be wrong with the current configuration.
Running the [1mclean[0m sub-command to clear the working directory and remove caches might help.
If the error persists, please report the issue as a bug and attach a log with increased verbosity by passing [1m-v -v -v[0m.
2024.11.27 12:34:44 ERROR Bloop 'bsp' command exited with code 1. Something may be wrong with the current configuration.
Running the [1mclean[0m sub-command to clear the working directory and remove caches might help.
If the error persists, please report the issue as a bug and attach a log with increased verbosity by passing [1m-v -v -v[0m.
2024.11.27 12:34:44 INFO  No running Bloop server found, starting one.
2024.11.27 12:34:44 INFO  No running Bloop server found, starting one.
2024.11.27 12:34:44 INFO  No running Bloop server found, starting one.
2024.11.29 14:04:58 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.96.0-insider.
2024.11.29 14:05:05 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.29 14:05:06 INFO  Attempting to connect to the build server...
2024.11.29 14:05:06 INFO  No running Bloop server found, starting one.
2024.11.29 14:05:15 INFO  Starting compilation server
2024.11.29 14:05:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.29 14:05:38 INFO  Attempting to connect to the build server...
2024.11.29 14:05:38 INFO  Found a Bloop server running
2024.11.29 14:05:38 INFO  Attempting to connect to the build server...
2024.11.29 14:05:38 INFO  Found a Bloop server running
2024.11.29 14:05:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.29 14:05:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.29 14:05:59 ERROR Timeout waiting for 'build/initialize' response
2024.11.29 14:05:59 WARN  Retrying connection to the build server Bloop
2024.11.29 14:05:59 INFO  Found a Bloop server running
2024.11.29 14:05:59 ERROR Timeout waiting for 'build/initialize' response
2024.11.29 14:05:59 WARN  Retrying connection to the build server Bloop
2024.11.29 14:05:59 INFO  Found a Bloop server running
2024.11.29 14:06:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.29 14:06:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.29 14:06:12 INFO  time: Connected to build server in 1m6s
2024.11.29 14:06:12 INFO  Connected to Build server: Bloop v2.0.3
2024.11.29 14:06:13 INFO  time: Imported build in 0.78s
2024.11.29 14:06:13 INFO  running doctor check
2024.11.29 14:06:13 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.11.29 14:07:03 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.11.29 14:08:14 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.29 14:09:39 INFO  time: indexed workspace in 3m25s
2024.12.04 19:46:19 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.96.0-insider.
2024.12.04 19:46:25 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.12.04 19:46:25 INFO  Attempting to connect to the build server...
2024.12.04 19:46:25 INFO  No running Bloop server found, starting one.
2024.12.04 19:46:36 INFO  Starting compilation server
2024.12.04 19:46:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.12.04 19:46:57 INFO  Attempting to connect to the build server...
2024.12.04 19:46:57 INFO  Found a Bloop server running
2024.12.04 19:46:57 INFO  Attempting to connect to the build server...
2024.12.04 19:46:57 INFO  Found a Bloop server running
2024.12.04 19:47:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.12.04 19:47:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.12.04 19:47:04 INFO  time: Connected to build server in 38s
2024.12.04 19:47:04 INFO  Connected to Build server: Bloop v2.0.3
2024.12.04 19:47:05 INFO  time: Imported build in 0.59s
2024.12.04 19:47:05 INFO  running doctor check
2024.12.04 19:47:05 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.12.04 19:47:09 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.12.04 19:48:01 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.12.04 19:48:55 INFO  time: indexed workspace in 1m49s
2024.12.05 16:04:05 INFO  Shutting down server
2024.12.05 16:04:05 INFO  shutting down Metals
2024.12.05 16:04:06 INFO  Shut down connection with build server.
2024.12.05 16:04:06 INFO  Shut down connection with build server.
2024.12.05 16:04:06 INFO  Shut down connection with build server.
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@3ac76ea3[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 364]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:435)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete(Promise.scala:278)
	at scala.concurrent.Promise.complete(Promise.scala:57)
	at scala.concurrent.Promise.complete$(Promise.scala:56)
	at scala.concurrent.impl.Promise$DefaultPromise.complete(Promise.scala:104)
	at bloop.rifle.internal.Operations$.$anonfun$bsp$1(Operations.scala:374)
	at bloop.rifle.BloopRifleLogger.$anonfun$runnable$1(BloopRifleLogger.scala:14)
	at java.base/java.lang.Thread.run(Thread.java:833)
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@3ac76ea3[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 364]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:435)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete(Promise.scala:278)
	at scala.concurrent.Promise.complete(Promise.scala:57)
	at scala.concurrent.Promise.complete$(Promise.scala:56)
	at scala.concurrent.impl.Promise$DefaultPromise.complete(Promise.scala:104)
	at bloop.rifle.internal.Operations$.$anonfun$bsp$1(Operations.scala:374)
	at bloop.rifle.BloopRifleLogger.$anonfun$runnable$1(BloopRifleLogger.scala:14)
	at java.base/java.lang.Thread.run(Thread.java:833)
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@3ac76ea3[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 364]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:435)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete(Promise.scala:278)
	at scala.concurrent.Promise.complete(Promise.scala:57)
	at scala.concurrent.Promise.complete$(Promise.scala:56)
	at scala.concurrent.impl.Promise$DefaultPromise.complete(Promise.scala:104)
	at bloop.rifle.internal.Operations$.$anonfun$bsp$1(Operations.scala:374)
	at bloop.rifle.BloopRifleLogger.$anonfun$runnable$1(BloopRifleLogger.scala:14)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.12.05 19:49:16 INFO  Started: Metals version 1.3.5+171-b77fedf0-SNAPSHOT in folders 'C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend' for client Visual Studio Code - Insiders 1.96.0-insider.
2024.12.05 19:49:21 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.12.05 19:49:22 INFO  Attempting to connect to the build server...
2024.12.05 19:49:22 INFO  Found a Bloop server running
2024.12.05 19:49:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.12.05 19:49:28 INFO  Attempting to connect to the build server...
2024.12.05 19:49:28 INFO  Found a Bloop server running
2024.12.05 19:49:28 INFO  Attempting to connect to the build server...
2024.12.05 19:49:28 INFO  Found a Bloop server running
2024.12.05 19:49:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.12.05 19:49:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\project\project\.metals\bsp.trace.json or C:\Users\sti\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.12.05 19:49:30 INFO  time: Connected to build server in 8.45s
2024.12.05 19:49:30 INFO  Connected to Build server: Bloop v2.0.3
2024.12.05 19:49:31 INFO  time: Imported build in 0.6s
2024.12.05 19:49:32 INFO  running doctor check
2024.12.05 19:49:32 INFO  java targets: root-test, root, backend-build, backend-build-build
2024.12.05 19:49:36 WARN  2.12.16 is no longer supported in the current Metals versions, using the last known supported version 1.3.5
2024.12.05 19:50:20 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.12.05 19:51:09 INFO  time: indexed workspace in 1m37s
2024.12.05 20:59:04 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.12.05 20:59:04 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.12.05 20:59:06 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
2024.12.05 20:59:06 INFO  no build target found for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\build.sc. Using presentation compiler with project's scala-library version: 2.13.12
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10
Dez. 05, 2024 8:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 13
Dez. 05, 2024 10:28:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 18
Dez. 05, 2024 10:28:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 17
Dez. 05, 2024 10:28:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 20
Dez. 05, 2024 10:28:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 27
Dez. 05, 2024 10:28:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 25
2024.12.05 22:28:35 INFO  time: code lens generation in 2.53s
2024.12.05 22:28:35 INFO  time: code lens generation in 2.84s
2024.12.05 22:30:20 INFO  compiling root (13 scala sources and 1 java source)
2024.12.05 22:30:31 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 2h 41m 3.645s)
2024.12.05 22:30:31 INFO  compiling root (13 scala sources and 1 java source)
Dez. 05, 2024 10:30:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 61
2024.12.05 22:30:44 INFO  compiling root (13 scala sources and 1 java source)
Dez. 05, 2024 10:30:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 76
2024.12.05 22:31:06 INFO  time: compiled root in 21s
2024.12.05 22:31:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:31:15 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:31:15 WARN  javac exited with exit code 1
2024.12.05 22:31:15 WARN  javac exited with exit code 1
2024.12.05 22:31:15 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 2h 41m 47.776s)
2024.12.05 22:31:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5+171-b77fedf0-SNAPSHOT' (since 2h 41m 47.851s)
2024.12.05 22:31:16 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:31:16 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:31:16 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:31:31 INFO  time: compiled root in 15s
2024.12.05 22:31:31 INFO  compiling root (15 scala sources and 1 java source)
Dez. 05, 2024 10:31:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 145
2024.12.05 22:31:43 INFO  time: compiled root in 11s
2024.12.05 22:32:06 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:32:09 INFO  time: compiled root in 2.8s
2024.12.05 22:32:26 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:32:29 INFO  time: compiled root in 2.55s
2024.12.05 22:32:56 WARN  Could not find 'ExecutionContext' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.12.05 22:33:19 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:33:22 INFO  time: compiled root in 3.04s
2024.12.05 22:33:31 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:33:34 INFO  time: compiled root in 2.67s
2024.12.05 22:34:27 INFO  compiling root (9 scala sources)
2024.12.05 22:34:32 INFO  time: compiled root in 4.55s
2024.12.05 22:34:32 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:34:41 INFO  time: compiled root in 9.47s
2024.12.05 22:35:25 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:35:38 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:35:40 INFO  time: compiled root in 2.54s
2024.12.05 22:35:50 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.12.05 22:35:53 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.12.05 22:36:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:36:11 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:36:13 INFO  time: compiled root in 2.56s
Dez. 05, 2024 10:36:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 560
2024.12.05 22:36:15 INFO  compiling root (14 scala sources and 1 java source)
Dez. 05, 2024 10:36:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-chat-code-block://45482292-0ad2-4dbb-b7c0-e0e7e240d06f/response_d6f3b359-31f0-40a2-b8a5-940da9f4bb6b/0#%7B%22references%22%3A%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22c%3A%5C%5CUsers%5C%5Csti%5C%5COneDrive%20-%20Leicom%20AG%5C%5CDesktop%5C%5CHTWG%5C%5CWeb_App%5C%5Cbackend%5C%5Capp%5C%5Cmodels%5C%5CUser.scala%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fc%253A%2FUsers%2Fsti%2FOneDrive%2520-%2520Leicom%2520AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FUser.scala%22%2C%22path%22%3A%22%2Fc%3A%2FUsers%2Fsti%2FOneDrive%20-%20Leicom%20AG%2FDesktop%2FHTWG%2FWeb_App%2Fbackend%2Fapp%2Fmodels%2FUser.scala%22%2C%22scheme%22%3A%22file%22%7D%2C%22range%22%3A%7B%22startLineNumber%22%3A1%2C%22startColumn%22%3A1%2C%22endLineNumber%22%3A14%2C%22endColumn%22%3A1%7D%7D%5D%7D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-chat-code-block" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.12.05 22:36:18 INFO  time: compiled root in 2.58s
2024.12.05 22:36:19 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Dez. 05, 2024 10:36:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Dez. 05, 2024 10:36:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Dez. 05, 2024 10:36:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 581
Dez. 05, 2024 10:36:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 583
Dez. 05, 2024 10:36:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 585
Dez. 05, 2024 10:36:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 591
2024.12.05 22:36:24 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:36:28 INFO  time: compiled root in 3.88s
Dez. 05, 2024 10:36:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 642
2024.12.05 22:36:45 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:36:48 INFO  time: compiled root in 2.93s
Dez. 05, 2024 10:36:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 722
Dez. 05, 2024 10:36:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 725
2024.12.05 22:37:01 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:37:06 INFO  time: compiled root in 4.62s
Dez. 05, 2024 10:37:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 775
Dez. 05, 2024 10:37:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 799
Dez. 05, 2024 10:37:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 806
Dez. 05, 2024 10:37:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 811
Dez. 05, 2024 10:37:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 812
Dez. 05, 2024 10:37:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 820
Dez. 05, 2024 10:37:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 822
Dez. 05, 2024 10:37:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 828
Dez. 05, 2024 10:37:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 831
Dez. 05, 2024 10:37:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 832
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 836
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 837
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 838
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 839
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 840
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 841
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 843
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 844
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 845
Dez. 05, 2024 10:37:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 847
2024.12.05 22:37:36 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:37:51 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:37:51 WARN  javac exited with exit code 1
2024.12.05 22:37:51 INFO  time: compiled root in 15s
2024.12.05 22:39:15 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:39:30 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:39:30 WARN  javac exited with exit code 1
2024.12.05 22:39:30 INFO  time: compiled root in 14s
2024.12.05 22:39:30 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:39:44 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:39:44 WARN  javac exited with exit code 1
2024.12.05 22:39:44 INFO  time: compiled root in 13s
2024.12.05 22:40:53 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:41:06 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:41:06 WARN  javac exited with exit code 1
2024.12.05 22:41:06 INFO  time: compiled root in 13s
2024.12.05 22:45:18 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:45:22 INFO  time: compiled root in 4.29s
Dez. 05, 2024 10:45:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 933
Dez. 05, 2024 10:45:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 936
Exception in thread "pool-9-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Exception in thread "pool-9-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.12.05 22:45:53 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:45:56 INFO  time: compiled root in 3.39s
2024.12.05 22:45:57 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:46:17 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:46:17 WARN  javac exited with exit code 1
2024.12.05 22:46:17 INFO  time: compiled root in 19s
Dez. 05, 2024 10:47:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1038
2024.12.05 22:47:56 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\PairsRepository.scala
2024.12.05 22:48:00 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.12.05 22:48:01 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\CandlesRepository.scala
2024.12.05 22:48:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:48:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:48:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:48:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:48:06 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\CandleStick.scala
2024.12.05 22:48:14 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\CandlesticksController.scala
Dez. 05, 2024 10:48:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1080
2024.12.05 22:49:08 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java

Uri: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Dez. 05, 2024 10:49:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\n/**\n * \u003cP\u003eA thin wrapper around {@code java.util.Date} that allows\n * the JDBC API to identify this as an SQL {@code TIMESTAMP} value.\n * It adds the ability\n * to hold the SQL {@code TIMESTAMP} fractional seconds value, by allowing\n * the specification of fractional seconds to a precision of nanoseconds.\n * A Timestamp also provides formatting and\n * parsing operations to support the JDBC escape syntax for timestamp values.\n *\n * \u003cp\u003eThe precision of a Timestamp object is calculated to be either:\n * \u003cul\u003e\n * \u003cli\u003e{@code 19 }, which is the number of characters in yyyy-mm-dd hh:mm:ss\n * \u003cli\u003e {@code  20 + s }, which is the number\n * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and {@code s} represents  the scale of the given Timestamp,\n * its fractional seconds precision.\n *\u003c/ul\u003e\n *\n * \u003cP\u003e\u003cB\u003eNote:\u003c/B\u003e This type is a composite of a {@code java.util.Date} and a\n * separate nanoseconds value. Only integral seconds are stored in the\n * {@code java.util.Date} component. The fractional seconds - the nanos - are\n * separate.  The {@code Timestamp.equals(Object)} method never returns\n * {@code true} when passed an object\n * that isn\u0027t an instance of {@code java.sql.Timestamp},\n * because the nanos component of a date is unknown.\n * As a result, the {@code Timestamp.equals(Object)}\n * method is not symmetric with respect to the\n * {@code java.util.Date.equals(Object)}\n * method.  Also, the {@code hashCode} method uses the underlying\n * {@code java.util.Date}\n * implementation and therefore does not include nanos in its computation.\n * \u003cP\u003e\n * Due to the differences between the {@code Timestamp} class\n * and the {@code java.util.Date}\n * class mentioned above, it is recommended that code not view\n * {@code Timestamp} values generically as an instance of\n * {@code java.util.Date}.  The\n * inheritance relationship between {@code Timestamp}\n * and {@code java.util.Date} really\n * denotes implementation inheritance, and not type inheritance.\n *\n * @since 1.1\n */\npublic class Timestamp extends java.util.Date {\n\n    /**\n     * Constructs a {@code Timestamp} object initialized\n     * with the given values.\n     *\n     * @param year the year minus 1900\n     * @param month 0 to 11\n     * @param date 1 to 31\n     * @param hour 0 to 23\n     * @param minute 0 to 59\n     * @param second 0 to 59\n     * @param nano 0 to 999,999,999\n     * @deprecated instead use the constructor {@code Timestamp(long millis)}\n     * @exception IllegalArgumentException if the nano argument is out of bounds\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public Timestamp(int year, int month, int date,\n                     int hour, int minute, int second, int nano) {\n        super(year, month, date, hour, minute, second);\n        if (nano \u003e 999999999 || nano \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d nano;\n    }\n\n    /**\n     * Constructs a {@code Timestamp} object\n     * using a milliseconds time value. The\n     * integral seconds are stored in the underlying date value; the\n     * fractional seconds are stored in the {@code nanos} field of\n     * the {@code Timestamp} object.\n     *\n     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.\n     *        A negative number is the number of milliseconds before\n     *         January 1, 1970, 00:00:00 GMT.\n     * @see java.util.Calendar\n     */\n    public Timestamp(long time) {\n        super((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Sets this {@code Timestamp} object to represent a point in time that is\n     * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.\n     *\n     * @param time   the number of milliseconds.\n     * @see #getTime\n     * @see #Timestamp(long time)\n     * @see java.util.Calendar\n     */\n    public void setTime(long time) {\n        super.setTime((time/1000)*1000);\n        nanos \u003d (int)((time%1000) * 1000000);\n        if (nanos \u003c 0) {\n            nanos \u003d 1000000000 + nanos;\n            super.setTime(((time/1000)-1)*1000);\n        }\n    }\n\n    /**\n     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     * represented by this {@code Timestamp} object.\n     *\n     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT\n     *          represented by this date.\n     * @see #setTime\n     */\n    public long getTime() {\n        long time \u003d super.getTime();\n        return (time + (nanos / 1000000));\n    }\n\n\n    /**\n     * @serial\n     */\n    private int nanos;\n\n    /**\n     * Converts a {@code String} object in JDBC timestamp escape format to a\n     * {@code Timestamp} value.\n     *\n     * @param s timestamp in format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}.  The\n     * fractional seconds may be omitted. The leading zero for {@code mm}\n     * and {@code dd} may also be omitted.\n     *\n     * @return corresponding {@code Timestamp} value\n     * @exception java.lang.IllegalArgumentException if the given argument\n     * does not have the format {@code yyyy-[m]m-[d]d hh:mm:ss[.f...]}\n     */\n    public static Timestamp valueOf(String s) {\n        final int YEAR_LENGTH \u003d 4;\n        final int MONTH_LENGTH \u003d 2;\n        final int DAY_LENGTH \u003d 2;\n        final int MAX_MONTH \u003d 12;\n        final int MAX_DAY \u003d 31;\n        int year \u003d 0;\n        int month \u003d 0;\n        int day \u003d 0;\n        int hour;\n        int minute;\n        int second;\n        int a_nanos \u003d 0;\n        int firstDash;\n        int secondDash;\n        int dividingSpace;\n        int firstColon;\n        int secondColon;\n        int period;\n        String formatError \u003d \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\n\n        if (s \u003d\u003d null) throw new java.lang.IllegalArgumentException(\"null string\");\n\n        // Split the string into date and time components\n        s \u003d s.trim();\n        dividingSpace \u003d s.indexOf(\u0027 \u0027);\n        if (dividingSpace \u003c 0) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Parse the date\n        firstDash \u003d s.indexOf(\u0027-\u0027);\n        secondDash \u003d s.indexOf(\u0027-\u0027, firstDash+1);\n\n        // Parse the time\n        firstColon \u003d s.indexOf(\u0027:\u0027, dividingSpace + 1);\n        secondColon \u003d s.indexOf(\u0027:\u0027, firstColon + 1);\n        period \u003d s.indexOf(\u0027.\u0027, secondColon + 1);\n\n        // Convert the date\n        boolean parsedDate \u003d false;\n        if (firstDash \u003e 0 \u0026\u0026 secondDash \u003e 0 \u0026\u0026 secondDash \u003c dividingSpace - 1) {\n            if (firstDash \u003d\u003d YEAR_LENGTH \u0026\u0026\n                    (secondDash - firstDash \u003e 1 \u0026\u0026 secondDash - firstDash \u003c\u003d MONTH_LENGTH + 1) \u0026\u0026\n                    (dividingSpace - secondDash \u003e 1 \u0026\u0026 dividingSpace - secondDash \u003c\u003d DAY_LENGTH + 1)) {\n                 year \u003d Integer.parseInt(s, 0, firstDash, 10);\n                 month \u003d Integer.parseInt(s, firstDash + 1, secondDash, 10);\n                 day \u003d Integer.parseInt(s, secondDash + 1, dividingSpace, 10);\n\n                if ((month \u003e\u003d 1 \u0026\u0026 month \u003c\u003d MAX_MONTH) \u0026\u0026 (day \u003e\u003d 1 \u0026\u0026 day \u003c\u003d MAX_DAY)) {\n                    parsedDate \u003d true;\n                }\n            }\n        }\n        if (! parsedDate) {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        // Convert the time; default missing nanos\n        int len \u003d s.length();\n        if (firstColon \u003e 0 \u0026\u0026 secondColon \u003e 0 \u0026\u0026 secondColon \u003c len - 1) {\n            hour \u003d Integer.parseInt(s, dividingSpace + 1, firstColon, 10);\n            minute \u003d Integer.parseInt(s, firstColon + 1, secondColon, 10);\n            if (period \u003e 0 \u0026\u0026 period \u003c len - 1) {\n                second \u003d Integer.parseInt(s, secondColon + 1, period, 10);\n                int nanoPrecision \u003d len - (period + 1);\n                if (nanoPrecision \u003e 9)\n                    throw new java.lang.IllegalArgumentException(formatError);\n                if (!Character.isDigit(s.charAt(period + 1)))\n                    throw new java.lang.IllegalArgumentException(formatError);\n                int tmpNanos \u003d Integer.parseInt(s, period + 1, len, 10);\n                while (nanoPrecision \u003c 9) {\n                    tmpNanos *\u003d 10;\n                    nanoPrecision++;\n                }\n                a_nanos \u003d tmpNanos;\n            } else if (period \u003e 0) {\n                throw new java.lang.IllegalArgumentException(formatError);\n            } else {\n                second \u003d Integer.parseInt(s, secondColon + 1, len, 10);\n            }\n        } else {\n            throw new java.lang.IllegalArgumentException(formatError);\n        }\n\n        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\n    }\n\n    /**\n     * Formats a timestamp in JDBC timestamp escape format.\n     *         {@code yyyy-mm-dd hh:mm:ss.fffffffff},\n     * where {@code fffffffff} indicates nanoseconds.\n     *\n     * @return a {@code String} object in\n     *           {@code yyyy-mm-dd hh:mm:ss.fffffffff} format\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String toString() {\n        int year \u003d super.getYear() + 1900;\n        int month \u003d super.getMonth() + 1;\n        int day \u003d super.getDate();\n        int hour \u003d super.getHours();\n        int minute \u003d super.getMinutes();\n        int second \u003d super.getSeconds();\n\n        int trailingZeros \u003d 0;\n        int tmpNanos \u003d nanos;\n        if (tmpNanos \u003d\u003d 0) {\n            trailingZeros \u003d 8;\n        } else {\n            while (tmpNanos % 10 \u003d\u003d 0) {\n                tmpNanos /\u003d 10;\n                trailingZeros++;\n            }\n        }\n\n        // 8058429: To comply with current JCK tests, we need to deal with year\n        // being any number between 0 and 292278995\n        int count \u003d 10000;\n        int yearSize \u003d 4;\n        do {\n            if (year \u003c count) {\n                break;\n            }\n            yearSize++;\n            count *\u003d 10;\n        } while (count \u003c 1000000000);\n\n        char[] buf \u003d new char[25 + yearSize - trailingZeros];\n        Date.formatDecimalInt(year, buf, 0, yearSize);\n        buf[yearSize] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(month, buf, yearSize + 1, 2);\n        buf[yearSize + 3] \u003d \u0027-\u0027;\n        Date.formatDecimalInt(day, buf, yearSize + 4, 2);\n        buf[yearSize + 6] \u003d \u0027 \u0027;\n        Date.formatDecimalInt(hour, buf, yearSize + 7, 2);\n        buf[yearSize + 9] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(minute, buf, yearSize + 10, 2);\n        buf[yearSize + 12] \u003d \u0027:\u0027;\n        Date.formatDecimalInt(second, buf, yearSize + 13, 2);\n        buf[yearSize + 15] \u003d \u0027.\u0027;\n        Date.formatDecimalInt(tmpNanos, buf, yearSize + 16, 9 - trailingZeros);\n\n        return new String(buf);\n    }\n\n    /**\n     * Gets this {@code Timestamp} object\u0027s {@code nanos} value.\n     *\n     * @return this {@code Timestamp} object\u0027s fractional seconds component\n     * @see #setNanos\n     */\n    public int getNanos() {\n        return nanos;\n    }\n\n    /**\n     * Sets this {@code Timestamp} object\u0027s {@code nanos} field\n     * to the given value.\n     *\n     * @param n the new fractional seconds component\n     * @exception java.lang.IllegalArgumentException if the given argument\n     *            is greater than 999999999 or less than 0\n     * @see #getNanos\n     */\n    public void setNanos(int n) {\n        if (n \u003e 999999999 || n \u003c 0) {\n            throw new IllegalArgumentException(\"nanos \u003e 999999999 or \u003c 0\");\n        }\n        nanos \u003d n;\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if the given {@code Timestamp}\n     *         object is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(Timestamp ts) {\n        if (super.equals(ts)) {\n            if  (nanos \u003d\u003d ts.nanos) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Tests to see if this {@code Timestamp} object is\n     * equal to the given object.\n     *\n     * This version of the method {@code equals} has been added\n     * to fix the incorrect\n     * signature of {@code Timestamp.equals(Timestamp)} and to preserve backward\n     * compatibility with existing class files.\n     *\n     * Note: This method is not symmetric with respect to the\n     * {@code equals(Object)} method in the base class.\n     *\n     * @param ts the {@code Object} value to compare with\n     * @return {@code true} if the given {@code Object} is an instance\n     *         of a {@code Timestamp} that\n     *         is equal to this {@code Timestamp} object;\n     *         {@code false} otherwise\n     */\n    public boolean equals(java.lang.Object ts) {\n      if (ts instanceof Timestamp) {\n        return this.equals((Timestamp)ts);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * earlier than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is earlier;\n     *        {@code false} otherwise\n     */\n    public boolean before(Timestamp ts) {\n        return compareTo(ts) \u003c 0;\n    }\n\n    /**\n     * Indicates whether this {@code Timestamp} object is\n     * later than the given {@code Timestamp} object.\n     *\n     * @param ts the {@code Timestamp} value to compare with\n     * @return {@code true} if this {@code Timestamp} object is later;\n     *        {@code false} otherwise\n     */\n    public boolean after(Timestamp ts) {\n        return compareTo(ts) \u003e 0;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Timestamp} object.\n     *\n     * @param   ts   the {@code Timestamp} object to be compared to\n     *                this {@code Timestamp} object\n     * @return  the value {@code 0} if the two {@code Timestamp}\n     *          objects are equal; a value less than {@code 0} if this\n     *          {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     * @since   1.4\n     */\n    public int compareTo(Timestamp ts) {\n        long thisTime \u003d this.getTime();\n        long anotherTime \u003d ts.getTime();\n        int i \u003d (thisTime\u003canotherTime ? -1 :(thisTime\u003d\u003danotherTime?0 :1));\n        if (i \u003d\u003d 0) {\n            if (nanos \u003e ts.nanos) {\n                    return 1;\n            } else if (nanos \u003c ts.nanos) {\n                return -1;\n            }\n        }\n        return i;\n    }\n\n    /**\n     * Compares this {@code Timestamp} object to the given\n     * {@code Date} object.\n     *\n     * @param o the {@code Date} to be compared to\n     *          this {@code Timestamp} object\n     * @return  the value {@code 0} if this {@code Timestamp} object\n     *          and the given object are equal; a value less than {@code 0}\n     *          if this  {@code Timestamp} object is before the given argument;\n     *          and a value greater than {@code 0} if this\n     *          {@code Timestamp} object is after the given argument.\n     *\n     * @since   1.5\n     */\n    public int compareTo(java.util.Date o) {\n       if(o instanceof Timestamp) {\n            // When Timestamp instance compare it with a Timestamp\n            // Hence it is basically calling this.compareTo((Timestamp))o);\n            // Note typecasting is safe because o is instance of Timestamp\n           return compareTo((Timestamp)o);\n      } else {\n            // When Date doing a o.compareTo(this)\n            // will give wrong results.\n          Timestamp ts \u003d new Timestamp(o.getTime());\n          return this.compareTo(ts);\n      }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The {@code hashCode} method uses the underlying {@code java.util.Date}\n     * implementation and therefore does not include nanos in its computation.\n     *\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    static final long serialVersionUID \u003d 2745179027874758501L;\n\n    private static final int MILLIS_PER_SECOND \u003d 1000;\n\n    /**\n     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}\n     * object, with the same year, month, day of month, hours, minutes,\n     * seconds and nanos date-time value as the provided {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The provided {@code LocalDateTime} is interpreted as the local\n     * date-time in the local time zone.\n     *\n     * @param dateTime a {@code LocalDateTime} to convert\n     * @return a {@code Timestamp} object\n     * @exception NullPointerException if {@code dateTime} is null.\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Timestamp valueOf(LocalDateTime dateTime) {\n        return new Timestamp(dateTime.getYear() - 1900,\n                             dateTime.getMonthValue() - 1,\n                             dateTime.getDayOfMonth(),\n                             dateTime.getHour(),\n                             dateTime.getMinute(),\n                             dateTime.getSecond(),\n                             dateTime.getNano());\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion creates a {@code LocalDateTime} that represents the\n     * same year, month, day of month, hours, minutes, seconds and nanos\n     * date-time value as this {@code Timestamp} in the local time zone.\n     *\n     * @return a {@code LocalDateTime} object representing the same date-time value\n     * @since 1.8\n     */\n    @SuppressWarnings(\"deprecation\")\n    public LocalDateTime toLocalDateTime() {\n        return LocalDateTime.of(getYear() + 1900,\n                                getMonth() + 1,\n                                getDate(),\n                                getHours(),\n                                getMinutes(),\n                                getSeconds(),\n                                getNanos());\n    }\n\n    /**\n     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.\n     * \u003cp\u003e\n     * {@code Instant} can store points on the time-line further in the future\n     * and further in the past than {@code Date}. In this scenario, this method\n     * will throw an exception.\n     *\n     * @param instant  the instant to convert\n     * @return an {@code Timestamp} representing the same point on the time-line as\n     *  the provided instant\n     * @exception NullPointerException if {@code instant} is null.\n     * @exception IllegalArgumentException if the instant is too large to\n     *  represent as a {@code Timestamp}\n     * @since 1.8\n     */\n    public static Timestamp from(Instant instant) {\n        try {\n            Timestamp stamp \u003d new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n            stamp.nanos \u003d instant.getNano();\n            return stamp;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    /**\n     * Converts this {@code Timestamp} object to an {@code Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the same\n     * point on the time-line as this {@code Timestamp}.\n     *\n     * @return an instant representing the same point on the time-line\n     * @since 1.8\n     */\n    @Override\n    public Instant toInstant() {\n        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Dez. 05, 2024 10:49:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11/lib/src.zip%21/java.sql/java/sql/Timestamp.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11/lib/src.zip!/java.sql/java/sql/Timestamp.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.12.05 22:49:08 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:49:16 WARN  failed to generate semanticdb for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\repositories\UserRepository.scala:
java.lang.IllegalArgumentException: 1332 is not a valid offset, allowed [0..1254]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$File.offsetToLine(Input.scala:73)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:45)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:45)
	at scala.meta.internal.semanticdb.Implicits$XtensionPositionToRange$.toRange$extension(Implicits.scala:10)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.tryFindSynthetic(TextDocumentOps.scala:485)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:587)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$TypeApply.traverse(Trees.scala:777)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.$anonfun$traverse$1(TextDocumentOps.scala:502)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.$anonfun$traverse$1$adapted(TextDocumentOps.scala:501)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:501)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$ValDef.$anonfun$traverse$3(Trees.scala:441)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.internal.Trees$ValDef.traverse(Trees.scala:437)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$2(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$1(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.traverseStats(Trees.scala:2519)
	at scala.reflect.internal.Trees$Template.traverse(Trees.scala:550)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.internal.Trees$ClassDef.$anonfun$traverse$1(Trees.scala:369)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.internal.Trees$ClassDef.traverse(Trees.scala:365)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:165)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$2(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$1(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.traverseStats(Trees.scala:2519)
	at scala.reflect.internal.Trees$PackageDef.traverse(Trees.scala:349)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:625)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:628)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:43)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.saveSemanticdbForCompilationUnit(SemanticdbPipeline.scala:66)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.apply(SemanticdbPipeline.scala:70)
	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:480)
	at scala.tools.nsc.Global$GlobalPhase.run(Global.scala:427)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.run(SemanticdbPipeline.scala:78)
	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1546)
	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1530)
	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1522)
	at scala.tools.nsc.Global$Run.compileFiles(Global.scala:1635)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:176)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:139)
	at scala.tools.xsbt.CompilerBridge.run(CompilerBridge.scala:43)
	at sbt.internal.inc.AnalyzingCompiler.compile(AnalyzingCompiler.scala:91)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.compileSources$1(BloopHighLevelCompiler.scala:148)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$9(BloopHighLevelCompiler.scala:181)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$1(BloopHighLevelCompiler.scala:73)
	at bloop.tracing.NoopTracer$.trace(BraveTracer.scala:53)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.timed$1(BloopHighLevelCompiler.scala:72)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$8(BloopHighLevelCompiler.scala:181)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)
	at monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)
	at monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)
	at monix.eval.internal.TaskExecuteOn$AsyncRegister$$anon$1.run(TaskExecuteOn.scala:71)
	at java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
2024.12.05 22:49:25 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:49:25 WARN  javac exited with exit code 1
2024.12.05 22:49:25 INFO  time: compiled root in 16s
2024.12.05 22:49:27 INFO  compiling root (14 scala sources and 1 java source)
2024.12.05 22:49:29 INFO  time: compiled root in 2.62s
2024.12.05 22:49:32 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:49:35 INFO  time: compiled root in 2.9s
2024.12.05 22:49:42 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:49:44 INFO  time: compiled root in 2.49s
Dez. 05, 2024 10:49:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1165
2024.12.05 22:49:53 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:49:59 INFO  time: compiled root in 6.22s
Dez. 05, 2024 10:50:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1208
Dez. 05, 2024 10:50:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1212
Dez. 05, 2024 10:50:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1209
2024.12.05 22:50:36 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:50:39 INFO  time: compiled root in 3.12s
2024.12.05 22:50:46 WARN  Could not find 'Json' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.12.05 22:50:59 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:51:01 INFO  time: compiled root in 2.33s
2024.12.05 22:52:26 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:52:43 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:52:43 WARN  javac exited with exit code 1
2024.12.05 22:52:43 INFO  time: compiled root in 16s
2024.12.05 22:56:07 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:56:17 WARN  Could not load snapshot text for C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\controllers\CandlesticksController.scala
2024.12.05 22:56:25 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:56:25 WARN  javac exited with exit code 1
2024.12.05 22:56:25 INFO  time: compiled root in 18s
2024.12.05 22:56:25 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:56:46 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:56:46 WARN  javac exited with exit code 1
2024.12.05 22:56:46 INFO  time: compiled root in 20s
2024.12.05 22:57:38 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 22:58:08 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 22:58:08 WARN  javac exited with exit code 1
2024.12.05 22:58:08 INFO  time: compiled root in 29s
2024.12.05 23:04:54 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 23:05:22 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 23:05:27 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 23:05:27 WARN  javac exited with exit code 1
2024.12.05 23:05:27 INFO  time: compiled root in 5.5s
2024.12.05 23:05:42 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 23:05:42 WARN  javac exited with exit code 1
Dez. 05, 2024 11:06:05 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\User.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\User.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:281)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:295)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:274)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:155)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:27)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:377)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Dez. 05, 2024 11:06:05 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNUNG: Error indexing C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\User.scala
java.nio.file.NoSuchFileException: C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\app\models\User.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:440)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:300)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:281)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:295)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:274)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:155)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:27)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:377)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.12.05 23:06:12 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 23:06:15 INFO  time: compiled root in 3.23s
Dez. 05, 2024 11:06:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1420
Dez. 05, 2024 11:06:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1421
2024.12.05 23:06:24 INFO  compiling root (15 scala sources and 1 java source)
2024.12.05 23:06:36 WARN  Unexpected javac output: WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions (file:/C:/Users/sti/AppData/Local/bloop/cache/semanticdb/com.sourcegraph.semanticdb-javac.0.10.3/semanticdb-javac-0.10.3.jar) to method com.sun.tools.javac.api.BasicJavacTask.getContext()
WARNING: Please consider reporting this to the maintainers of com.sourcegraph.shaded.com.sourcegraph.semanticdb_javac.SemanticdbJavacOptions
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag '-'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'Leicom'
package controllers;
^
C:\Users\sti\OneDrive - Leicom AG\Desktop\HTWG\Web_App\backend\target\scala-2.13\routes\main\controllers\routes.java:4: error: semanticdb-javac: unknown flag 'AG/Desktop/HTWG/Web_App/backend'
package controllers;
^
3 errors.
2024.12.05 23:06:36 WARN  javac exited with exit code 1
2024.12.05 23:06:36 INFO  time: compiled root in 12s
Dez. 05, 2024 11:32:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1580
