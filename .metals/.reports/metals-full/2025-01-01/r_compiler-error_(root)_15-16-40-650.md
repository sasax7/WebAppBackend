file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/repositories/AdvancedTradeRepository.scala
### scala.reflect.internal.FatalError: class Object does not have a method getClass

occurred in the presentation compiler.

presentation compiler configuration:
Scala version: 2.13.12
Classpath:
<WORKSPACE>\conf [exists ], <WORKSPACE>\.bloop\root\bloop-bsp-clients-classes\classes-Metals-v0X0-SSbSXmMPza17mlJ0g== [exists ], <HOME>\AppData\Local\bloop\cache\semanticdb\com.sourcegraph.semanticdb-javac.0.10.3\semanticdb-javac-0.10.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\twirl-api_2.13\1.5.1\twirl-api_2.13-1.5.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-server_2.13\2.8.20\play-server_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-logback_2.13\2.8.20\play-logback_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-akka-http-server_2.13\2.8.20\play-akka-http-server_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\filters-helpers_2.13\2.8.20\filters-helpers_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-guice_2.13\2.8.20\play-guice_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-slick_2.13\5.0.0\play-slick_2.13-5.0.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-slick-evolutions_2.13\5.0.0\play-slick-evolutions_2.13-5.0.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\postgresql\postgresql\42.2.23\postgresql-42.2.23.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\fusesource\jansi\jansi\2.4.0\jansi-2.4.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-xml_2.13\1.3.1\scala-xml_2.13-1.3.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play_2.13\2.8.20\play_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\qos\logback\logback-classic\1.2.12\logback-classic-1.2.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-streams_2.13\2.8.20\play-streams_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-http-core_2.13\10.1.15\akka-http-core_2.13-10.1.15.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\inject\guice\5.1.0\guice-5.1.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\inject\extensions\guice-assistedinject\4.2.3\guice-assistedinject-4.2.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\slick\slick_2.13\3.3.2\slick_2.13-3.3.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\slick\slick-hikaricp_2.13\3.3.2\slick-hikaricp_2.13-3.3.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-jdbc-api_2.13\2.8.0\play-jdbc-api_2.13-2.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-jdbc-evolutions_2.13\2.8.0\play-jdbc-evolutions_2.13-2.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\checkerframework\checker-qual\3.8.0\checker-qual-3.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\build-link\2.8.20\build-link-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\slf4j\slf4j-api\1.7.36\slf4j-api-1.7.36.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\slf4j\jul-to-slf4j\1.7.36\jul-to-slf4j-1.7.36.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\slf4j\jcl-over-slf4j\1.7.36\jcl-over-slf4j-1.7.36.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-actor_2.13\2.6.21\akka-actor_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-actor-typed_2.13\2.6.21\akka-actor-typed_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-slf4j_2.13\2.6.21\akka-slf4j_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-serialization-jackson_2.13\2.6.21\akka-serialization-jackson_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-core\2.11.4\jackson-core-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-annotations\2.11.4\jackson-annotations-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.11.4\jackson-datatype-jdk8-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.11.4\jackson-datatype-jsr310-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-databind\2.11.4\jackson-databind-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-json_2.13\2.8.2\play-json_2.13-2.8.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\guava\guava\30.1.1-jre\guava-30.1.1-jre.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\io\jsonwebtoken\jjwt\0.9.1\jjwt-0.9.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\jakarta\xml\bind\jakarta.xml.bind-api\2.3.3\jakarta.xml.bind-api-2.3.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\jakarta\transaction\jakarta.transaction-api\1.3.3\jakarta.transaction-api-1.3.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\javax\inject\javax.inject\1\javax.inject-1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-java8-compat_2.13\1.0.2\scala-java8-compat_2.13-1.0.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\ssl-config-core_2.13\0.4.3\ssl-config-core_2.13-0.4.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-parser-combinators_2.13\1.1.2\scala-parser-combinators_2.13-1.1.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\qos\logback\logback-core\1.2.12\logback-core-1.2.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\reactivestreams\reactive-streams\1.0.4\reactive-streams-1.0.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-stream_2.13\2.6.21\akka-stream_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-parsing_2.13\10.1.15\akka-parsing_2.13-10.1.15.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\aopalliance\aopalliance\1.0\aopalliance-1.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\config\1.4.2\config-1.4.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-collection-compat_2.13\2.0.0\scala-collection-compat_2.13-2.0.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\zaxxer\HikariCP\3.2.0\HikariCP-3.2.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-exceptions\2.8.20\play-exceptions-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\module\jackson-module-parameter-names\2.11.4\jackson-module-parameter-names-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\dataformat\jackson-dataformat-cbor\2.11.4\jackson-dataformat-cbor-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\module\jackson-module-scala_2.13\2.11.4\jackson-module-scala_2.13-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\lz4\lz4-java\1.8.0\lz4-java-1.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-functional_2.13\2.8.2\play-functional_2.13-2.8.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\joda-time\joda-time\2.10.5\joda-time-2.10.5.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\guava\failureaccess\1.0.1\failureaccess-1.0.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\errorprone\error_prone_annotations\2.5.1\error_prone_annotations-2.5.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\j2objc\j2objc-annotations\1.3\j2objc-annotations-1.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\jakarta\activation\jakarta.activation-api\1.2.2\jakarta.activation-api-1.2.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-protobuf-v3_2.13\2.6.21\akka-protobuf-v3_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\module\jackson-module-paranamer\2.11.4\jackson-module-paranamer-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\thoughtworks\paranamer\paranamer\2.8\paranamer-2.8.jar [exists ]
Options:
-deprecation -unchecked -encoding utf8 -Yrangepos -Xplugin-require:semanticdb -release 11


action parameters:
offset: 3972
uri: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/repositories/AdvancedTradeRepository.scala
text:
```scala
package repositories

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import models._
import slick.jdbc.PostgresProfile.api._
import play.api.db.slick.DatabaseConfigProvider
import java.sql.Timestamp
import models.Candlestick._
import scala.math.abs
import play.api.libs.json._
import slick.lifted.ProvenShape
@Singleton
class AdvancedTradeRepository @Inject() (
    dbConfigProvider: DatabaseConfigProvider
)(implicit ec: ExecutionContext) {
  private val dbConfig = dbConfigProvider.get[slick.jdbc.JdbcProfile]
  private val db = dbConfig.db

  private val advancedTrades = TableQuery[AdvancedTradeTable]
  private val indicators = TableQuery[IndicatorTable]
  private val pricePoints = TableQuery[PricePointTable]
  private val stopLosses = TableQuery[StopLossTable]
  private val takeProfits = TableQuery[TakeProfitTable]
  private val tradeRRs = TableQuery[TradeRRTable]
  private val candlesticks = TableQuery[CandlestickTable]
  private val pairs = TableQuery[PairTable]
  private val indicatorNames = TableQuery[IndicatorNameTable]
  private val pricePointNames = TableQuery[PricePointNameTable]
  private val stopLossNames = TableQuery[StopLossNameTable]
  private val takeProfitNames = TableQuery[TakeProfitNameTable]
  def addTakeProfit(
    price: Double,
    tradeId: Long,
    takeProfitNameId: Long,
    pairId: Long,
    startDate: Timestamp
): Future[TakeProfit] = {
  val isBuyQuery = advancedTrades.filter(_.id === tradeId).map(_.isBuy).result.head

  val timeHitQuery = for {
    isBuy <- isBuyQuery
    timeHit <- candlesticks
      .filter(c =>
        c.pair_id === pairId && c.timeframe === "1m" && c.time >= startDate.getTime
      )
      .filter { c =>
        if (isBuy) c.high >= price
        else c.low <= price
      }
      .sortBy(_.time.asc)
      .map(_.time)
      .result
      .headOption
  } yield timeHit

  def lowestPriceQuery(startTime: Long, endTime: Long, isBuy: Boolean): DBIO[Double] = {
    val query = candlesticks
      .filter(c =>
        c.pair_id === pairId &&
          c.timeframe === "1m" &&
          c.time >= startTime &&
          c.time <= endTime
      )

    val priceQuery =
      if (isBuy) query.map(_.low).min.result
      else query.map(_.high).max.result

    priceQuery.map {
      case Some(price) => price
      case None        => price
    }
  }

  def calculateRRs(tradeId: Long, takeProfitId: Long, price: Double, isBuy: Boolean): DBIO[Unit] = {
    val stopLossesQuery = stopLosses.filter(_.tradeId === tradeId).result

    stopLossesQuery.flatMap { stopLosses =>
      val rrs = stopLosses.map { stopLoss =>
        val rr = if (isBuy) {
          if (stopLoss.highestPrice.exists(_ >= price)) {
            (price - stopLoss.price) / (stopLoss.price - stopLoss.entryPrice)
          } else {
            -1.0
          }
        } else {
          if (stopLoss.highestPrice.exists(_ <= price)) {
            (stopLoss.price - price) / (stopLoss.entryPrice - stopLoss.price)
          } else {
            -1.0
          }
        }

        TradeRR(
          id = None,
          takeProfitId = takeProfitId,
          stopLossId = stopLoss.id.get,
          rr = rr
        )
      }

      tradeRRs ++= rrs
    }
  }

  val action = for {
    isBuy <- isBuyQuery
    timeHitOpt <- timeHitQuery
    lowestPrice <- timeHitOpt match {
      case Some(timeHit) =>
        lowestPriceQuery(startDate.getTime, timeHit, isBuy)
      case None =>
        DBIO.successful(price)
    }

    newTakeProfit <- (takeProfits returning takeProfits.map(_.id) into ((takeProfit, id) =>
      takeProfit.copy(id = Some(id))
    )) += TakeProfit(
      id = None,
      price = price,
      timeHit = timeHitOpt.map(new Timestamp(_)),
      lowestPrice = Some(lowestPrice),
      tradeId = tradeId,
      takeProfitNameId = takeProfitNameId@@
    )

    _ <- calculateRRs(tradeId, newTakeProfit.id.get, price, isBuy)
  } yield newTakeProfit

  db.run(action.transactionally)
}
  def addIndicator(
      value: Double,
      time: Option[Timestamp],
      indicatorNameId: Long,
      tradeId: Long
  ): Future[Indicator] = {
    val newIndicator = Indicator(
      id = None,
      value = value,
      time = time,
      indicatorNameId = indicatorNameId,
      tradeId = tradeId
    )

    val action =
      (indicators returning indicators.map(_.id) into ((indicator, id) =>
        indicator.copy(id = Some(id))
      )) += newIndicator

    db.run(action)
  }
  def addPricePoint(
      value: Double,
      time: Timestamp,
      pricePointNameId: Long,
      tradeId: Long
  ): Future[PricePoint] = {
    val newPricePoint = PricePoint(
      id = None,
      value = value,
      time = time, // Directly assign the Timestamp
      pricePointNameId = pricePointNameId,
      tradeId = tradeId
    )

    val action =
      (pricePoints returning pricePoints.map(_.id) into ((pricePoint, id) =>
        pricePoint.copy(id = Some(id))
      )) += newPricePoint

    db.run(action)
  }
  def getTradeObjectById(tradeId: Long): Future[Option[AdvancedTradeObject]] = {
    val baseQuery = for {
      t <- advancedTrades if t.id === tradeId
      p <- pairs if t.pairId === p.id
    } yield (t, p.pairName)

    val stopLossQuery = for {
      stopLoss <- stopLosses
      stopLossName <- stopLossNames
      if stopLoss.stopLossNameId === stopLossName.id
      t <- advancedTrades if stopLoss.tradeId === t.id && t.id === tradeId
    } yield (stopLoss, stopLossName.name)

    val takeProfitQuery = for {
      takeProfit <- takeProfits
      takeProfitName <- takeProfitNames
      if takeProfit.takeProfitNameId === takeProfitName.id
      t <- advancedTrades if takeProfit.tradeId === t.id && t.id === tradeId
    } yield (takeProfit, takeProfitName.name)

    val indicatorQuery = for {
      indicator <- indicators
      indicatorName <- indicatorNames
      if indicator.indicatorNameId === indicatorName.id
      t <- advancedTrades if indicator.tradeId === t.id && t.id === tradeId
    } yield (indicator, indicatorName.name)

    val pricePointQuery = for {
      pricePoint <- pricePoints
      pricePointName <- pricePointNames
      if pricePoint.pricePointNameId === pricePointName.id
      t <- advancedTrades if pricePoint.tradeId === t.id && t.id === tradeId
    } yield (pricePoint, pricePointName.name)

    val tradeRRQuery = for {
      tradeRR <- tradeRRs
      stopLoss <- stopLosses if tradeRR.stopLossId === stopLoss.id
      takeProfit <- takeProfits if tradeRR.takeProfitId === takeProfit.id
      t <- advancedTrades
      if t.id === tradeId && stopLoss.tradeId === t.id && takeProfit.tradeId === t.id
    } yield tradeRR

    for {
      trades <- db.run(baseQuery.result)
      stopLossesResult <- db.run(stopLossQuery.result)
      takeProfitsResult <- db.run(takeProfitQuery.result)
      indicatorsResult <- db.run(indicatorQuery.result)
      pricePointsResult <- db.run(pricePointQuery.result)
      tradeRRsResult <- db.run(tradeRRQuery.result)
    } yield {
      trades.headOption.map { case (trade, pairName) =>
        val tradeStopLosses = stopLossesResult.map(_._1)
        val tradeTakeProfits = takeProfitsResult.map(_._1)
        val tradeIndicators = indicatorsResult.map(_._1)
        val tradePricePoints = pricePointsResult.map(_._1)
        AdvancedTradeObject(
          trade = trade,
          stopLosses = tradeStopLosses,
          takeProfits = tradeTakeProfits,
          indicators = tradeIndicators,
          pricePoints = tradePricePoints,
          tradeRRs = tradeRRsResult
        )
      }
    }
  }
  def getTradesByStrategyIdObject(
      strategyId: Long
  ): Future[Seq[AdvancedTradeObject]] = {
    val query = for {
      trade <- advancedTrades if trade.strategyId === strategyId
      pair <- pairs if trade.pairId === pair.id
    } yield (trade, pair.pairName)

    val stopLossQuery = for {
      stopLoss <- stopLosses
      stopLossName <- stopLossNames
      if stopLoss.stopLossNameId === stopLossName.id
      trade <- advancedTrades
      if stopLoss.tradeId === trade.id && trade.strategyId === strategyId
    } yield (stopLoss, stopLossName.name, trade)

    val takeProfitQuery = for {
      takeProfit <- takeProfits
      takeProfitName <- takeProfitNames
      if takeProfit.takeProfitNameId === takeProfitName.id
      trade <- advancedTrades
      if takeProfit.tradeId === trade.id && trade.strategyId === strategyId
    } yield (takeProfit, takeProfitName.name, trade)

    val indicatorQuery = for {
      indicator <- indicators
      indicatorName <- indicatorNames
      if indicator.indicatorNameId === indicatorName.id
      trade <- advancedTrades
      if indicator.tradeId === trade.id && trade.strategyId === strategyId
    } yield (indicator, indicatorName.name, trade)

    val pricePointQuery = for {
      pricePoint <- pricePoints
      pricePointName <- pricePointNames
      if pricePoint.pricePointNameId === pricePointName.id
      trade <- advancedTrades
      if pricePoint.tradeId === trade.id && trade.strategyId === strategyId
    } yield (pricePoint, pricePointName.name, trade)

    val tradeRRQuery = for {
      tradeRR <- tradeRRs
      stopLoss <- stopLosses if tradeRR.stopLossId === stopLoss.id
      takeProfit <- takeProfits if tradeRR.takeProfitId === takeProfit.id
      trade <- advancedTrades
      if stopLoss.tradeId === trade.id && takeProfit.tradeId === trade.id && trade.strategyId === strategyId
    } yield (tradeRR, trade)

    for {
      trades <- db.run(query.result)
      stopLosses <- db.run(stopLossQuery.result)
      takeProfits <- db.run(takeProfitQuery.result)
      indicators <- db.run(indicatorQuery.result)
      pricePoints <- db.run(pricePointQuery.result)
      tradeRRs <- db.run(tradeRRQuery.result)
    } yield {
      trades.map { case (trade, pairName) =>
        val tradeStopLosses = stopLosses.collect {
          case (stopLoss, stopLossName, t) if t.id == trade.id => stopLoss
        }
        val tradeTakeProfits = takeProfits.collect {
          case (takeProfit, takeProfitName, t) if t.id == trade.id => takeProfit
        }
        val tradeIndicators = indicators.collect {
          case (indicator, indicatorName, t) if t.id == trade.id => indicator
        }
        val tradePricePoints = pricePoints.collect {
          case (pricePoint, pricePointName, t) if t.id == trade.id => pricePoint
        }
        val tradeRRsForTrade = tradeRRs.collect {
          case (tradeRR, t) if t.id == trade.id => tradeRR
        }
        AdvancedTradeObject(
          trade = trade,
          stopLosses = tradeStopLosses,
          takeProfits = tradeTakeProfits,
          indicators = tradeIndicators,
          pricePoints = tradePricePoints,
          tradeRRs = tradeRRsForTrade
        )
      }
    }
  }

  def addAdvancedTrade(
      start_date: Timestamp,
      entry_price: BigDecimal,
      stop_loss: BigDecimal,
      strategy_id: Long,
      pair_id: Long
  ): Future[Option[Long]] = {
    val is_buy = entry_price > stop_loss

    val triggeredDateQuery = candlesticks
      .filter(c =>
        c.pair_id === pair_id && c.timeframe === "1m" && c.time >= start_date.getTime
      )
      .filter { c =>
        if (is_buy) c.low <= entry_price.toDouble
        else c.high >= entry_price.toDouble
      }
      .sortBy(_.time.asc)
      .map(_.time)
      .result
      .headOption

    val timeHitQuery = candlesticks
      .filter(c =>
        c.pair_id === pair_id && c.timeframe === "1m" && c.time >= start_date.getTime
      )
      .filter { c =>
        if (is_buy) c.low <= stop_loss.toDouble
        else c.high >= stop_loss.toDouble
      }
      .sortBy(_.time.asc)
      .map(_.time)
      .result
      .headOption

    def highestOrLowestPriceQuery(
        startTime: Long,
        endTime: Long,
        isBuy: Boolean
    ): DBIO[Double] = {
      val query = candlesticks
        .filter(c =>
          c.pair_id === pair_id &&
            c.timeframe === "1m" &&
            c.time >= startTime &&
            c.time <= endTime
        )

      val priceQuery =
        if (isBuy) query.map(_.high).max.result
        else query.map(_.low).min.result

      priceQuery.map {
        case Some(price) => price
        case None        => entry_price.toDouble
      }
    }

    def getNextCandleOpen(startTime: Long): DBIO[Option[Double]] = {
      candlesticks
        .filter(c =>
          c.pair_id === pair_id &&
            c.timeframe === "1m" &&
            c.time > startTime
        )
        .sortBy(_.time.asc)
        .map(_.open)
        .result
        .headOption
    }

    val action = for {
      triggeredDateOpt <- triggeredDateQuery
      timeHitOpt <- timeHitQuery

      effectiveEntryPrice <- triggeredDateOpt match {
        case Some(triggeredTime) if triggeredTime == start_date.getTime =>
          getNextCandleOpen(triggeredTime).map(
            _.getOrElse(entry_price.toDouble)
          )
        case _ =>
          DBIO.successful(entry_price.toDouble)
      }

      highestPrice <- triggeredDateOpt match {
        case Some(triggeredTime) =>
          val endTime = timeHitOpt.getOrElse(System.currentTimeMillis())
          highestOrLowestPriceQuery(triggeredTime, endTime, is_buy)
        case None =>
          DBIO.successful(entry_price.toDouble)
      }

      highestRR = {
        val profitDistance = abs(highestPrice - effectiveEntryPrice)
        val riskDistance = abs(effectiveEntryPrice - stop_loss.toDouble)
        if (riskDistance > 0) profitDistance / riskDistance else 0.0
      }

      newTradeId <- (advancedTrades returning advancedTrades.map(
        _.id
      )) += AdvancedTrade(
        id = None,
        startDate = start_date,
        triggeredDate = triggeredDateOpt.map(time => new Timestamp(time)),
        isBuy = is_buy,
        entryPrice = BigDecimal(effectiveEntryPrice),
        strategyId = strategy_id,
        pairId = pair_id
      )

      _ <- stopLosses += StopLoss(
        id = None,
        price = stop_loss.toDouble,
        timeHit = timeHitOpt.map(new java.sql.Timestamp(_)),
        highestPrice = Some(highestPrice),
        highestRR = Some(highestRR),
        hit1RR = highestRR >= 1.0,
        tradeId = newTradeId,
        stopLossNameId = 1
      )
    } yield Some(newTradeId)

    db.run(action.transactionally)
  }
  def getTradesByStrategyId(strategyId: Long): Future[Seq[JsObject]] = {
    val query = for {
      trade <- advancedTrades if trade.strategyId === strategyId
      pair <- pairs if trade.pairId === pair.id
    } yield (trade, pair.pairName)

    val stopLossQuery = for {
      stopLoss <- stopLosses
      stopLossName <- stopLossNames
      if stopLoss.stopLossNameId === stopLossName.id
      trade <- advancedTrades
      if stopLoss.tradeId === trade.id && trade.strategyId === strategyId
    } yield (stopLoss, stopLossName.name, trade)

    val takeProfitQuery = for {
      takeProfit <- takeProfits
      takeProfitName <- takeProfitNames
      if takeProfit.takeProfitNameId === takeProfitName.id
      trade <- advancedTrades
      if takeProfit.tradeId === trade.id && trade.strategyId === strategyId
    } yield (takeProfit, takeProfitName.name, trade)

    val indicatorQuery = for {
      indicator <- indicators
      indicatorName <- indicatorNames
      if indicator.indicatorNameId === indicatorName.id
      trade <- advancedTrades
      if indicator.tradeId === trade.id && trade.strategyId === strategyId
    } yield (indicator, indicatorName.name, trade)

    val pricePointQuery = for {
      pricePoint <- pricePoints
      pricePointName <- pricePointNames
      if pricePoint.pricePointNameId === pricePointName.id
      trade <- advancedTrades
      if pricePoint.tradeId === trade.id && trade.strategyId === strategyId
    } yield (pricePoint, pricePointName.name, trade)

    for {
      trades <- db.run(query.result)
      stopLosses <- db.run(stopLossQuery.result)
      takeProfits <- db.run(takeProfitQuery.result)
      indicators <- db.run(indicatorQuery.result)
      pricePoints <- db.run(pricePointQuery.result)
    } yield {
      trades.map { case (trade, pairName) =>
        val tradeStopLosses = stopLosses.collect {
          case (stopLoss, stopLossName, t) if t.id == trade.id =>
            Json.obj(
              "stopLoss" -> Json.toJson(stopLoss),
              "name" -> stopLossName
            )
        }
        val tradeTakeProfits = takeProfits.collect {
          case (takeProfit, takeProfitName, t) if t.id == trade.id =>
            Json.obj(
              "takeProfit" -> Json.toJson(takeProfit),
              "name" -> takeProfitName
            )
        }
        val tradeIndicators = indicators.collect {
          case (indicator, indicatorName, t) if t.id == trade.id =>
            Json.obj(
              "indicator" -> Json.toJson(indicator),
              "name" -> indicatorName
            )
        }
        val tradePricePoints = pricePoints.collect {
          case (pricePoint, pricePointName, t) if t.id == trade.id =>
            Json.obj(
              "pricePoint" -> Json.toJson(pricePoint),
              "name" -> pricePointName
            )
        }
        Json.obj(
          "trade" -> Json.obj(
            "trade" -> Json.toJson(
              trade
            ), // This will use AdvancedTrade.format and apply the timestampFormat
            "stopLosses" -> tradeStopLosses,
            "takeProfits" -> tradeTakeProfits,
            "indicators" -> tradeIndicators,
            "pricePoints" -> tradePricePoints
          )
        )
      }
    }
  }

}

```



#### Error stacktrace:

```
scala.reflect.internal.Definitions$DefinitionsClass.fatalMissingSymbol(Definitions.scala:1411)
	scala.reflect.internal.Definitions$DefinitionsClass.miss$1(Definitions.scala:1464)
	scala.reflect.internal.Definitions$DefinitionsClass.$anonfun$getMemberMethod$2(Definitions.scala:1466)
	scala.reflect.internal.Definitions$DefinitionsClass.getMemberMethod(Definitions.scala:1466)
	scala.reflect.internal.Definitions$DefinitionsClass.Any_getClass$lzycompute(Definitions.scala:1172)
	scala.reflect.internal.Definitions$DefinitionsClass.Any_getClass(Definitions.scala:1172)
	scala.reflect.internal.Definitions$DefinitionsClass.syntheticCoreMethods$lzycompute(Definitions.scala:1578)
	scala.reflect.internal.Definitions$DefinitionsClass.syntheticCoreMethods(Definitions.scala:1572)
	scala.reflect.internal.Definitions$DefinitionsClass.symbolsNotPresentInBytecode$lzycompute(Definitions.scala:1603)
	scala.reflect.internal.Definitions$DefinitionsClass.symbolsNotPresentInBytecode(Definitions.scala:1603)
	scala.reflect.internal.Definitions$DefinitionsClass.init(Definitions.scala:1659)
	scala.tools.nsc.Global$Run.<init>(Global.scala:1249)
	scala.tools.nsc.interactive.Global$TyperRun.<init>(Global.scala:1352)
	scala.tools.nsc.interactive.Global.newTyperRun(Global.scala:1375)
	scala.tools.nsc.interactive.Global.<init>(Global.scala:294)
	scala.meta.internal.pc.MetalsGlobal.<init>(MetalsGlobal.scala:44)
	scala.meta.internal.pc.ScalaPresentationCompiler.newCompiler(ScalaPresentationCompiler.scala:522)
```
#### Short summary: 

scala.reflect.internal.FatalError: class Object does not have a method getClass