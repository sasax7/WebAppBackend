file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/models/State/BacktestState.scala
### scala.reflect.internal.FatalError: class Object does not have a method getClass

occurred in the presentation compiler.

presentation compiler configuration:
Scala version: 2.13.12
Classpath:
<WORKSPACE>\conf [exists ], <WORKSPACE>\.bloop\root\bloop-bsp-clients-classes\classes-Metals-v0X0-SSbSXmMPza17mlJ0g== [exists ], <HOME>\AppData\Local\bloop\cache\semanticdb\com.sourcegraph.semanticdb-javac.0.10.3\semanticdb-javac-0.10.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\twirl-api_2.13\1.5.1\twirl-api_2.13-1.5.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-server_2.13\2.8.20\play-server_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-logback_2.13\2.8.20\play-logback_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-akka-http-server_2.13\2.8.20\play-akka-http-server_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\filters-helpers_2.13\2.8.20\filters-helpers_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-guice_2.13\2.8.20\play-guice_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-slick_2.13\5.0.0\play-slick_2.13-5.0.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-slick-evolutions_2.13\5.0.0\play-slick-evolutions_2.13-5.0.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\postgresql\postgresql\42.2.23\postgresql-42.2.23.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\fusesource\jansi\jansi\2.4.0\jansi-2.4.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-xml_2.13\1.3.1\scala-xml_2.13-1.3.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play_2.13\2.8.20\play_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\qos\logback\logback-classic\1.2.12\logback-classic-1.2.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-streams_2.13\2.8.20\play-streams_2.13-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-http-core_2.13\10.1.15\akka-http-core_2.13-10.1.15.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\inject\guice\5.1.0\guice-5.1.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\inject\extensions\guice-assistedinject\4.2.3\guice-assistedinject-4.2.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\slick\slick_2.13\3.3.2\slick_2.13-3.3.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\slick\slick-hikaricp_2.13\3.3.2\slick-hikaricp_2.13-3.3.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-jdbc-api_2.13\2.8.0\play-jdbc-api_2.13-2.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-jdbc-evolutions_2.13\2.8.0\play-jdbc-evolutions_2.13-2.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\checkerframework\checker-qual\3.8.0\checker-qual-3.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\build-link\2.8.20\build-link-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\slf4j\slf4j-api\1.7.36\slf4j-api-1.7.36.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\slf4j\jul-to-slf4j\1.7.36\jul-to-slf4j-1.7.36.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\slf4j\jcl-over-slf4j\1.7.36\jcl-over-slf4j-1.7.36.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-actor_2.13\2.6.21\akka-actor_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-actor-typed_2.13\2.6.21\akka-actor-typed_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-slf4j_2.13\2.6.21\akka-slf4j_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-serialization-jackson_2.13\2.6.21\akka-serialization-jackson_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-core\2.11.4\jackson-core-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-annotations\2.11.4\jackson-annotations-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.11.4\jackson-datatype-jdk8-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.11.4\jackson-datatype-jsr310-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-databind\2.11.4\jackson-databind-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-json_2.13\2.8.2\play-json_2.13-2.8.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\guava\guava\30.1.1-jre\guava-30.1.1-jre.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\io\jsonwebtoken\jjwt\0.9.1\jjwt-0.9.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\jakarta\xml\bind\jakarta.xml.bind-api\2.3.3\jakarta.xml.bind-api-2.3.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\jakarta\transaction\jakarta.transaction-api\1.3.3\jakarta.transaction-api-1.3.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\javax\inject\javax.inject\1\javax.inject-1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-java8-compat_2.13\1.0.2\scala-java8-compat_2.13-1.0.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\ssl-config-core_2.13\0.4.3\ssl-config-core_2.13-0.4.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-parser-combinators_2.13\1.1.2\scala-parser-combinators_2.13-1.1.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\qos\logback\logback-core\1.2.12\logback-core-1.2.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\reactivestreams\reactive-streams\1.0.4\reactive-streams-1.0.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-stream_2.13\2.6.21\akka-stream_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-parsing_2.13\10.1.15\akka-parsing_2.13-10.1.15.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\aopalliance\aopalliance\1.0\aopalliance-1.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\config\1.4.2\config-1.4.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-collection-compat_2.13\2.0.0\scala-collection-compat_2.13-2.0.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\zaxxer\HikariCP\3.2.0\HikariCP-3.2.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-exceptions\2.8.20\play-exceptions-2.8.20.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\module\jackson-module-parameter-names\2.11.4\jackson-module-parameter-names-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\dataformat\jackson-dataformat-cbor\2.11.4\jackson-dataformat-cbor-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\module\jackson-module-scala_2.13\2.11.4\jackson-module-scala_2.13-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\lz4\lz4-java\1.8.0\lz4-java-1.8.0.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-functional_2.13\2.8.2\play-functional_2.13-2.8.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\joda-time\joda-time\2.10.5\joda-time-2.10.5.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\guava\failureaccess\1.0.1\failureaccess-1.0.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\errorprone\error_prone_annotations\2.5.1\error_prone_annotations-2.5.1.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\google\j2objc\j2objc-annotations\1.3\j2objc-annotations-1.3.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\jakarta\activation\jakarta.activation-api\1.2.2\jakarta.activation-api-1.2.2.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-protobuf-v3_2.13\2.6.21\akka-protobuf-v3_2.13-2.6.21.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\module\jackson-module-paranamer\2.11.4\jackson-module-paranamer-2.11.4.jar [exists ], <HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\thoughtworks\paranamer\paranamer\2.8\paranamer-2.8.jar [exists ]
Options:
-deprecation -unchecked -encoding utf8 -Yrangepos -Xplugin-require:semanticdb -release 11


action parameters:
offset: 5382
uri: file:///C:/Users/sti/OneDrive%20-%20Leicom%20AG/Desktop/HTWG/Web_App/backend/app/models/State/BacktestState.scala
text:
```scala
package state

import models._
import repositories.{
  CandlesRepository,
  UsersRepository,
  StrategyRepository,
  AdvancedTradeRepository,
  PairsRepository
}
import scala.concurrent.{ExecutionContext, Future}
import play.api.libs.json._
import play.api.libs.functional.syntax._
import scala.math.abs
import java.sql.Timestamp

trait BacktestState {
  def updateTimestamp(newTimestamp: Long)(implicit
      ec: ExecutionContext,
      candlesRepository: CandlesRepository
  ): Future[BacktestState]
  def addTrade(trade: AddTradeRequest): BacktestState
}

case class OperationalState(
    newestTimestamp: Long,
    trades: Seq[Trade],
    currentPrice: BigDecimal,
    strategy: Option[Strategy],
    strategyDetails: Option[StrategyDetails],
    user: Option[User],
    currentPair: Pair,
    balance: Option[BigDecimal],
    timeframe: String,
    spread: Option[BigDecimal],
    fees: Option[BigDecimal],
    percentageRiskPerTrade: Option[BigDecimal],
    currentCandlestick: Option[Candlestick],
    nextCandlesticks: Seq[Candlestick] = Seq.empty
) extends BacktestState {

  override def updateTimestamp(newTimestamp: Long)(implicit
      ec: ExecutionContext,
      candlesRepository: CandlesRepository
  ): Future[BacktestState] = {
    val oldTimestamp = newestTimestamp
    for {
      candlesticks <- candlesRepository.getCandlesticksBatchByPairName(
        currentPair.pairName,
        "1m",
        newTimestamp,
        1
      )
      nextCandlesticks <- candlesRepository.getCandlesticksByTimeRange(
        currentPair.pairName,
        "1m",
        oldTimestamp,
        newTimestamp
      )
    } yield {
      candlesticks.headOption match {
        case Some(latestCandle) =>
          val newPrice = BigDecimal(latestCandle.close)
          val updatedTrades = trades.map { trade =>
            val profit =
              if (trade.addAdvancedTradeObject.exists(_.trade.isBuy)) {
                (newPrice - trade.addAdvancedTradeObject.get.trade.entryPrice) * trade.size
                  .getOrElse(BigDecimal(1))
              } else {
                (trade.addAdvancedTradeObject.get.trade.entryPrice - newPrice) * trade.size
                  .getOrElse(BigDecimal(1))
              }

            val newState = (
              trade.addAdvancedTradeObject.flatMap(_.trade.triggeredDate),
              trade.addAdvancedTradeObject.flatMap(
                _.stopLosses.headOption.flatMap(_.timeHit)
              ),
              trade.addAdvancedTradeObject.flatMap(
                _.takeProfits.headOption.flatMap(_.timeHit)
              )
            ) match {
              case (Some(triggeredDate), Some(slTimeHit), Some(tpTimeHit))
                  if newTimestamp >= triggeredDate.getTime =>
                if (
                  newTimestamp >= slTimeHit.getTime || newTimestamp >= tpTimeHit.getTime
                ) {
                  TradeState.Closed
                } else {
                  TradeState.Triggered
                }
              case (Some(triggeredDate), Some(slTimeHit), None)
                  if newTimestamp >= triggeredDate.getTime =>
                if (newTimestamp >= slTimeHit.getTime) {
                  TradeState.Closed
                } else {
                  TradeState.Triggered
                }
              case (Some(triggeredDate), None, Some(tpTimeHit))
                  if newTimestamp >= triggeredDate.getTime =>
                if (newTimestamp >= tpTimeHit.getTime) {
                  TradeState.Closed
                } else {
                  TradeState.Triggered
                }
              case (Some(triggeredDate), None, None)
                  if newTimestamp >= triggeredDate.getTime =>
                TradeState.Triggered
              case _ =>
                TradeState.NotTriggered
            }

            val currentProfit = newState match {
              case TradeState.NotTriggered => BigDecimal(0)
              case TradeState.Triggered =>
                if (trade.addAdvancedTradeObject.exists(_.trade.isBuy)) {
                  (newPrice - trade.addAdvancedTradeObject.get.trade.entryPrice) * trade.size
                    .getOrElse(BigDecimal(1))
                } else {
                  (trade.addAdvancedTradeObject.get.trade.entryPrice - newPrice) * trade.size
                    .getOrElse(BigDecimal(1))
                }
              case TradeState.Closed => BigDecimal(0)
            }

            trade.copy(currentProfit = Some(currentProfit), state = newState)
          }
          copy(
            newestTimestamp = newTimestamp,
            currentPrice = newPrice,
            trades = updatedTrades,
            currentCandlestick =
              Some(latestCandle), // Update the current candlestick
            nextCandlesticks = nextCandlesticks // Update the next candlesticks
          )
        case None =>
          this // No update if no candlestick data is available
      }
    }
  }
  override def addTrade(tradeData: AddTradeRequest)(implicit
      ec: ExecutionContext,
      advancedTradeRepository: AdvancedTradeRepository
  ): Future[BacktestState] = {
    val startDate = new Timestamp(newestTimestamp)
    (for {
      strategyId <- strategy.flatMap(_.id@@)
      pairId <- currentPair.id
    } yield {
      advancedTradeRepository
        .addAdvancedTrade(
          start_date = startDate,
          entry_price = tradeData.entryPrice,
          stop_loss = tradeData.stopLoss,
          strategy_id = strategyId,
          pair_id = pairId
        )
        .map {
          case Some(tradeId) =>
            // Fetch the newly added trade and update the state
            advancedTradeRepository
              .getTradesByStrategyIdObject(strategyId)
              .map { trades =>
                val newTrades = trades.map { trade =>
                  convertToTrade(trade)(
                    newestTimestamp,
                    balance,
                    percentageRiskPerTrade,
                    currentPrice
                  )
                }
                copy(trades = newTrades)
              }
          case None =>
            this // No update if the trade could not be added
        }
    }).getOrElse(Future.successful(this))
  }
}

object OperationalState {
  import models.Strategy.strategyFormat // Import the implicit format for Strategy
  import models.StrategyDetails.format // Import the implicit format for StrategyDetails
  import models.User.userFormat // Import the implicit format for User
  import models.Trade.format // Import the implicit format for Trade
  import models.Candlestick.format // Import the implicit format for Candlestick

  implicit val operationalStateWrites: OWrites[OperationalState] =
    Json.writes[OperationalState]
  implicit val operationalStateReads: Reads[OperationalState] =
    Json.reads[OperationalState]
  implicit val operationalStateFormat: OFormat[OperationalState] =
    OFormat(operationalStateReads, operationalStateWrites)

  def initialize(
      newestTimestamp: Long,
      strategyId: Long,
      userFirebaseId: String,
      currentPairName: String,
      balance: Option[BigDecimal],
      timeframe: Option[String],
      spread: Option[BigDecimal],
      fees: Option[BigDecimal],
      percentageRiskPerTrade: Option[BigDecimal]
  )(implicit
      ec: ExecutionContext,
      candlesRepository: CandlesRepository,
      usersRepository: UsersRepository,
      strategyRepository: StrategyRepository,
      advancedTradeRepository: AdvancedTradeRepository,
      pairsRepository: PairsRepository
  ): Future[OperationalState] = {
    for {
      userOpt <- usersRepository.findUserByFirebaseUid(userFirebaseId)
      strategyOpt <- strategyRepository.findStrategyById(strategyId)
      strategyDetailsOpt <- strategyRepository.findStrategyDetailsById(
        strategyId
      )
      pairOpt <- pairsRepository.getPairIdByName(currentPairName).flatMap {
        case Some(pairId) => pairsRepository.findPairById(pairId)
        case None         => Future.successful(None)
      }
      candlestickOpt <- candlesRepository
        .getCandlesticksBatchByPairName(
          currentPairName,
          "1m",
          newestTimestamp,
          1
        )
        .map(_.headOption)
      advancedTrades <- advancedTradeRepository.getTradesByStrategyIdObject(
        strategyId
      )
    } yield {
      val currentPrice = candlestickOpt.map(_.close).getOrElse(0.0)
      val trades = advancedTrades.map { trade =>
        convertToTrade(trade)(
          newestTimestamp,
          balance,
          percentageRiskPerTrade,
          BigDecimal(currentPrice)
        )
      }

      val finalBalance =
        trades.foldLeft(balance.getOrElse(BigDecimal(100000))) {
          (balance, trade) =>
            trade.state match {
              case TradeState.Closed =>
                val riskAmount =
                  balance * percentageRiskPerTrade.getOrElse(BigDecimal(0.02))
                val stopLossHitTime = trade.addAdvancedTradeObject.flatMap(
                  _.stopLosses.headOption.flatMap(_.timeHit)
                )
                val takeProfitHitTime = trade.addAdvancedTradeObject.flatMap(
                  _.takeProfits.headOption.flatMap(_.timeHit)
                )

                (stopLossHitTime, takeProfitHitTime) match {
                  case (Some(slTime), Some(tpTime)) =>
                    if (tpTime.before(slTime)) {
                      balance + riskAmount
                    } else {
                      balance - riskAmount
                    }
                  case (Some(_), None) =>
                    trade.addAdvancedTradeObject.flatMap(
                      _.stopLosses.headOption
                    ) match {
                      case Some(stopLoss) if stopLoss.hit1RR =>
                        balance + riskAmount
                      case _ =>
                        balance - riskAmount
                    }
                  case (None, Some(_)) =>
                    balance + riskAmount
                  case (None, None) =>
                    balance
                }
              case _ => balance
            }
        }
      (
        userOpt,
        strategyOpt,
        strategyDetailsOpt,
        pairOpt,
        candlestickOpt
      ) match {
        case (
              Some(user),
              Some(strategy),
              Some(strategyDetails),
              Some(pair),
              Some(candlestick)
            ) =>
          OperationalState(
            newestTimestamp = newestTimestamp,
            trades = trades,
            currentPrice = BigDecimal(candlestick.close),
            strategy = Some(strategy),
            strategyDetails = Some(strategyDetails),
            user = Some(user),
            currentPair = pair,
            balance = Some(finalBalance),
            timeframe = timeframe.getOrElse("1m"),
            spread = spread.orElse(Some(BigDecimal(0))),
            fees = fees.orElse(Some(BigDecimal(0))),
            percentageRiskPerTrade =
              percentageRiskPerTrade.orElse(Some(BigDecimal(0.02))),
            currentCandlestick = Some(candlestick)
          )
        case _ =>
          throw new Exception(
            "Invalid user, strategy, pair, or candlestick data"
          )
      }
    }
  }
  def convertToTrade(
      advancedTradeObject: AdvancedTradeObject
  )(implicit
      newestTimestamp: Long,
      balance: Option[BigDecimal],
      percentageRiskPerTrade: Option[BigDecimal],
      currentPrice: BigDecimal
  ): Trade = {
    val advancedTrade = advancedTradeObject.trade
    val stopLoss = advancedTradeObject.stopLosses.headOption
    val takeProfit = advancedTradeObject.takeProfits.headOption

    val state = (advancedTrade.triggeredDate, stopLoss, takeProfit) match {
      case (Some(triggeredDate), Some(sl), Some(tp))
          if newestTimestamp >= triggeredDate.getTime =>
        if (
          newestTimestamp >= sl.timeHit
            .map(_.getTime)
            .getOrElse(Long.MaxValue) || newestTimestamp >= tp.timeHit
            .map(_.getTime)
            .getOrElse(Long.MaxValue)
        ) {
          TradeState.Closed
        } else {
          TradeState.Triggered
        }
      case (Some(triggeredDate), Some(sl), None)
          if newestTimestamp >= triggeredDate.getTime =>
        if (
          newestTimestamp >= sl.timeHit.map(_.getTime).getOrElse(Long.MaxValue)
        ) {
          TradeState.Closed
        } else {
          TradeState.Triggered
        }
      case (Some(triggeredDate), None, Some(tp))
          if newestTimestamp >= triggeredDate.getTime =>
        if (
          newestTimestamp >= tp.timeHit.map(_.getTime).getOrElse(Long.MaxValue)
        ) {
          TradeState.Closed
        } else {
          TradeState.Triggered
        }
      case (Some(triggeredDate), None, None)
          if newestTimestamp >= triggeredDate.getTime =>
        TradeState.Triggered
      case _ =>
        TradeState.NotTriggered
    }

    // Convert any numeric values to BigDecimal explicitly:
    val riskPercentage = percentageRiskPerTrade.getOrElse(BigDecimal(0.02))
    val balanceValue = balance.getOrElse(BigDecimal(100000))
    val entryPrice = advancedTrade.entryPrice
    val exitPrice =
      stopLoss.map(sl => BigDecimal(sl.price)).getOrElse(BigDecimal(0))

    val difference: BigDecimal = (entryPrice - exitPrice).abs
    val size: BigDecimal =
      if (difference > 0) (balanceValue * riskPercentage) / difference
      else BigDecimal(0)

    val currentProfit = state match {
      case TradeState.NotTriggered => BigDecimal(0)
      case TradeState.Triggered =>
        if (advancedTrade.isBuy) {
          (currentPrice - entryPrice) * size
        } else {
          (entryPrice - currentPrice) * size
        }
      case TradeState.Closed => BigDecimal(0)
    }
    Trade(
      addAdvancedTradeObject = Some(advancedTradeObject),
      currentProfit = Some(
        currentProfit
      ),
      size = Some(size), // Calculated size
      state = state // Determined state
    )
  }
}

```



#### Error stacktrace:

```
scala.reflect.internal.Definitions$DefinitionsClass.fatalMissingSymbol(Definitions.scala:1411)
	scala.reflect.internal.Definitions$DefinitionsClass.miss$1(Definitions.scala:1464)
	scala.reflect.internal.Definitions$DefinitionsClass.$anonfun$getMemberMethod$2(Definitions.scala:1466)
	scala.reflect.internal.Definitions$DefinitionsClass.getMemberMethod(Definitions.scala:1466)
	scala.reflect.internal.Definitions$DefinitionsClass.Any_getClass$lzycompute(Definitions.scala:1172)
	scala.reflect.internal.Definitions$DefinitionsClass.Any_getClass(Definitions.scala:1172)
	scala.reflect.internal.Definitions$DefinitionsClass.syntheticCoreMethods$lzycompute(Definitions.scala:1578)
	scala.reflect.internal.Definitions$DefinitionsClass.syntheticCoreMethods(Definitions.scala:1572)
	scala.reflect.internal.Definitions$DefinitionsClass.symbolsNotPresentInBytecode$lzycompute(Definitions.scala:1603)
	scala.reflect.internal.Definitions$DefinitionsClass.symbolsNotPresentInBytecode(Definitions.scala:1603)
	scala.reflect.internal.Definitions$DefinitionsClass.init(Definitions.scala:1659)
	scala.tools.nsc.Global$Run.<init>(Global.scala:1249)
	scala.tools.nsc.interactive.Global$TyperRun.<init>(Global.scala:1352)
	scala.tools.nsc.interactive.Global.newTyperRun(Global.scala:1375)
	scala.tools.nsc.interactive.Global.<init>(Global.scala:294)
	scala.meta.internal.pc.MetalsGlobal.<init>(MetalsGlobal.scala:44)
	scala.meta.internal.pc.ScalaPresentationCompiler.newCompiler(ScalaPresentationCompiler.scala:522)
```
#### Short summary: 

scala.reflect.internal.FatalError: class Object does not have a method getClass